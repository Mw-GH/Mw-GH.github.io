<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown-lint规则</title>
    <url>/2021-02-MarkDown-lint%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>markdownlint是vscode上一款非常好用的 Markdown 格式检查扩展工具，它规定了许多规则并实时对文档进行检查，防止一些语法错误，同时维持文档风格的统一，使用此工具有助于形成一个良好的写作习惯和规范。但因其规则较多，写文档时很容易就出错（或不符合规则），所以需要对工具的规则有一个详细的了解，另外，有时工作要求的文档风格与markdownlint工具规定的规则并不相同，比如标题、列表的创建格式，缩进的空格数等等，这时就需要对规则进行一定的设置。</p>
<p>本文主要参考markdownlint的<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwMDItLS1maXJzdC1oZWFkaW5nLXNob3VsZC1iZS1hLXRvcC1sZXZlbC1oZWFkaW5n">rules文档<i class="fa fa-external-link-alt"></i></span>，对每一个规则都进行了说明，指明了一些规则中可以设置的参数，便于用户设置相应的规则。</p>
<span id="more"></span>

<h2 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h2><p>标题级数每次只能扩大1, 也就是不能隔级创建标题（从1级到6级的顺序）</p>
<h2 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top level heading"></a>MD002 - First heading should be a top level heading</h2><p>文档的第一个标题必须是最高级的标题（标题等级1级到6级逐渐降低）</p>
<p>参数：<br> “level”：指定最高级标题的级数，默认是1</p>
<h2 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h2><p>整篇文档要采用一致的标题格式</p>
<p>参数：<br> “style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”, “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p>
<p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p>
<h2 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h2><p>整篇文档定义无序列表的格式要一致</p>
<p>参数：<br> “style”：字符串，指定无序列表的定义格式，有(“consistent”, “asterisk”, “plus”, “dash”, “sublist”)五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是”consistent”</p>
<h2 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h2><p>同一级的列表缩进必须一致<br> 在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p>
<h2 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a>MD006 - Consider starting bulleted lists at the beginning of the line</h2><p>1级列表不能缩进</p>
<h2 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h2><p>无序列表嵌套缩进时默认采用两个空格</p>
<p>参数：<br> “ident”：指定无序列表嵌套时缩进的空格数，默认是2</p>
<h2 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h2><p>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p>
<p>参数：<br> “br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格<br> “list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p>
<h2 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h2><p>不能使用tab键缩进，要使用空格</p>
<p>参数：<br> “code_blocks”：指定本条规则在代码块里是否(true or false)生效</p>
<h2 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h2><p>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p>
<h2 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h2><p>文档中不能有连续的空行，在代码块中此规则不会生效</p>
<p>参数：<br> “maximum”：指定文档中可以连续的最多空行数，默认值是1</p>
<h2 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h2><p>默认行的最大长度是80，此规则对代码块、表格、标题也生效</p>
<p>参数：<br> “line_length”：指定行的最大长度，默认是80<br> “heading_line_length”：指定标题行的最大长度，默认是80<br> “code_blocks”：指定规则是否(true or false)对代码块生效，默认true<br> “tables”：指定规则是否(true or false)对表格生效，默认true<br> “hesdings”：指定规则是否(true or false)对标题生效，默认true</p>
<h2 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h2><p>在代码块中，终端命令前不需要有美元符号($)<br> 如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ls</span><br><span class="line">foo bar</span><br><span class="line"><span class="variable">$ </span>cat foo</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间需用一个空格隔开</p>
<h2 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p>
<h2 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p>
<h2 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p>
<h2 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h2><p>标题行的上下行必须都是空行</p>
<p>参数：<br> “lines_above”：指定标题行上方的空行数，默认为1，可以设为更大或0<br> “lines_below”：指定标题行下方的空行数，默认为1，可以设为更大或0</p>
<p>注意当此处的空行设为比1大的数时，规则MD012的设置也要改</p>
<h2 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h2><p>标题行不能缩进</p>
<h2 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h2><p>文档不能有内容重复的标题</p>
<p>参数：<br> “siblings_only”：默认为false，设为true时，不同标题下的子标题内容可以重复</p>
<h2 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top level headings in the same document"></a>MD025 - Multiple top level headings in the same document</h2><p>同一文档只能有一个最高级的标题，默认是只能有一个1级标题</p>
<p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p>
<h2 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h2><p>标题行末尾不能有以下标点符号：”.,;:!?”</p>
<p>参数：<br> “punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p>
<p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p>
<h2 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h2><p>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p>
<h2 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h2><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p>
<h2 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h2><p>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字(“one_or_ordered”)</p>
<p>参数：<br> “style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是”one_or_ordered”</p>
<p>本条规则支持在前缀序号中补0，以实现对齐，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">08.  one</span><br><span class="line">09.  two</span><br><span class="line">10.  three</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h2><p>列表（有序、无序）的前缀符号和文字之间用1个空格隔开<br> 在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p>
<p>参数：<br> “ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1</p>
<h2 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h2><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p>
<h2 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h2><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br> 列表的缩进必须一致，否则会警告</p>
<h2 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h2><p>文档中不允许使用HTML语句</p>
<p>参数：<br> “allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p>
<h2 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h2><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p>
<h2 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h2><p>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p>
<p>参数：<br> “style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***”,”—“,”___”)，默认是”consistent”</p>
<h2 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h2><p>不能用强调代替标题</p>
<p>参数：<br> “punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p>
<p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p>
<h2 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h2><p>用于创建强调的符号和强调的的文字之间不能有空格</p>
<h2 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h2><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br> 如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p>
<h2 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h2><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">百 度</span>](http:<span class="comment">//www.baidu.com &quot;百 度&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h2><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p>
<h2 id="MD041-First-line-in-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in file should be a top level heading"></a>MD041 - First line in file should be a top level heading</h2><p>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p>
<p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p>
<h2 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h2><p>链接的地址不能为空</p>
<h2 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h2><p>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p>
<p>参数：<br> “headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;# head&quot;</span>,</span><br><span class="line">    <span class="string">&quot;## item&quot;</span>,</span><br><span class="line">    <span class="string">&quot;### detail&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwNDMtLS1yZXF1aXJlZC1oZWFkaW5nLXN0cnVjdHVyZQ==">MD043<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h2><p>指定一些名称，会检查它是否有正确的大写</p>
<p>参数：<br> “names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br> “code_blocks”：指定本规则是否(true or false)对代码块生效，默认是true<br> 一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数”names”中，防止写错</p>
<h2 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h2><p>图片链接必须包含描述文本（alt text）</p>
<h2 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h2><p>整篇文档采用一致的代码格式</p>
<p>参数：<br> “style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p>
<h2 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h2><p>文档需用一个空行结尾</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwMDItLS1maXJzdC1oZWFkaW5nLXNob3VsZC1iZS1hLXRvcC1sZXZlbC1oZWFkaW5n">rules文档<i class="fa fa-external-link-alt"></i></span></p>
<p>原文作者：夜行的鸟<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MTUyM2ExYzZmZTE=">https://www.jianshu.com/p/51523a1c6fe1<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-三大修饰符</title>
    <url>/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="抽象abstract"><a href="#抽象abstract" class="headerlink" title="抽象abstract"></a>抽象abstract</h2><h3 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h3><p>现实中不存在的对象；具备某类别对象的特征，但不具体，不完整，不能独立存在。</p>
<p>eg：（名词） 动物，鼠标，桌子，椅子</p>
<p>动物：没有动物本身，现实中全是动物的子类对象（猫，狗）</p>
<p>鼠标：具有属性(大小，颜色，价格)，方法（移动，点击）特征，却没有鼠标本身，现实中全是各个厂家的实现</p>
<span id="more"></span>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>不该被创建的对象</p>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309194342645.png" class="">

<ul>
<li>应用：abstract修饰词，限制类不能被创建成为对象</li>
</ul>
<h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol>
<li><p>可被子类<mark>继承</mark>，提供共性属性和方法。</p>
</li>
<li><p>可声明为引用，更自然的使用<mark>多态</mark>。</p>
</li>
</ol>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309200353003.png" class="">

<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>父类提供的方法不满足子类的需求，如不定义，则表示所有动物都不会吃，睡。若定义，略显多余，多数会被子类覆盖。</p>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309203302004.png" class="">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>abstract 修饰类：不能new对象，但可以声明引用(多态)</li>
<li>abstract修饰方法：只有方法声明，没有方法实现，必须包含在抽象类中</li>
<li>抽象类不一定有抽象方法，但抽象方法一定是在抽象类中</li>
<li>子类继承抽象类后，必须重写父类中所有的抽象方法，除非子类还是抽象类</li>
</ul>
<p>代码实列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;  <span class="comment">//2.抽象方法必须在抽象类中</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//1.被子类都实现了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123; <span class="comment">//继承</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    <span class="comment">//继承抽象类必须重写抽象类中所有抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开着&quot;</span>+<span class="keyword">super</span>.brand+<span class="string">&quot;去上班&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bike</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;骑着&quot;</span>+brand+<span class="string">&quot;自行车回家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(Vehicle vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;要上班了&quot;</span>);</span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">black</span><span class="params">(Vehicle vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;该回家了&quot;</span>);</span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMaster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Master xm = <span class="keyword">new</span> Master(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Vehicle baoma = <span class="keyword">new</span> Car(<span class="string">&quot;宝马&quot;</span>);  <span class="comment">//多态父类引用指向子类</span></span><br><span class="line">        Vehicle yelv = <span class="keyword">new</span> Bike(<span class="string">&quot;野驴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        xm.go(baoma);</span><br><span class="line">        xm.black(yelv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h2><h3 id="什么是静态"><a href="#什么是静态" class="headerlink" title="什么是静态"></a>什么是静态</h3><p>个人理解：static修饰的成员 直接类名调用，不用创建类的实例，从而有效的降低内存泄漏的风险，所以应该是空间的减少</p>
<p>（工具类<br>操作全局变量<br>共享）</p>
<ul>
<li>概念：<ul>
<li>静态可以修饰属性和方法。</li>
<li>称为静态属性（类属性），静态方法（类方法）。不属于类实例出来的对象，实例出来的属性称为实例属性。</li>
<li>静态成员是全类所有对象共享的成员</li>
<li>在全类中只有一份，不因创建多个对象而产生多份</li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>特点<ul>
<li>静态方法允许直接访问静态成员</li>
<li>静态方法不能直接访问非静态成员（对象还未创建）</li>
<li>静态访问中不允许使用this或super关键字</li>
<li>静态方法可以继承，不能重写，没有多态</li>
</ul>
</li>
<li>已知静态方法<ul>
<li>Arrays.copyOf()</li>
<li>Arrays.sort()</li>
<li>Math.random()</li>
<li>Math.sqrt()</li>
</ul>
</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>类加载时，触发静态代码块的执行(仅一次)。</p>
<ul>
<li>执行顺序：静态属性初始化之后。</li>
<li>作用：可为静态属性赋值，或必要的初始化行为。</li>
<li>触发时机：<ul>
<li>创建对象。</li>
<li>创建子类对象</li>
<li>访问静态属性</li>
<li>调用静态方法</li>
<li>主动加载：Class.forName(“”);</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>static修饰的成员为静态成员，无需创建对象，可直接通过类名访问。</li>
<li>静态方法不能直接访问非静态成员。</li>
<li>静态方法中不能使用this或super</li>
<li>静态方法可以继承、不能重写、没有多态。</li>
<li>静态代码块在类加载时被执行，且只执行一次。</li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.staticMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;  <span class="comment">//1.静态属性（类属性）</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;------&quot;</span>+age+<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;个学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCount</span><span class="params">()</span></span>&#123; <span class="comment">//2.静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生总数：&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//3.静态代码块 让count从1000开始</span></span><br><span class="line">        count=<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        s2.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.count);</span><br><span class="line">        Student.showCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最终final"><a href="#最终final" class="headerlink" title="最终final"></a>最终final</h2><ul>
<li>概念：最后的，不可更改的。</li>
<li>final修饰的内容：<ul>
<li>类（最终类）：此类不能被继承<ul>
<li>String、Math、System</li>
</ul>
</li>
<li>方法（最终方法）：此方法不能被重写，覆盖。</li>
<li>变量（最终变量，常量）：此变量值不能被改变。</li>
</ul>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>局部常量：此变量值不能被改变</li>
<li>实例常量：实例常量不再提供默认值，必须手动赋予初始值<ul>
<li>赋值时机：显示初始化，构造方法</li>
<li>注意：在构造方法中为实列常量复制，必须包装所有构造方法都能对其正确赋值</li>
</ul>
</li>
<li>静态常量：实例常量不再提供默认值，必须手动赋予初始值<ul>
<li>赋值时机：显示初始化，静态代码块</li>
</ul>
</li>
<li>对象常量：final修饰引用类型：地址不可变</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>final修饰类：此类不能被继承</li>
<li>final修饰方法：此方法不能被覆盖</li>
<li>final修饰变量：此变量值不能被改变。（如果不设置初始值，初始赋值只能一次）<ul>
<li>局部常量：显示初始化</li>
<li>实例常量：显示初始化、构造方法</li>
<li>静态常量：显式初始化、静态代码块</li>
<li>基本类型常量：值不可改变</li>
<li>引用类型常量：地址不可改变</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.finalMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fristName=<span class="string">&quot;张&quot;</span>;<span class="comment">//2.实例常量</span></span><br><span class="line">    <span class="keyword">final</span> String lastName; <span class="comment">//2.1实例常量 在初始化时赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String provincial=<span class="string">&quot;四川&quot;</span>;<span class="comment">//3.静态常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String city;<span class="comment">//3.1 静态常量 在静态代码块中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//final修饰基本类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> iphone=<span class="number">138888888</span>; <span class="comment">//1.局部常量 赋值后不能进行修改</span></span><br><span class="line">        <span class="comment">//iphone=&quot;1111&quot;;  报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态对象（final修饰引用类型）</span></span><br><span class="line">        <span class="keyword">final</span> String[] interest=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;唱歌&quot;</span>,<span class="string">&quot;跳舞&quot;</span>&#125;; <span class="comment">//4.1静态对象</span></span><br><span class="line">        <span class="comment">//interest=new String[]&#123;&quot;打游戏&quot;,&quot;看电影&quot;&#125;; 不能再进行初始化（更改地址） 但是可以更改里面的值</span></span><br><span class="line">        interest[<span class="number">0</span>]=<span class="string">&quot;打游戏&quot;</span>; </span><br><span class="line">        <span class="keyword">final</span> Pet pig = <span class="keyword">new</span> Pet(<span class="string">&quot;小猪&quot;</span>);</span><br><span class="line">        <span class="comment">//pig=new Pet (&quot;罗志祥&quot;); 不能再进行初始化（更改地址） 但是可以更改里面的值</span></span><br><span class="line">        pig.setName(<span class="string">&quot;时间管理大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(iphone+fristName+lastName+provincial+city+Arrays.toString(interest)+pig.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lastName=<span class="string">&quot;三&quot;</span>; <span class="comment">//2.2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName; <span class="comment">//必须保证正确的赋值</span></span><br><span class="line">        <span class="comment">//this.lastName=&quot;四&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        city=<span class="string">&quot;成都&quot;</span>;<span class="comment">//3.1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.finalMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Person(<span class="string">&quot;五&quot;</span>);</span><br><span class="line">        zhangsan.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-基本类型和包装类以及==和equals的区别</title>
    <url>/2021-01-JavaSE-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E4%BB%A5%E5%8F%8A-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="基本类型与包装类型的区别"><a href="#基本类型与包装类型的区别" class="headerlink" title="基本类型与包装类型的区别"></a>基本类型与包装类型的区别</h2><ol>
<li><p>在Java中，一切皆对象，但八大基本类型却不是对象。</p>
</li>
<li><p>声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。</p>
</li>
<li><p>存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。</p>
</li>
<li><p>初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；</p>
</li>
<li><p>使用方式的不同，比如与集合类合作使用时只能使用包装类型。</p>
</li>
<li><p>什么时候该用包装类，什么时候用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许null值，则必然要用封装类，否则值类型就可以了，用到比如泛型和反射调用函数，就需要用包装类了！</p>
<span id="more"></span>

</li>
</ol>
<h2 id="与equals的区别与联系"><a href="#与equals的区别与联系" class="headerlink" title="==与equals的区别与联系"></a>==与equals的区别与联系</h2><ul>
<li>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li>
<li>“==”使用情况如下：<ul>
<li>a) 基本类型，比较的是值</li>
<li>b) 引用类型，比较的是地址</li>
<li>c) 不能比较没有父子关系的两个对象</li>
</ul>
</li>
<li>equals()方法使用如下：<ul>
<li>a) 系统类一般已经覆盖了equals()，比较的是内容。</li>
<li>b) 用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址<br>（return (this == obj);）</li>
<li>c) 用户自定义类需要覆盖父类的equals()</li>
</ul>
</li>
<li>注意<ul>
<li>Object的==和equals比较的都是地址，作用相同</li>
<li>基本数据类型的包装类之间，==比较地址，equals比较值</li>
<li>基本数据类型与包装类之间，包装类自动拆封为基本类型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String比较</span></span><br><span class="line">        String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//str1 str2均为常量，常量在常量池中只有一份 所以为true</span></span><br><span class="line">        System.out.println(str1==str2);</span><br><span class="line">        <span class="comment">//equals在String类中为比较值</span></span><br><span class="line">        System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String str3=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String str4=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new出的对象 地址不同 所以为false</span></span><br><span class="line">        System.out.println(str3==str4);</span><br><span class="line">        <span class="comment">//同9行</span></span><br><span class="line">        System.out.println(str3.equals(str4));</span><br><span class="line">        <span class="comment">//常量地址与new出的对象地址肯定不同</span></span><br><span class="line">        System.out.println(str1==str3);</span><br><span class="line">        <span class="comment">//同9行</span></span><br><span class="line">        System.out.println(str1.equals(str3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本类型与包装类比较</span></span><br><span class="line">        <span class="comment">//int与Integer</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num11=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//==Integer.valueOf(10);</span></span><br><span class="line">        Integer num3=<span class="number">10</span>;</span><br><span class="line">        Integer num4=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//==Integer.valueOf(1000) ==new Integer(1000)</span></span><br><span class="line">        Integer num33=<span class="number">1000</span>;</span><br><span class="line">        Integer num44=<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//产生一个新的Integer 对象</span></span><br><span class="line">        Integer num5=<span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//指定的 int 值的 Integer 实例</span></span><br><span class="line">        Integer num6=Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//小于-128||大于127 ==new Integer(1000)</span></span><br><span class="line">        Integer num66=Integer.valueOf(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----使用==----&quot;</span>);</span><br><span class="line">        System.out.println(num1 == num2);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//包装对象与数值比较，自动拆箱</span></span><br><span class="line">        System.out.println(num1 == num3);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num1 == num5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num1 == num6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num5 == num6);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(num3 == num4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num33 == num44);<span class="comment">//false</span></span><br><span class="line">        System.out.println(num3 == num5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(num3 == num6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num66 == num33);<span class="comment">//flase</span></span><br><span class="line">        System.out.println(num66 == num11);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----使用equals----&quot;</span>);</span><br><span class="line">        <span class="comment">//equals 方法比较的是数值大小</span></span><br><span class="line">        System.out.println(num3.equals(num1));</span><br><span class="line">        System.out.println(num5.equals(num1));</span><br><span class="line">        System.out.println(num4.equals(num3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//double与Double</span></span><br><span class="line">        <span class="keyword">double</span> a=<span class="number">66.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a1=<span class="number">66.0</span>;</span><br><span class="line">        Double b=<span class="number">66.0</span>;</span><br><span class="line">        Double b1=<span class="number">66.0</span>;</span><br><span class="line">        Double c=<span class="number">2000.1</span>;</span><br><span class="line">        Double c1=<span class="number">2000.1</span>;</span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line">        System.out.println(a == a1);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//double取的是近似值 运输会失真</span></span><br><span class="line">        System.out.println(b == b1);<span class="comment">//false</span></span><br><span class="line">        System.out.println(c == c1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">//equals</span></span><br><span class="line">        System.out.println(b.equals(b1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        <span class="comment">//boolean</span></span><br><span class="line">        Boolean i=<span class="keyword">null</span>;</span><br><span class="line">        Boolean i1 = <span class="keyword">null</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-问题记录</title>
    <url>/2021-01-JavaSE-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="为什么可以在匿名内部类中使用非final的数组"><a href="#为什么可以在匿名内部类中使用非final的数组" class="headerlink" title="为什么可以在匿名内部类中使用非final的数组"></a>为什么可以在匿名内部类中使用非final的数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWin2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> [] age1=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//方式二 匿名内部类 因为接口实现类只使用了一次</span></span><br><span class="line">        <span class="keyword">int</span> [] age=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//可以使用 且可以修改元素</span></span><br><span class="line">        age=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//更改引用地址后 又不能使用了</span></span><br><span class="line">        age1=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//更改引用地址后 也可以使用</span></span><br><span class="line">        age[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        System.out.println(age[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//int ticket=101;//不可以使用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> ticket=<span class="number">101</span>; <span class="comment">//可以使用 不可以修改值</span></span><br><span class="line">        Runnable tickWin2=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">int</span> ticket=<span class="number">101</span>; <span class="comment">//可以使用 且可以修改值</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    age1[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ticket&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖了第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                    <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(1000);  //状态一：休眠1秒</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                    <span class="comment">//Thread.yield();  //状态二：放弃  当前线程主动放弃时间片，回到就绪状态，竞争下一次时间片</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021-03-SpringBoot/</url>
    <content><![CDATA[<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java - 框架 - SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解大全详解</title>
    <url>/2021-03-Spring%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>作用于方法上，一般标明返回的对象直接被Spring管理起来，常用于@Configuration中</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>作用于类上，声明这个类是一个组件，让spring容器管理起来</p>
<p><strong>@Component三个衍生注解</strong></p>
<ul>
<li>@Conroller //作用于控制下的类</li>
<li>@Service //作用于业务层下的类</li>
<li>@Repository //作用于dao层下的类</li>
</ul>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan()"></a>@ComponentScan()</h3><p>如果你的其他包都在使用了@SpringBootApplication注解的main<br>app所在的包及其下级包，则你什么都不用做，SpringBoot会自动帮你把其他包都扫描了</p>
<p>如果你有一些bean所在的包，不在main<br>app的包及其下级包，那么你需要手动加上@ComponentScan注解并指定那个bean所在的包</p>
<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><ul>
<li><p>@Controller //表示该类是一个控制器</p>
</li>
<li><p>@RestController //表示该类，只返回字符串</p>
</li>
<li><p>@ResponseBody  //表示该方法不走视图解析器，直接返回字符串</p>
</li>
<li><p>@RequestMapping(“hello”) //映射地址</p>
</li>
<li><p>@Autowired  //自动装配 在容器中自动找到依赖  根据类型 ，省去了get set方法</p>
</li>
<li><p>@Qualifier //与@Autowired配置使用，@Autowired根据类型找不到时@Qualifier根据名称取找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>    <span class="comment">//表示该类是一个控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span>   <span class="comment">//映射主路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooksController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//在容器中自动找到依赖  根据类型</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;booksServiceImpl&quot;)</span>  <span class="comment">//根据名称</span></span><br><span class="line">    <span class="keyword">private</span> BooksService booksService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/allBook&quot;)</span>  <span class="comment">//映射副路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Books&gt; list = booksService.queryAllBook();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>表示该类是一个配置类</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>SSM</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title>开发报错集合</title>
    <url>/2021-03-%E5%BC%80%E5%8F%91%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="Error-parsing-SQL-Mapper-Configuration-Cause-java-io-IOException-Could-not-find-resource-top-chenmw-user-mapper-UserMapper-xml"><a href="#Error-parsing-SQL-Mapper-Configuration-Cause-java-io-IOException-Could-not-find-resource-top-chenmw-user-mapper-UserMapper-xml" class="headerlink" title="Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource top/chenmw/user/mapper/UserMapper.xml"></a>Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource top/chenmw/user/mapper/UserMapper.xml</h3><p>原因：idea不会编译src的java目录的xml文件</p>
<p>所以解决思路就是：将IDEA maven项目中src源代码下的xml等资源文件编译进classes文件夹</p>
<p>具体操作方法就是：配置maven的pom文件配置，在节点下添加代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="attempted-to-return-null-from-a-method-with-a-primitive-return-type-int"><a href="#attempted-to-return-null-from-a-method-with-a-primitive-return-type-int" class="headerlink" title="attempted to return null from a method with a primitive return type (int)"></a>attempted to return null from a method with a primitive return type (int)</h3><p>sql语句返回为空，但是mapper.xml定义的返回类型为int<br>int默认为0，不支持空  改为java.lang.Integer即可<br>这就是基本类型int和包装类Integer的区别</p>
<h2 id="Spring-Mybatis"><a href="#Spring-Mybatis" class="headerlink" title="Spring Mybatis"></a>Spring Mybatis</h2><h3 id="事务不生效问题"><a href="#事务不生效问题" class="headerlink" title="事务不生效问题"></a>事务不生效问题</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给哪些方法添加事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--传播特性 默认REQUIRED--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法名与被事务的方法名名必须相同， 或则使用”<em>“ 所有方法,我出错的原因是写成了”</em>/“ 然后测试发现方法名不同也会不生效</p>
<h3 id="Error-creating-bean-with-name-‘sqlSessionFactory’-defined-in-class-path-resource-spring-config-xml-Invocation-of-init-method-failed-nested-exception-is-org-springframework-core-NestedIOException-Failed-to-parse-mapping-resource-‘file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml-’-nested-exception-is-org-apache-ibatis-builder-BuilderException-Error-parsing-Mapper-XML-The-XML-location-is-‘file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml-’-Cause-java-lang-IllegalArgumentException-Mapped-Statements-collection-already-contains-value-for-top-chenmw-mapper-UserMapper-selectUser-please-check-top-chenmw-mapper-UserMapper-xml-and-file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml"><a href="#Error-creating-bean-with-name-‘sqlSessionFactory’-defined-in-class-path-resource-spring-config-xml-Invocation-of-init-method-failed-nested-exception-is-org-springframework-core-NestedIOException-Failed-to-parse-mapping-resource-‘file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml-’-nested-exception-is-org-apache-ibatis-builder-BuilderException-Error-parsing-Mapper-XML-The-XML-location-is-‘file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml-’-Cause-java-lang-IllegalArgumentException-Mapped-Statements-collection-already-contains-value-for-top-chenmw-mapper-UserMapper-selectUser-please-check-top-chenmw-mapper-UserMapper-xml-and-file-D-learn-Spring-Learning-spring-10-02-spring-mybatis-target-classes-top-chenmw-mapper-UserMapper-xml" class="headerlink" title="Error creating bean with name ‘sqlSessionFactory’ defined in class path resource [spring-config.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: ‘file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]’; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is ‘file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]’. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for top.chenmw.mapper.UserMapper.selectUser. please check top/chenmw/mapper/UserMapper.xml and file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]"></a>Error creating bean with name ‘sqlSessionFactory’ defined in class path resource [spring-config.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: ‘file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]’; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is ‘file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]’. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for top.chenmw.mapper.UserMapper.selectUser. please check top/chenmw/mapper/UserMapper.xml and file [D:\learn\Spring-Learning\spring-10-02-spring-mybatis\target\classes\top\chenmw\mapper\UserMapper.xml]</h3><p>mybatis-config.xml和spring-config.xml重复扫描mapper造成的,注释掉mybatis-config.xml里面的</p>
<p>spring-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--生成代理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:top/chenmw/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描直接文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;mapper resource=&quot;top/chenmw/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描指定包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;top.chenmw.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>统一Java编译环境为utf-8</title>
    <url>/2021-03-%E7%BB%9F%E4%B8%80Java%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%BAutf-8/</url>
    <content><![CDATA[<blockquote>
<p>彻底解决开发中，遇到的所有乱码问题</p>
<p>欢迎补充</p>
</blockquote>
<span id="more"></span>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p> win10、idea2019.3、java1.8、tomcat9  </p>
<h3 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h3><ul>
<li><p>方式一(不推荐 很多软件不兼容)：设置系统全局默认编码为utf-8,以后创建文件，cmd窗口编码默认都为utf-8<br>但是有道词典等软件和一些文件(.bat)会中文乱码</p>
<img src="/2021-03-%E7%BB%9F%E4%B8%80Java%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%BAutf-8/image-20210316081323129.png" class="">
</li>
<li><p>方式二：针对cmd命令设置默认编码为utf-8（需要使用cmd运行jar，war包）<br>使用方式一 后cmd窗口默认编码也变为了utf-8，原本是gbk</p>
<ul>
<li>一次性 **(推荐)**：cmd执行<code>chcp 65001</code>（65001代表utf-8编码），当前窗口编码为utf-8.<br>运行tomcat starup.bat前先执行<code>chcp 65001</code>再在当前窗口执行<code>startup.bat</code></li>
<li>永久:win+R,输入<code>regedit</code>,路径：<br><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor</code>,<br>空白处右键新建字符串值,名称autorun,值65001<img src="/2021-03-%E7%BB%9F%E4%B8%80Java%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%BAutf-8/image-20210316085717853.png" class="">

</li>
</ul>
</li>
</ul>
<h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><ul>
<li><p>idea虚拟机配置  加上-Dfile.encoding=UTF-8</p>
<p>菜单栏 Help-Edit custon VM options</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># custom IntelliJ IDEA VM options</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=240m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>idea-tomcat虚拟机配置 加上-Dfile.encoding=UTF-8      （貌似没啥用，可能是）</p>
<img src="/2021-03-%E7%BB%9F%E4%B8%80Java%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%BAutf-8/image-20210316091320237.png" class="">
</li>
<li><p>java文件编码  全设置为utf-8</p>
<img src="/2021-03-%E7%BB%9F%E4%B8%80Java%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%BAutf-8/image-20210316091010393.png" class="">

</li>
</ul>
<h3 id="tomcat9"><a href="#tomcat9" class="headerlink" title="tomcat9"></a>tomcat9</h3><p>解决idea tomcat窗口，tomcat starup.bat、catalina.bat窗口乱码，需要配合使用cmd窗口编码为utf-8</p>
<ul>
<li><p>server.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>logging.properties  5个编码为utf-8</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1catalina.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2localhost.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3manager.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4host-manager.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>starup.bat</li>
</ul>
<p>将 <code>call &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%</code> 修改为 <code>call &quot;%EXECUTABLE%&quot; run %CMD_LINE_ARGS%</code></p>
<ul>
<li>catalina.bat</li>
</ul>
<p>将 <code>set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;</code> 修改为 <code>set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS% -Dfile.encoding=UTF-8&quot;</code></p>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><ul>
<li><p>web.xml  添加字节过滤器  统一解决参数传递乱码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>springmvc-servlet.xml   统一解决json乱码  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>乱码 - 编码utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea 2019.1激活</title>
    <url>/2020-10-Idea-2019-1%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>原理应该是让idea拉回激活信息失败</p>
<p>hosts 文件添加</p>
<p>0.0.0.0 account.jetbrains.com<br>0.0.0.0 <span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tLw==">www.jetbrains.com<i class="fa fa-external-link-alt"></i></span></p>
<p>激活码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MNQ043JMTU-eyJsaWNlbnNlSWQiOiJNTlEwNDNKTVRVIiwibGljZW5zZWVOYW1lIjoiR1VPIEJJTiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNC0wNCJ9XSwiaGFzaCI6IjEyNjIxNDIwLzBwIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOnRydWUsImlzQXV0b1Byb2xvbmdhdGVkIjp0cnVlfQ&#x3D;&#x3D;-Zmbxcn7NPlqBNqAURX0uiLzybnruyx6PG+6KYZrpzm&#x2F;IJJs5nnIogGgdfIJoifO6fbaaJYc5pjds7CHdrt&#x2F;neIpvF2o&#x2F;HvIjMEF4&#x2F;AhNV7HUGsAa9zpMszc6YBIkMmVFh4Y7GPKOStA14&#x2F;Ld83AC7kGnwL1Fq7eAXKJFljc00GMejPpfE0zDqTN634bC+0ojfklhWXaLqhUt230SiE8onnd3quvEaH5NsW7sIQm2spyONZI+iHvHFtl4EvG7tlRlD1StsfhrbgNNxz61FOEEQ+GtZIzMx+T4sbpfoRyms7lbWQecrbAtE0c2sR98esm4PcDUhrFVBxGorPC1ppOLSQ&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/2020-10-Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p><code>git clone https://github.com/Mw-GH/GitLearning.git</code>     从远程仓库上克隆项目</p>
</li>
<li><p><code>git push -u orgin master</code><br>  将本地的最新数据推送到远程仓库<br>  第一加 <code>-u</code>后  后面可直接使用 <code>git push</code><br>  <code>pull</code>同理</p>
</li>
<li><p><code>git pull orgin master</code><br>  将远程仓库的最新数据同步到本地</p>
<span id="more"></span>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2></li>
<li><p><code>git config user.name</code><br>  查看配置用户</p>
</li>
<li><p><code>git config user.email</code><br>  查看配置邮箱</p>
</li>
<li><p><code>git config --global user.name &quot;Mw-GH&quot;</code><br>  配置更改git用户</p>
</li>
<li><p><code>git config --global user.email &quot;Mw-MS@outlook.com&quot;</code><br>  配置或更改git邮箱</p>
</li>
<li><p><code>ssh-keygen -t rsa -C &quot;Mw-MS@outlook.com&quot;</code><br>  在C:\Users\Administrator目录下生成.ssh</p>
</li>
</ul>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li><p><code>git init</code><br>初始化仓库</p>
</li>
<li><p><code>git add &lt;file&gt;</code><br>更新文件 工作区&gt;&gt;&gt;暂存区  </p>
</li>
<li><p><code>git commit -m &lt;&quot;describe&quot;&gt;</code><br>更新版本 暂存区&gt;&gt;&gt;仓库（版本库）</p>
<p>  <strong>注意<br>  一次commit能够提交上一次commit后所有的修改添加</strong></p>
</li>
<li><p><code>git checkout &lt;file&gt;</code><br><code>git checkout .</code>  恢复全部文件的修改<br>恢复修改  撤销<br>未git add的文件</p>
</li>
<li><p><code>git reset HEAD</code><br>撤销文件更新 工作区&lt;&lt;&lt;暂存区<br>已经git add的文件，再用上一条命令恢复文件<br>同commit 全部恢复为未提交状态</p>
</li>
<li><p><code>git reset --hard HEAD^</code><br>  <code>git rest --hard &lt;版本号&gt;</code><br>版本回退 暂存区&lt;&lt;&lt;仓库（仓库）<br>回退到上一个版本 上上一个版本为HEAD^^ 上一百个版本HEAD~100<br>已经commit后 恢复所有文件为上一个版本</p>
</li>
<li><p><code>git rm test.txt</code><br>删除test.txt文件</p>
</li>
<li><p><code>git status</code><br>查看commit前仓库的状态 是否有需要提交的文件</p>
</li>
<li><p><code>git diff [file]</code><br>查看commit前的差异   difference差异</p>
</li>
<li><p><code>git log</code><br>查看最近到最远的提交日志<br>  <code>git log --pretty=oneline</code><br>简略版日志</p>
</li>
<li><p><code>git reflog</code><br>查看你的每一次命令</p>
</li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><ul>
<li><p><code>git checkout -b dev</code><br>创建并切换到新的分支dev<br>等同于<br><code>git branch dev</code><br><code>git checkout dev</code></p>
</li>
<li><p><code>git branch</code><br>查看当前所有分支</p>
</li>
<li><p><code>git merge dev</code><br>当前分支master合并dev分支  </p>
</li>
</ul>
<p><strong>合并方式：<br><code>Fast-forward</code>:快进模式<code>git merge dev</code>，直接把master指向dev的提交，缺点：看不出合并记录还会搅乱master分支提交记录<br>禁用<code>Fast-forward</code>:普通模式<code>git merge --no-ff -m &quot;merge --no-ff&quot;</code>,合并后的历史有分支，能看出来曾经做过合并</strong></p>
<p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>禁用<code>Fast forward</code>模式 合并分支并生成一个commit  </p>
<p><strong>建议使用<br><code>--no-ff</code>参数 就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</strong></p>
<ul>
<li><code>git branch -d dev</code><br>删除dev分支</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul>
<li><p><code>git switch -c dev</code><br>创建并切换到新的分支dev</p>
</li>
<li><p><code>git switch master</code><br>直接切换到已有分支master  </p>
</li>
</ul>
<p><strong>注意<br> 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</strong></p>
<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code><br>用带参的<code>git log</code>查看分支的合并情况</li>
</ul>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul>
<li><p><code>git stash</code><br><code>git stash save &quot;sta1&quot;</code><br>储藏现在的工作区</p>
</li>
<li><p><code>git stash list</code><br>查看所有储藏的内容</p>
</li>
<li><p><code>git stash pop</code><br>恢复内容同时删除stash</p>
</li>
<li><p><code>git stash apply</code><br><code>git stash apply stash@&#123;0&#125;</code><br>恢复最近一个stash</p>
</li>
<li><p><code>git stash drop stash@&#123;0&#125;</code><br>删除指定stash</p>
</li>
<li><p><code>git stash branch</code><br>从最新的stash创建分支</p>
</li>
<li><p><code>git cherry-pick</code><br>复制一个特定的提交到当前分支</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用命令</title>
    <url>/2020-10-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h1><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><p>uname -an</p>
<h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>vi /etc/hostname</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网卡地址<br>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><p>正在运行程序<br>netstat -ntlp</p>
<p>防火墙允许通过的进程<br>firewall-cmd –list-ports</p>
<span id="more"></span>
<h2 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h2><p>先在Vmware虚拟机设置中扩展虚拟机磁盘容量</p>
<p>查看以有分区<br><code>fdisk -l</code></p>
<p>进入菜单,m列出菜单,p列出分区列表,n增加分区,w保存<br><code>fdisk /dev/sda</code></p>
<p>重启<br><code>reboot</code></p>
<p>查看分区情况<br><code>df -h</code></p>
<p>格式化<br><code>mkfs -t ext4 /dev/sda4</code></p>
<p>不挂载直接给根目录扩容</p>
<p>进入lvm管理<br><code>lvm</code></p>
<p>初始化分区<br><code>pvcreate /dev/sda3</code></p>
<p>将初始化过的分区加入到虚拟卷组vg_dc01<br><code>vgextend centos /dev/sda3</code></p>
<p>扩展已有的卷的容量<br><code>lvextend -L +50G /dev/mapper/centos-root</code></p>
<p>查看卷容量<br><code>pvdisplay</code></p>
<h2 id="设置开机启动之nexus3"><a href="#设置开机启动之nexus3" class="headerlink" title="设置开机启动之nexus3"></a>设置开机启动之nexus3</h2><p>创建软连接<br><code>ln -s /opt/nexus-3.21.1-01/bin/nexus /etc/init.d/nexus</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d</span><br><span class="line">sudo chkconfig --add nexus</span><br><span class="line">sudo chkconfig --levels 345 nexus on</span><br><span class="line">sudo service nexus start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux部署JavaWeb项目</title>
    <url>/2020-10-Linux%E9%83%A8%E7%BD%B2Javaweb%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="linux部署javaWeb项目"><a href="#linux部署javaWeb项目" class="headerlink" title="linux部署javaWeb项目"></a>linux部署javaWeb项目</h1><h2 id="1-查看是否有java环境"><a href="#1-查看是否有java环境" class="headerlink" title="1.查看是否有java环境"></a>1.查看是否有java环境</h2><pre><code>java -version
</code></pre>
<h2 id="2-部署tomcat"><a href="#2-部署tomcat" class="headerlink" title="2.部署tomcat"></a>2.部署tomcat</h2><p>解压tomcat</p>
<pre><code>tar -zxvf apache-tomcat-8.5.43.tar.gz 
</code></pre>
<p>进入bin目录运行<code>start.sh</code></p>
<pre><code>./start.sh
</code></pre>
<span id="more"></span>

<p>开放8080端口</p>
<p>先关闭防火墙–&gt;安装或更新防火墙–&gt;启动防火墙–&gt;查看防火墙状态</p>
<pre><code>systemctl stop firewalld
yum install iptables-services
systemctl enable iptables
systemctl start iptables
</code></pre>
<p>查看正在运行的程序信息(端口)</p>
<pre><code>netstat -tunlp
</code></pre>
<h2 id="3-部署mysql"><a href="#3-部署mysql" class="headerlink" title="3.部署mysql"></a>3.部署mysql</h2><p>解压mysql</p>
<pre><code>tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<p>移动并修改文件名</p>
<pre><code>mv mysql-5.7.17-linux-glibc2.5-x86_64 /usr/saplc-gc/mysql
</code></pre>
<p>添加mysql 用户</p>
<pre><code>groupadd mysql
useradd -r -g mysql mysql
</code></pre>
<p>切换到/usr/saplc-gc/mysql 改变目录拥有者为 mysql</p>
<pre><code>chown -R mysql.mysql /usr/saplc-gc/mysql
</code></pre>
<p>安装mysql</p>
<pre><code>bin/mysqld --initialize --user=mysql --basedir=/usr/saplc-gc/mysql --datadir=/usr/saplc-gc/mysql/data
</code></pre>
<p><strong>填坑</strong><br>在linux系统，默认设置下：</p>
<ul>
<li>数据库名与表名是严格区分大小写的；</li>
<li>列名与列的别名在所有的情况下均是忽略大小写的；</li>
<li>变量名也是严格区分大小写的；</li>
</ul>
<p>在windows系统，默认设置下：</p>
<ul>
<li>都不区分大小写</li>
</ul>
<p><strong>解决方法</strong><br>以root用户登录数据库服务器,修改<code>/etc/my.cnf</code>文件:</p>
<ol>
<li><p>在[mysqld]下加入代码:</p>
<pre><code> lower_case_table_names=1
</code></pre>
</li>
<li><p>重启数据库</p>
<pre><code> service mysqld restart
</code></pre>
</li>
<li><p>验证lower_case_table_names的值,0代表区分大小写,1代表不区分大小写</p>
</li>
</ol>
<p><strong>建议</strong><br>为了避免大小写引发的问题，一种推荐的命名规则是：在定义数据库、表、列的时候全部采用小写字母加下划线的方式，不使用任何大写字母。</p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware与Docker不兼容解决办法</title>
    <url>/2020-10-VMware%E4%B8%8EDocker%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="熊掌和鱼不可兼得，只能使用其一"><a href="#熊掌和鱼不可兼得，只能使用其一" class="headerlink" title="熊掌和鱼不可兼得，只能使用其一"></a>熊掌和鱼不可兼得，只能使用其一</h2><span id="more"></span>
<h2 id="1-使用用docker"><a href="#1-使用用docker" class="headerlink" title="1.使用用docker"></a>1.使用用docker</h2><p>第一步：在控制面板中勾选Hyper -v<br>第二步：在cmd，以管理员身份运行：<br>bcdedit /set hypervisorlaunchtype auto<br>第三步:重启</p>
<h2 id="2-使用虚拟机"><a href="#2-使用虚拟机" class="headerlink" title="2.使用虚拟机"></a>2.使用虚拟机</h2><p>第一步：在控制面板中取消勾选Hyper -v<br>第二步：在cmd中，以管理员身份运行：<br>bcdedit /set hypervisorlaunchtype off<br>第三步:重启</p>
]]></content>
      <categories>
        <category>技术储备</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 中文乱码解决</title>
    <url>/2020-10-Tomcat-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在开发过程或者更换开发环境中经常遇到tomcat中文乱码问题，在此记录已方便查看.</p>
<span id="more"></span>

<h2 id="控制台中文乱码"><a href="#控制台中文乱码" class="headerlink" title="控制台中文乱码"></a>控制台中文乱码</h2><p>注释掉<code>tomcat/conf/logging.properties</code>中</p>
<pre><code>java.util.logging.ConsoleHandler.encoding = UTF-8
</code></pre>
<h2 id="前端传递参数到后端（JSP接受）"><a href="#前端传递参数到后端（JSP接受）" class="headerlink" title="前端传递参数到后端（JSP接受）"></a>前端传递参数到后端（JSP接受）</h2><p>修改<code>tomcat/conf/server.xml</code>文件中</p>
<pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">useBodyEncodingForURI</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>技术储备</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-多态</title>
    <url>/2020-10-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。</p>
<span id="more"></span>

<h2 id="多态的存在有三个必要的条件"><a href="#多态的存在有三个必要的条件" class="headerlink" title="多态的存在有三个必要的条件"></a>多态的存在有三个必要的条件</h2><ol>
<li>要有继承（两个类之间存在继承关系，子类继承父类)</li>
<li>要有重写（在子类里面重写从父类继承下来的方法）</li>
<li>父类引用指向子类对象  </li>
</ol>
<p>这三个条件一旦满足，当你调用父类里面被重写的方法的时候，实际当中new的是哪个子类对象，就调用子类对象的方法（这个方法是从父类继承下来后重写后的方法）。</p>
<p>　　面向对象比较强调类和类之间，对象和对象之间的一种组织关系，如果能把这种组织关系组织得比较好的话，你的程序想扩展性比较好，比较健壮，维护性比较好这些都可以达到，关键看你的设计到底好还是不好。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-异常</title>
    <url>/2020-10-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理，让程序继续执行下去,而不是遇到异常中断程序运行</li>
<li>在多重catch块后面，可以加一个catch(Exception)来处理可能被遗漏的异常  </li>
<li>对于不确定的代码，也可以加上try-catch来处理潜在的异常</li>
<li>尽力去处理异常，切忌不要只是简单的调用printStackTrace()去打印输出  </li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加finally语句块去释放占用的资源</li>
<li>不要在循环语句内使用try-catch，会占用大量资源<span id="more"></span>

</li>
</ul>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常是不需要捕获的，程序员可以去处理，避免，比如0作除数异常，只需要加一个判断 被除数不能等于0即可避免，当异常出现时，虚拟机会处理。常见的运行时异常有空指针异常。</p>
<p>常见的5中运行时异常：</p>
<p>ClassCastException(类转换异常)<br>IndexOutOfBoundsException(数组越界)<br>NullPointerException(空指针)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>还有IO操作的BufferOverflowException异常</p>
<h3 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h3><p>非运行时异常就必须得捕获了，强制处理异常，否则编译不过去，java编译器要求程序员必须对这种异常进行捕获或抛出,Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。</p>
<p>常见的非运行异常有io异常和sql异常。</p>
<p>IOException<br>FileNotFoundExcetion<br>SQLException</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>错误 无法解决</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h2><p>捕获异常 范围由小到大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        demo2.d2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h2><p>1、throws出现在方法的声明中，表示该方法可能会抛出的异常，允许throws后面跟着多个异常类型<br>2、throw出现在方法体中，用于抛出异常。当方法在执行过程中遇到异常情况时，将异常信息封装为异常对象，然后throw。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>抛出异常和捕获异常：</p>
<p>抛出异常 为了让程序继续执行<br>让调用者捕获解决异常</p>
<p>什么时候用 try catch ，throws ，throw：</p>
<ol>
<li><p>throws:抛出异常</p>
<p> 写方法时可能会遇到异常，在方法名声明异常  可声明多个异常  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这里有可能会产生FileNotFoundException异常</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;MyFile.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw：手动抛出异常  </p>
<p> 常用于判断内 例如：用户输入不合法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;i不能等于0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 类似与sout打印到控制台，但是打印到控制台</p>
</li>
<li><p>try catch: 捕获异常，处理异常</p>
<p> 调用时try catch捕获异常 处理异常</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        demo2.d2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>AP配置文件</title>
    <url>/2020-10-%E8%B4%A6%E6%88%B7%E7%A7%98%E5%AF%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ebf7c5fec32fc441c0166d9eb469254d625d950164c281464804549641a11fc9">a4626797b59d51ca61698aa4c885a79dbaf4e24b070ecdbf062639dad5a2a232ae84e372eb2560f6d2baa8fedd9be3b73c9cf6bd7aeb290d0a95d232d530ba34f6256845b0d316e6d68091afa31924b6515af881d12b5202d0c165e03130cb2f8fb64160daf6fe9f22f5f34fc043230c210248507b92a662d53c33dd7219b6dd3fbc0007a943ef0a8b5a90e23868b5948694db2a30da5a4bfc2c33eb5e814721cff19a35b459cb1f9ff0012cc1d9ab5c86495a82e5d5b42712a90bbb893bd6c89fe89201b6f7a345a6f2252bd5b46470ecfecb30b3c107ef74dfda7fd44538b9ad660fe84d8febf9cb6bf0e5324c1913a0f9415ccfe95e2ef6b14b068c36c1c3bc47e638e934c5e6a0cd8082628995f6a6edc602414eed7bc66f16928c9b384cfd603db20e71a9a001f898cad03a7c23a7165f9e0d2e4c770abd63110cfd557e322af7b1189d357e1dee53727a54d1931ea4e3c1f2e0b01f8eaa8f0ce892ee18c58ecb66b0201890a1fbe38e146097f1d75eb441b7f78c9cf3d14d058d33bb8e7b89c4c5ca817b6013ba2c4aeb865c8e268f9a0eb08745cba9b7282926fc0ad4cc5c3b8ccdcd3c8aaf42f50e85ffed42a75e1adc92d41bdc539f55b7cc4f1b11b665336827a615242f26b2f93a6b2044bb024ee656646255143fc123b64e22c28960ecf448d2fce36dc47e17e23a711c051e56b83bee9915166fd9f7e11e40d2ba28e9dbdfd8fffd597f70058478be9f31cfc745ff6e84757df970b0d94741b3adf6da9a61adfdbb911e37bc1410a8b87cf711acdbfa6d39b059efd41a3f908df4bb36b77f50f200ada752a14e2a7cbbe2f60c46d85e39b50cffbefec666c1f788c55d4947217c1cee59cd7c6c5a9478e84eacfd3dea59c9f889a3fe9e922c9d8812e093e2528968d227b4da559d5d73c0690a6bb46c8f6affe8934ec12b3f3c89296121c57b0216e5d4757b7c0f76e0056149199765be06e0925f7d479045857a609907216ffb4b872367d103ddf914668a9a543445b70a46f55fc632d08ac40328075162b6341a10e076d1dee16fd7389da25a4b07ff010918f0dfd8d772cc92164a36ee775b41bcb5e846f85f9d952c34732a1591f8e9b3c5a72f8213caffc8d207e896ef47a454dc62331bd6870d3509cb3544e581508026365c262a3b5f14ead3ff48754e320c706c5c48493c23e7868dfbb31ea291c14062200d9d5491abae4b3dd4021d37fcb6a3b2ae83312b12424db8be3b55e84e7b207114c0948397575c175a601b183c2f309996152c09b4b6322f7a63cab53bebc5079d947ba3f81436ff4dc7a897b4b203a7c5ae8ec41d1ad93e1dbe9f7b9b81448b53ea9770a6e44aa74c2709535ad2975880d58840b771a1dae03245eb7613a20eaf1c4a6dfe980c9188f96c2563b8563c8e877626261c7be915819c1d42ba4af732b9533858f9e61a7f4a25c2e1faadf9aaeec5262705d8eef27bc36497e1f53c0ebf64628b4659dd3f0b864171d5147089c4429a27a652a6ddbef6022f54fcbd320b2cef9d11cc3607d7fd0ee4f2e83ef6bac05777f3cf0716052032660e8a8235bac1410f5cd36e6c7b49eaf401e912b68fe5f5b5c1f1ba2e0f0b83766672ef1cd2031659d5fad42bc61046b210c82001d31dc7f59a82c9d9dc785cf06eae394e111e2bb73126ac7843c9b0bba6ee35d7933c1d29b7edea40f7e1d1313d84956c6dec2f59ef6bafaa6f40c727fec4dc1a127461e679c270ae2ffc7a9384b3f05650b49b5117302a82d4927658d02280ac46c7f870ecc72b72cea8a7572f017f6fe46f60a077e47b6f6bf09717b008b392cc715257c9b66eafc26214c298abe019af968aaced853f906a1680edad88f86e31bd43cfee43693cae84147594137afb84f3fe7bb9b208ac47bb376166b2c1eefc9f49315448b39e20ddd7717fe15852e3787e066d71afa4ed5ba7203e39cdfcec1183dfe0d780d96074df775384c410d70cc4a4985c52ad4047c9e176bb91b60c7d69e04d5155b5ff79086aa763bd05c6f67810e1711f8ed65afa7341933ee67d22231d729b50cec6b7553fc9353b7cb20b7b340aa0e8a00ca4578859c933e2fbb2578aaabb9f6f5177f104cd98fe614922208b9f5a5ffc45b5902aae018841cad8a95f7321dfad6beabd1043909b55d0ae757876d5ebe12f34fe075c6d30aa83264a21c23e4ee6cd7b97b8fce755f188510cd9b25c14edecd7bdeff2a2f1be81db11756345eaa693cd3ca836152eb567189b6a17be72671b97981a00dbfe81127a6d6970d16f509e5ab332ccfe1ca43fcb06c30b4e6c6f7abbd1f0b18a4a057036a8dd435f17c7db98b3b506fe6fc63a896e2e79d0c3aa77ee13a8f92d04bb183f4df99749ef62e35eb84247c9b791e56f3386adc93545b08e4e02c736aad9dab1dbf8302e21760c18b8efdd5639c3a0e92a63335f17425aeb094cd258e0da933dd7213a5526fc5b66651dd5405932247540071ecfc7000d0f18052ac8ea8c52b2172cda298a8bcb989f146445866c466634e3f7bd6746ac758cc1e71d0076f3f4ce721f330898d8b73243db3fd3290fb0ca</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>个人文件</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-数组</title>
    <url>/2020-10-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">int</span> [] a;  <span class="keyword">int</span> [][]b;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">int</span> a[]; <span class="comment">//不是首选</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h2 id="实列数组对象"><a href="#实列数组对象" class="headerlink" title="实列数组对象"></a>实列数组对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="声明创建实列三合一"><a href="#声明创建实列三合一" class="headerlink" title="声明创建实列三合一"></a>声明创建实列三合一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定大小</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//指定元素</span></span><br><span class="line"><span class="keyword">int</span> []a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dateType [] arrayName=&#123;arrayValue1,arrayValue2,arrayValue3&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    System.out.println(array[i]);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二： 增强for循环 foreach  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:array)&#123;  </span><br><span class="line">    System.out.println(a);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-锁</title>
    <url>/2020-10-%E9%94%81/</url>
    <content><![CDATA[<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>大概率一个数据不会被多个线程同时修改，<br>通过Cas总会分配一个t1优先权限，t1中的E1（预期值）=V（主存的共享变量）说明预期值正确，执行N1=V1+1，然后将N1值覆盖主存的值，线程t2执行 拿到主存中的值V=21，然后与t2中的E2比较 E2！=V 重新更新主存的值到自己的副本，再次尝试，值到E2=V 说明没有别的线程对旧值进行更改，则继续执行，优化 加版本号 version</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">之前不能防止ABA的正常修改：</span><br><span class="line"></span><br><span class="line">update table set value = newValue where value = #&#123;oldValue&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>oldValue就是我们执行前查询出来的值 </span><br><span class="line">带版本号能防止ABA的修改：</span><br><span class="line"></span><br><span class="line">update table set value = newValue ，vision = vision + 1 where value = #&#123;oldValue&#125; and vision = #&#123;vision&#125; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号<span class="number">100</span><span class="operator">%</span>不一样</span><br></pre></td></tr></table></figure>

<p>适合于多读</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>大概率一个数据会被多个线程同时修改，<br>每次拿到数据就上锁，别的线程拿数据就会阻塞直到拿到锁， t1上锁， t2阻塞，t1执行完后，t2上锁以此类推<br>适合于多写</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote>
<p>持续更新… 待工期间感觉无聊，一直觉得程序猿一定要有一个属于自己的博客，记录自己的学习过程、笔记，于是重新捡起了Hexo，完整的记录我搭建Hexo Next主题博客的过程,碰到无数的坑，掉了无数的头发，才勉勉强强搭建成现在的样子，给新手朋友一些建议，碰到问题多百度，多尝试，由于Next主题版本的原因，网上的方法不一定行，但一定有解决的办法，多参考一些大神的博客。你们也可以在下面评论给我提出建议。慢慢完成、完善后你会继续感到无尽寂寞（无敌）….</p>
</blockquote>
<span id="more"></span>

<ul>
<li>参考博客： 强烈感谢以下博主，存在copy的地方请见谅</li>
</ul>
<ol>
<li><p><span class="exturl" data-url="aHR0cDovL3NhaWxpLnNjaWVuY2UvZ2l0Lw==">http://saili.science/git/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sYXp5ZG9nMDM2LmdpdGVlLmlvLw==">https://lazydog036.gitee.io/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ub3Rlcy5kb3VibGVtaW5lLm1lLw==">https://notes.doublemine.me/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>QQ群：722344383 里面全是大佬</p>
</li>
</ol>
<h2 id="需要环境"><a href="#需要环境" class="headerlink" title="需要环境"></a>需要环境</h2><ol>
<li>Git</li>
<li>Node.js</li>
</ol>
<p>安装参考技术储备</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v //查看版本</span><br><span class="line">//hexo: <span class="number">5</span>.<span class="number">4</span>.<span class="number">0</span></span><br><span class="line">//hexo-cli: <span class="number">4</span>.<span class="number">2</span>.<span class="number">0</span></span><br><span class="line">//node: <span class="number">12</span>.<span class="number">21</span>.<span class="number">0</span>  不建议使用太高的版本，坑挺多</span><br></pre></td></tr></table></figure>

<p>在需要生成博客项目的路径下打开命令行输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init myblog //myblog 任意取名</span><br><span class="line"><span class="built_in">cd</span> myblog //进入项目文件</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹目录下有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>_config.yml: 博客的配置文件</li>
</ul>
<h3 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo g  //生成静态文件 </span><br><span class="line">hexo s  //启动Hexo服务</span><br></pre></td></tr></table></figure>

<p>打开hexo的服务，在浏览器输入localhost:4000访问博客</p>
<p>ctrl+c关闭服务</p>
<h3 id="放置主题"><a href="#放置主题" class="headerlink" title="放置主题"></a>放置主题</h3><ol>
<li><p>将下载好的主题文件 放入Hexo\themes文件下 我这里使用的是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">hexo-theme-next v7.8.0<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>更改<mark>站点配置文件</mark>中的theme: hexo-theme-next即可</p>
</li>
</ol>
<h2 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a><div id="1.4.1">将Hexo部署到GitHub</div></h2><h3 id="创建GitPage"><a href="#创建GitPage" class="headerlink" title="创建GitPage"></a>创建GitPage</h3><p>创建一个和你用户名相同的仓库，后面加.github,只有这样，将来要部署到GitHub page的时候，才会被识别, mw-gh.github.io</p>
<h3 id="绑定github"><a href="#绑定github" class="headerlink" title="绑定github"></a>绑定github</h3><p>绑定github用户名和邮箱</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br><span class="line"></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email  //检查</span><br></pre></td></tr></table></figure>

<p>然后创建SSH</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p>查看是否绑定成功<br>ssh -T <span class="exturl" data-url="bWFpbHRvOiYjeDY3OyYjMTA1OyYjeDc0OyYjeDQwOyYjeDY3OyYjMTA1OyYjeDc0OyYjMTA0OyYjMTE3OyYjeDYyOyYjeDJlOyYjOTk7JiN4NmY7JiMxMDk7">&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Hexo部署配置"><a href="#Hexo部署配置" class="headerlink" title="Hexo部署配置"></a>Hexo部署配置</h3><p>这一步，将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/mw-gh/mw-gh.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>然后安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>最后</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>过一会就可以访问<span class="exturl" data-url="aHR0cDovL213LWdoLmdpdGh1Yi5pby8=">http://mw-gh.github.io<i class="fa fa-external-link-alt"></i></span> 这个网站看到你的博客了</p>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><ol>
<li><p>购买域名 我是在腾讯云上购买的是chenmw.top</p>
</li>
<li><p>添加Github Pages解析：在Hexo/source中建立CNAME文件（没有后缀），文件内容为你希望访问项目的地址如：mw-blog.chenmw.top</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210228235810.jpg" class=""></li>
<li><p>在Github仓库设置中找到Custom domain 内容设置成一样</p>
</li>
<li><p>在你所购买域名网站，域名管理中找到DNS解析，添加一条主机记录为@,记录类型为CNAME，线路类型默认，记录值为你的github pages路径</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E5%9B%BE%E7%89%8720210301001016.png" class=""></li>
<li><p>项目重新部署 hexo d 访问chenmw.top即可</p>
<blockquote>
<p>hexo-d 报Error: Spawn failed 是CNAME文件与仓库中CNAME文件不一样</p>
</blockquote>
</li>
<li><p>项目添加了Valine功能的记得在LeanCloun 安全中心中添加Web安全域名</p>
</li>
</ol>
<h3 id="把代码放在github上管理"><a href="#把代码放在github上管理" class="headerlink" title="把代码放在github上管理"></a>把代码放在github上管理</h3><p><a href="#1.4.1">1.4.1</a>那一步创建的个人仓库只保存了个人文件和文章 github用来部署github pages的</p>
<p>这里我们自己上传一份代码便于管理</p>
<p>创建名为MyBlog的仓库 获取仓库链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL013LUdIL015QmxvZy5naXQ=">https://github.com/Mw-GH/MyBlog.git<i class="fa fa-external-link-alt"></i></span></p>
<p>然后在MyBlog文件夹中运行Git Bash</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git init   //<span class="number">1</span>. 初始化本地仓库</span><br><span class="line">git add .  //<span class="number">2</span>. add到暂缓区</span><br><span class="line">git commit -m &#x27;初始化&#x27;  //commit到提交区</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/Mw-GH/MyBlog.git  //添加远程仓库地址</span><br><span class="line">git push -u origin master //上传到远程仓库 第一次上传 远程仓库为空 所有要加-u参数</span><br></pre></td></tr></table></figure>

<p>由此完成代码上传到github</p>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><p>先拉去站点文件Mw-Blog，再拉取主题文件hexo-theme-next</p>
<p>站点文件中没有node_modules原因是不是自己写的代码，且文件较大，只要目录中有package.json文件，运行npm install就会自动建立node_modules且下载原来的依赖</p>
<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><h3 id="博客信息"><a href="#博客信息" class="headerlink" title="博客信息"></a>博客信息</h2></h3><p><mark>站点配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Mw-Blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">个人博客</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Mw</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line"><span class="comment"># Sidebar Position.</span></span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="string">//右侧</span></span><br><span class="line"><span class="comment">#position: right</span></span><br></pre></td></tr></table></figure>

<h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line"><span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="comment"># You can also use other linking images.</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">/images/Mw.png</span></span><br><span class="line"><span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line"><span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line"><span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="浏览进度百分比"><a href="#浏览进度百分比" class="headerlink" title="浏览进度百分比"></a>浏览进度百分比</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="个性化设置（进阶）"><a href="#个性化设置（进阶）" class="headerlink" title="个性化设置（进阶）"></a>个性化设置（进阶）</h2><h3 id="卜蒜子统计访客人数"><a href="#卜蒜子统计访客人数" class="headerlink" title="卜蒜子统计访客人数"></a>卜蒜子统计访客人数</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line"><span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line"><span class="attr">post_views:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h3 id="顶部背景-菜单栏阴影"><a href="#顶部背景-菜单栏阴影" class="headerlink" title="顶部背景 菜单栏阴影"></a>顶部背景 菜单栏阴影</h3><p>\themes\hexo-theme-next\source\css_common\outline\header\header.styl</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: url(<span class="string">&quot;../images/bg.jpg&quot;</span>) no-repeat <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\themes\hexo-theme-next\source\css_common\outline\header\menu.styl</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.65</span>);</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加统计文章字数和文章阅读时间"><a href="#添加统计文章字数和文章阅读时间" class="headerlink" title="添加统计文章字数和文章阅读时间"></a><strong>添加统计文章字数和文章阅读时间</strong></h3><ol>
<li>安装插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br><span class="line">npm install eslint --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><mark>站点配置文件</mark>添加</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span>   <span class="comment"># 文章阅读时长</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span>  <span class="comment"># 站点总字数统计</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment"># 站点总阅读时长</span></span><br><span class="line"><span class="attr">exclude_codeblock:</span> <span class="literal">false</span> <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><mark>站点配置文件</mark>添加</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span> <span class="comment"># 是否另起一行（true的话不和发表时间等同一行）</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span> <span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">true</span>   <span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span>  <span class="comment"># Average Word Length</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span> <span class="comment"># Words Per Minute（每分钟阅读词数）</span></span><br><span class="line"><span class="attr">suffix:</span> <span class="string">mins.</span></span><br><span class="line"></span><br><span class="line"><span class="string">post_wordcount:#</span> <span class="string">字数统计</span></span><br><span class="line"><span class="attr">item_text:</span> <span class="literal">true</span><span class="comment"># 是否显示文字</span></span><br><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span><span class="comment"># 显示字数</span></span><br><span class="line"><span class="attr">min2read:</span> <span class="literal">true</span> <span class="comment"># 显示阅读时间</span></span><br><span class="line"><span class="attr">totalcount:</span> <span class="literal">true</span><span class="comment"># 显示总数</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否分开</span></span><br></pre></td></tr></table></figure>

<h3 id="修改底部顺序-由于卜算子是单独的一个文件-文件读取靠前"><a href="#修改底部顺序-由于卜算子是单独的一个文件-文件读取靠前" class="headerlink" title="修改底部顺序 由于卜算子是单独的一个文件 文件读取靠前"></a>修改底部顺序 由于卜算子是单独的一个文件 文件读取靠前</h3><p>找到busuanzi-counter.swig文件  把文件内容拷贝到footer.swig文件中  调整模块div位置即可</p>
<p>删除themes\hexo-theme-next\layout_third-party\statistics\index.swig中对busuanzi-counter.swig文件的引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.beian.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;beian&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;- next_url(&#x27;https://beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;</span><br><span class="line">&#123;%- if theme.footer.beian.gongan_icon_url %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(theme.footer.beian.gongan_icon_url) &#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block;&quot;</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line">&#123;%- if theme.footer.beian.gongan_id and theme.footer.beian.gongan_num %&#125;</span><br><span class="line">&#123;&#123;- next_url(&#x27;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=&#x27; + theme.footer.beian.gongan_id, theme.footer.beian.gongan_num + &#x27; &#x27;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span></span><br><span class="line">&#123;% set copyright_year = date(null, &#x27;YYYY&#x27;) %&#125;</span><br><span class="line"><span class="symbol">&amp;copy;</span> &#123;% if theme.footer.since and theme.footer.since != copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">&quot;copyrightYear&quot;</span>&gt;</span>&#123;&#123; copyright_year &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;with-love&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;copyrightHolder&quot;</span>&gt;</span>&#123;&#123; theme.footer.copyright or author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wordcount&quot;</span>&gt;</span></span><br><span class="line">&#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-chart-area&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; symbolsCountTotal(site) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-coffee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125; <span class="symbol">&amp;asymp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __(&#x27;symbols_count_time.time_minutes&#x27;)) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-count&quot;</span>&gt;</span></span><br><span class="line">&lt;script&#123;&#123; pjax &#125;&#125; async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-pv&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;powered-by&quot;</span>&gt;</span></span><br><span class="line">&#123;%- set next_site = &#x27;https://theme-next.org&#x27; %&#125;</span><br><span class="line">&#123;%- if theme.scheme !== &#x27;Gemini&#x27; %&#125;</span><br><span class="line">&#123;%- set next_site = &#x27;https://&#x27; + theme.scheme | lower + &#x27;.theme-next.org&#x27; %&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line">&#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.add_this_id %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;addthis_inline_share_toolbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//s7.addthis.com/js/300/addthis_widget.js#pubid=&#123;&#123; theme.add_this_id &#125;&#125;&quot;</span> <span class="attr">async</span>=<span class="string">&quot;async&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject(&#x27;footer&#x27;) &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>打开<mark>主题配置文件</mark>，修改auto_excerpt:字段为true，length表示显示文本的长度</p>
<p>在想要隐藏的位置加入以下代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加文章评论和阅读次数"><a href="#添加文章评论和阅读次数" class="headerlink" title="添加文章评论和阅读次数"></a>添加文章评论和阅读次数</h3><blockquote>
<p>Valine 仅支持 Next 7.+ 以下版本<br>Next8.0 以上版本取消了Valine评论系统的支持</p>
</blockquote>
<ol>
<li><p>创建LeanCloud账号: <span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhbmNsb3VkLmNuLw==">https://www.leancloud.cn/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>创建应用</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227123921.png" class=""></li>
<li><p>点击存储-&gt;结构化数据 检查是否有Counter Comment 没有则创建</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227125317.png" class=""></li>
<li><p>点击设置-&gt;应用Key 获取AppID AppKey 下文需要用到</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227130954.png" class="" width="700" height="600"></li>
<li><p>打开<mark>主题配置文件</mark>开启Valine</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">appid:</span> <span class="comment">#你的AppID</span></span><br><span class="line"><span class="attr">appkey:</span> <span class="comment">#你的AppKey</span></span><br><span class="line"><span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line"><span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line"><span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line"><span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line"><span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line"><span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读次数</span></span><br><span class="line"><span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 评论次数</span></span><br><span class="line"><span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line"><span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line"><span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定文章关闭评论</p>
</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>自定义头像<br>参考：<span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnL2F2YXRhci5odG1s">https://valine.js.org/avatar.html<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<blockquote>
<p>本篇参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdW5pYW5fMjc2MS9hcnRpY2xlL2RldGFpbHMvOTczODg5OTc=">https://blog.csdn.net/jiunian_2761/article/details/97388997<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="文章插入图片，点击查看大图"><a href="#文章插入图片，点击查看大图" class="headerlink" title="文章插入图片，点击查看大图"></a>文章插入图片，点击查看大图</h3><h4 id="文章插入图片"><a href="#文章插入图片" class="headerlink" title="文章插入图片"></a>文章插入图片</h4><ol>
<li>绝对路径本地引用(不采用)</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>

<p>不推荐 图片存放过多后不便于查找</p>
<ol start="2">
<li>相对路径引用(不采用)</li>
</ol>
<p>开启<mark>站点配置文件</mark>中的post_asset_folder:true,执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<p>这种相对路径的图片显示方法在博文详情页面显示没有问题，但是在首页预览页面图片将显示不出来。</p>
<ol start="3">
<li>标签插件语法引用(采用)</li>
</ol>
<p>标签插件语法，可以使图片在文章和首页中同时显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 本地图片资源，不限制图片尺寸</span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br><span class="line"># 网络图片资源，限制图片显示尺寸</span><br><span class="line">&#123;% img http://www.viemu.com/vi-vim-cheat-sheet.gif 200 400 vi-vim-cheat-sheet %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="点击查看大图"><a href="#点击查看大图" class="headerlink" title="点击查看大图"></a>点击查看大图</h4><p>开启<mark>主题配置文件</mark>中的fancybox</p>
<p>fancybox:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1mYW5jeWJveDM=">https://github.com/theme-next/theme-next-fancybox3<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>本篇参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuenl3dnZkLmNvbS8yMDIwLzAyLzI3L2hleG8vNF9oZXhvX2FkZF9pbWFnZS9oZXhvLWFkZC1pbWFnZS8=">https://www.zywvvd.com/2020/02/27/hexo/4_hexo_add_image/hexo-add-image/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="添加全局搜索功能"><a href="#添加全局搜索功能" class="headerlink" title="添加全局搜索功能"></a>添加全局搜索功能</h3><ol>
<li>安装插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启<mark>主题配置文件</mark>中的local_search</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line"><span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line"><span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line"><span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line"><span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line"><span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h3><ol>
<li>手动修改/node_modules/hexo-generator-index/lib/generator.js</li>
</ol>
<blockquote>
<p>网上的方法，个人不采用，node_modules文件不上传到github 不便于后期维护</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line"><span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line"><span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.top - b.top; <span class="comment">// 否则按照top值升序排</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">perPage: config.index_generator.per_page,</span><br><span class="line">layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">data: &#123;</span><br><span class="line">__index: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在文章title添加top值，值越大文章越靠前</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Linux常用命令 长期更新</span><br><span class="line">date: 2019-09-03</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 技术储备</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Linux</span><br><span class="line">top: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我个人关闭了主题配置文件中的created_at: false和不要文章title中的date 即创建时间，主页和文章仅显示更新时间，Hexo会已更新时间自动进行排序，然后加入top指定文章排序 普通文章设定为0(必须每篇文章都设定，这有点搞心态)，指定文章设定为1，2，3 值越大排序越靠前</p>
</blockquote>
<h3 id="hexo文章模板设置"><a href="#hexo文章模板设置" class="headerlink" title="hexo文章模板设置"></a>hexo文章模板设置</h3><p>每次使用hexo new post “post-name”新建一篇文章时，只有title date tags，<br>还要手动增加top 和 categories。</p>
<p>为了偷懒，修改了hexo/scaffolds中的post.md模板。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">top: 0</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><ul>
<li>新建文章结构</li>
</ul>
<p><mark>站点配置文件</mark>中找到new_post_name修改为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year\:month\:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hexo d 生成文章结构</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year-:month-:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown-语法大全</title>
    <url>/2021-02-MarkDown-%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1496626-851332d4c4ebc3d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt="img"></p>
<p><strong>说明</strong>：现在markDown编译器和各平台支持情况都不太统一，为了达到一些效果会使用语法超集，但有些平台支持不好，请自行裁剪。简书使用的精简语法集合，文中有些语法效果显示不出来，为了发文的格式统一，同时也建议谨慎使用此类语法。</p>
<span id="more"></span>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-设计理念"><a href="#1-1-设计理念" class="headerlink" title="1.1 设计理念"></a>1.1 设计理念</h3><ul>
<li>Markdown 易于阅读，方便创作web文档，利于各平台无缝分发。</li>
<li>Markdown 语法灵感最大的来源还是纯文本 email 的格式，完全由标点符号标签组成的纯文本。</li>
<li>Markdown 文件应该以纯文本形式原样发布，不应该包含标记标签和格式化指令。</li>
</ul>
<h3 id="1-2-内联-HTML-语法"><a href="#1-2-内联-HTML-语法" class="headerlink" title="1.2 内联 HTML 语法"></a>1.2 内联 HTML 语法</h3><ul>
<li>HTML 是一种<strong>发布格式</strong>，Markdown 是一种<strong>创作格式</strong>。</li>
<li>Markdown语法集合比较小，只是HTML标签的一小部分。</li>
<li>对于 Markdown 中未包含的标签, 可以直接使用 HTML标签，例如用 HTML <code>&lt;a&gt;</code> 标签替代 Markdown 的链接语法。</li>
</ul>
<h3 id="1-3-特殊字符自动转义"><a href="#1-3-特殊字符自动转义" class="headerlink" title="1.3 特殊字符自动转义"></a>1.3 特殊字符自动转义</h3><p>  在 HTML 中, 有两个字符需要特殊对待: &lt; 和 &amp;，左尖括号用于起始标签。如果你想将它们用作字面量, 你必须将它们转义为字符实体, 例如<code>&lt;</code> 和 <code>&amp;</code>。</p>
<h2 id="二、行内语法讲解"><a href="#二、行内语法讲解" class="headerlink" title="二、行内语法讲解"></a>二、行内语法讲解</h2><h3 id="2-1-注释的表述"><a href="#2-1-注释的表述" class="headerlink" title="2.1 注释的表述"></a>2.1 注释的表述</h3><ul>
<li><strong>代码法</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#x27;display: none&#x27;</span>&gt;</span></span><br><span class="line">哈哈我是注释，不会在浏览器中显示。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>html注释</strong></li>
</ul>
<p>既然支持html语法，那也支持html注释，快捷键 comment + /。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">哈哈我是多段注释，</span></span><br><span class="line"><span class="comment">不会在浏览器中显示。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>hack方法</strong></li>
</ul>
<p>hack方法就是利用markdown的解析原理来实现注释的。<br> 一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。<br> hack方法比上面2种方法稳定得多，但是语义化太差。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">//</span>]: <span class="meta"># (哈哈我是最强注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="meta">^_^</span>]: <span class="meta"># (哈哈我是最萌注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="meta">//</span>]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[<span class="meta">comment</span>]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-分级标题、任务列表"><a href="#2-2-分级标题、任务列表" class="headerlink" title="2.2 分级标题、任务列表"></a>2.2 分级标题、任务列表</h3><ul>
<li><strong>分级标题</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题  <span class="comment">&lt;!--最多6级标题--&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于用了标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<ul>
<li><strong>任务列表</strong></li>
</ul>
<p>Markdown 语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- <span class="selector-attr">[ ]</span> 任务一 未做任务 `- + 空格 + <span class="selector-attr">[ ]</span>`</span><br><span class="line">- <span class="selector-attr">[x]</span> 任务二 已做任务 `- + 空格 + <span class="selector-attr">[x]</span>`</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>任务一 未做任务 <code>- + 空格 + [ ]</code></li>
<li>任务二 已做任务 <code>- + 空格 + [x]</code></li>
</ul>
<h3 id="2-3-缩进、换行、空行、对齐方式"><a href="#2-3-缩进、换行、空行、对齐方式" class="headerlink" title="2.3 缩进、换行、空行、对齐方式"></a>2.3 缩进、换行、空行、对齐方式</h3><ul>
<li><strong>首行缩进</strong></li>
</ul>
<p>不同特殊占位符所占空白是不一样大的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">【1】 &amp;emsp;或&amp;<span class="comment">#8195; //全角</span></span><br><span class="line">【2】 &amp;ensp;或&amp;<span class="comment">#8194; //半角</span></span><br><span class="line">【3】 &amp;nbsp;或&amp;<span class="comment">#160;  //半角之半角</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>换行</strong></li>
</ul>
<p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要<strong>换行必须得在一行字后面空两个格子才行</strong>。</p>
<ul>
<li><strong>空行</strong></li>
</ul>
<p>在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在<strong>渲染之后，只隔着一行</strong>。</p>
<ul>
<li><strong>对齐方式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">行中心对齐</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>行左对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>行右对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>行中心对齐<br> <p align="left">行左对齐</p><br> <p align="right">行右对齐</p></p>
<h3 id="2-4-斜体、粗体、删除线、下划线、背景高亮"><a href="#2-4-斜体、粗体、删除线、下划线、背景高亮" class="headerlink" title="2.4 斜体、粗体、删除线、下划线、背景高亮"></a>2.4 斜体、粗体、删除线、下划线、背景高亮</h3><ul>
<li>代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*或_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br><span class="line">++下划线++</span><br><span class="line">&#x3D;&#x3D;背景高亮&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li>显示效果：</li>
</ul>
<p>  <em>斜体</em>    <strong>粗体</strong>   <strong><em>加粗斜体\</em></strong>   <del>删除线</del>   ++删除线++   ==背景高亮==</p>
<h3 id="2-5-超链接、页内链接、自动链接、注脚"><a href="#2-5-超链接、页内链接、自动链接、注脚" class="headerlink" title="2.5 超链接、页内链接、自动链接、注脚"></a>2.5 超链接、页内链接、自动链接、注脚</h3><ul>
<li><strong>行内式</strong></li>
</ul>
<p>语法说明：</p>
<p>[]里写链接文字，()里写链接地址, ()中的””中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。</p>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">欢迎阅读 [择势勤](https://www.jianshu.com/u/16d77399d3a7 <span class="string">&quot;择势勤&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>欢迎阅读 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS8xNmQ3NzM5OWQzYTc=">择势勤<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>参考式</strong></li>
</ul>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明：<br> 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br> [链接文字]：链接地址的形式，见代码的最后一行。</p>
<p>代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">我经常去的几个网站[Google][<span class="number">1</span>]、[Leanote][<span class="number">2</span>]。</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]<span class="symbol">:http</span><span class="symbol">://www</span>.google.com </span><br><span class="line">[<span class="number">2</span>]<span class="symbol">:http</span><span class="symbol">://www</span>.leanote.com</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>我经常去的几个网站<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vd3d3Lmdvb2dsZS5jb20=">Google<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vd3d3LmxlYW5vdGUuY29t">Leanote<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li><strong>注脚</strong></li>
</ul>
<p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<p>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">使用 Markdown<span class="selector-attr">[^1]</span>可以效率的书写文档, 直接转换成 <span class="selector-tag">HTML</span><span class="selector-attr">[^2]</span>。</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[^1]</span>:Markdown是一种纯文本标记语言</span><br><span class="line"></span><br><span class="line">[^<span class="number">2</span>]:HyperText Markup Language 超文本标记语言</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>使用 Markdown[<a href="#fn1">1]</a>可以效率的书写文档, 直接转换成 HTML[<a href="#fn2">2]</a>。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的地方。</p>
<ul>
<li><strong>锚点（页内超链接）</strong></li>
</ul>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的，只支持在标题后插入锚点，其它地方无效。</p>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 0. 目录&#123;#index&#125;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>跳转到<a href="#index">目录</a></p>
<ul>
<li><strong>自动链接</strong></li>
</ul>
<p>语法说明：<br> Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p>代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&amp;lt;http:<span class="comment">//example.com/&amp;gt; &amp;emsp;&amp;emsp; </span></span><br><span class="line">&amp;lt;address<span class="meta">@example</span>.com&amp;gt;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>&lt;<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vZXhhbXBsZS5jb20v">http://example.com/<i class="fa fa-external-link-alt"></i></span>&gt;<br> &lt;<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1tYWlsdG86YWRkcmVzc0BleGFtcGxlLmNvbQ==">address@example.com<i class="fa fa-external-link-alt"></i></span>&gt;</p>
<h3 id="2-6-无序列表、有序列表、定义型列表"><a href="#2-6-无序列表、有序列表、定义型列表" class="headerlink" title="2.6 无序列表、有序列表、定义型列表"></a>2.6 无序列表、有序列表、定义型列表</h3><ul>
<li><strong>无序列表</strong><br> 使用 *，+，- 表示无序列表。<br> 代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表项 一</span><br><span class="line">+ 无序列表项 二</span><br><span class="line">- 无序列表项 三</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ul>
<li><p>无序列表项 一</p>
</li>
<li><p>无序列表项 二</p>
</li>
<li><p>无序列表项 三</p>
</li>
<li><p><strong>有序列表</strong></p>
</li>
</ul>
<p>有序列表则使用数字接着一个英文句点。<br> 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 有序列表项 一</span><br><span class="line">2. 有序列表项 二</span><br><span class="line">3. 有序列表项 三</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<ul>
<li><strong>定义型列表表</strong></li>
</ul>
<p>语法说明：</p>
<blockquote>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
</blockquote>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:   轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格）</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>Markdown<br> :   轻量级文本标记语言，可以转换成html，pdf等格式</p>
<h3 id="2-7-插入图像"><a href="#2-7-插入图像" class="headerlink" title="2.7 插入图像"></a>2.7 插入图像</h3><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<p>Markdown 语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--开始居中对齐--&gt;</span></span><br><span class="line"></span><br><span class="line">![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif &quot;图片Title&quot;)</span><br><span class="line">格式: ![图片Alt](图片地址 &quot;图片Title&quot;)</span><br><span class="line"> <span class="comment">&lt;!--结束居中对齐--&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1496626-c3d52ee452341b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310/format/webp" alt="img"></p>
<p>GitHub set up</p>
<h3 id="2-8-多级引用"><a href="#2-8-多级引用" class="headerlink" title="2.8 多级引用"></a>2.8 多级引用</h3><p>语法说明：</p>
<p>引用需要在被引用的文本前加上&gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 &gt; 。</p>
<p>代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白</span><br><span class="line"><span class="meta">&gt;&gt;</span> 自己看教程！ - 愤青</span><br><span class="line">&gt; 教程在哪？ - 小白</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="2-9-转义字符、字体、字号、颜色"><a href="#2-9-转义字符、字体、字号、颜色" class="headerlink" title="2.9 转义字符、字体、字号、颜色"></a>2.9 转义字符、字体、字号、颜色</h3><ul>
<li><strong>转义字符</strong></li>
</ul>
<p>Markdown中的转义字符为\，转义的有：</p>
<p>\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号  # 井号 + 加号 - 减号 . 英文句号 ! 感叹号</p>
<ul>
<li><strong>字体、字号、颜色</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">12</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span>黑体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span>gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">3</span>&gt;</span>null<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><font face="黑体">我是黑体字</font><br> <font face="微软雅黑">我是微软雅黑</font><br> <font face="STCAIYUN">我是华文彩云</font><br> <font color=#0099ff size=12 face="黑体">黑体</font><br> <font color=gray size=5>gray</font><br> <font color=#00ffff size=3>null</font></p>
<h2 id="三、块语法讲解"><a href="#三、块语法讲解" class="headerlink" title="三、块语法讲解"></a>三、块语法讲解</h2><h3 id="3-1-内容目录"><a href="#3-1-内容目录" class="headerlink" title="3.1 内容目录"></a>3.1 内容目录</h3><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>

<p>效果参见最上方的目录。</p>
<h3 id="3-2-代码块"><a href="#3-2-代码块" class="headerlink" title="3.2 代码块"></a>3.2 代码块</h3><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p>
<ul>
<li><strong>行内式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C语言里的函数 `<span class="built_in">scanf</span>()` 怎么使用？</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<ul>
<li><strong>缩进式多行代码</strong></li>
</ul>
<p>缩进 4 个空格或是 1 个制表符</p>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;#<span class="number">34</span>;Hello world\n&amp;#<span class="number">34</span>;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;#<span class="number">34</span>;Hello world\n&amp;#<span class="number">34</span>;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用六个`包裹多行代码</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">、、、</span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure>

<p><strong>显示效果：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-流程图"><a href="#3-3-流程图" class="headerlink" title="3.3 流程图"></a>3.3 流程图</h3><p>编辑自有道云笔记，代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">graph LR</span></span><br><span class="line"><span class="string">A--&gt;B</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">sequenceDiagram</span></span><br><span class="line"><span class="string">A-&gt;&gt;B: How are you?</span></span><br><span class="line"><span class="string">B-&gt;&gt;A: Great!</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: How are you?</span><br><span class="line">B-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>

<h3 id="3-4-表格"><a href="#3-4-表格" class="headerlink" title="3.4 表格"></a>3.4 表格</h3><p>语法说明：</p>
<p>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br> 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br> 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br> <code>-</code> 左对齐， <code>:-:</code> 中心对齐，<code>-:</code> 右对齐</p>
<p>表格代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="params">|学号|</span>姓名<span class="params">|序号|</span></span><br><span class="line"><span class="params">|-|</span>-<span class="params">|-|</span></span><br><span class="line"><span class="params">|小明明|</span>男<span class="params">|5|</span></span><br><span class="line"><span class="params">|小红|</span>女<span class="params">|79|</span></span><br><span class="line"><span class="params">|小陆|</span>男<span class="params">|192|</span></span><br></pre></td></tr></table></figure>

<p>原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th align="center">姓名</th>
<th align="right">序号</th>
</tr>
</thead>
<tbody><tr>
<td>小明明</td>
<td align="center">男</td>
<td align="right">5</td>
</tr>
<tr>
<td>小红</td>
<td align="center">女</td>
<td align="right">79</td>
</tr>
<tr>
<td>小陆</td>
<td align="center">男</td>
<td align="right">192</td>
</tr>
</tbody></table>
<h3 id="3-5-LaTeX-公式"><a href="#3-5-LaTeX-公式" class="headerlink" title="3.5 LaTeX 公式"></a>3.5 LaTeX 公式</h3><ul>
<li><strong>表示行内公式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 `<span class="variable">$E</span> = m c^2 $`来表达。</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>质能守恒方程可以用一个很简洁的方程式 <code>$E = m c^2 $</code>来表达。</p>
<ul>
<li><strong>表示整行公式</strong><br> 大部分的浏览器支持的</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> 公式 <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>有道云笔记 使用格式，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">E = mc^2</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>块级公式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =</span></span><br><span class="line"><span class="string">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; &#x3D;</span><br><span class="line">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]</span><br></pre></td></tr></table></figure>

<p>访问 <span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL21hdGgubWV0YS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTAyMC9tYXRoamF4LWJhc2ljLXR1dG9yaWFsLWFuZC1xdWljay1yZWZlcmVuY2U=">MathJax<i class="fa fa-external-link-alt"></i></span> 参考更多使用方法。</p>
<h3 id="3-6-分隔线"><a href="#3-6-分隔线" class="headerlink" title="3.6 分隔线"></a>3.6 分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure>

<p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h3 id="3-7-HTML-原始码"><a href="#3-7-HTML-原始码" class="headerlink" title="3.7 HTML 原始码"></a>3.7 HTML 原始码</h3><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p><strong>代码：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">第一个例子：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">© 2004 Foo Corporation</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">第二个例子：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>值班人员<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期三<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>李强<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>张明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>王平<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>第一个例子：<br> <div class="footer"><br> © 2004 Foo Corporation<br> </div></p>
<p>第二个例子：</p>
<table> <tr> <th rowspan="2">值班人员</th> <th>星期一</th> <th>星期二</th> <th>星期三</th> </tr> <tr> <td>李强</td> <td>张明</td> <td>王平</td> </tr> </table>

<h3 id="3-8-特殊字符"><a href="#3-8-特殊字符" class="headerlink" title="3.8 特殊字符"></a>3.8 特殊字符</h3><table>
<thead>
<tr>
<th align="center">特殊字符</th>
<th align="center">描述</th>
<th align="center">字符的代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">空格符</td>
<td align="center"><code> </code></td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于号</td>
<td align="center"><code>&lt;</code></td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于号</td>
<td align="center"><code>&gt;</code></td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">和号</td>
<td align="center"><code>&amp;</code></td>
</tr>
<tr>
<td align="center">￥</td>
<td align="center">人民币</td>
<td align="center"><code>¥</code></td>
</tr>
<tr>
<td align="center">©</td>
<td align="center">版权</td>
<td align="center"><code>©</code></td>
</tr>
<tr>
<td align="center">®</td>
<td align="center">注册商标</td>
<td align="center"><code>®</code></td>
</tr>
<tr>
<td align="center">°C</td>
<td align="center">摄氏度</td>
<td align="center"><code>°C</code></td>
</tr>
<tr>
<td align="center">±</td>
<td align="center">正负号</td>
<td align="center"><code>±</code></td>
</tr>
<tr>
<td align="center">×</td>
<td align="center">乘号</td>
<td align="center"><code>×</code></td>
</tr>
<tr>
<td align="center">÷</td>
<td align="center">除号</td>
<td align="center"><code>÷</code></td>
</tr>
<tr>
<td align="center">²</td>
<td align="center">平方（上标²）</td>
<td align="center"><code>²</code></td>
</tr>
<tr>
<td align="center">³</td>
<td align="center">立方（上标³）</td>
<td align="center"><code>³</code></td>
</tr>
</tbody></table>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lYmU1MmQyZDQ2OGY=">https://www.jianshu.com/p/ebe52d2d468f<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-IO流</title>
    <url>/2021-01-JavaSE-IO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a><strong>流的概念</strong></h2><ul>
<li><strong>概念</strong>：内存与存储设备之间传输数据的通道。<img src="/2021-01-JavaSE-IO%E6%B5%81/1.png" class=""></li>
<li>水借助管道传输；数据借助流传输。<span id="more"></span>
</li>
</ul>
<hr>
<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a><strong>流的分类</strong></h2><h3 id="按方向【重点】"><a href="#按方向【重点】" class="headerlink" title="按方向【重点】"></a><strong>按方向【重点】</strong></h3><ul>
<li><strong>输入流</strong>：将&lt;存储设备&gt;中的内容读入到&lt;内存&gt;中。</li>
<li><strong>输出流</strong>：将&lt;内存&gt;中的内容写入到&lt;存储设备&gt;中。</li>
</ul>
<img src="/2021-01-JavaSE-IO%E6%B5%81/2.png" class="">

<h3 id="按单位"><a href="#按单位" class="headerlink" title="按单位"></a><strong>按单位</strong></h3><ul>
<li><strong>字节流</strong>：以字节为单位，可以读写所有数据。</li>
<li><strong>字符流</strong>：以字符为单位，只能读写文本数据。</li>
</ul>
<h3 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a><strong>按功能</strong></h3><ul>
<li><strong>字节流</strong>：具有实际传输数据的读写功能。</li>
<li><strong>过滤流</strong>：在节点流的基础之上增强功能。</li>
</ul>
<hr>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h2><img src="/2021-01-JavaSE-IO%E6%B5%81/3.png" class="">

<h3 id="字节流的父类（抽象类）"><a href="#字节流的父类（抽象类）" class="headerlink" title="字节流的父类（抽象类）"></a><strong>字节流的父类（抽象类）</strong></h3><ul>
<li><p>InputStream</p>
<p>字节输入流</p>
<ul>
<li><code>public int read()&#123;&#125;</code></li>
<li><code>public int read(byte[] b)&#123;&#125;</code></li>
<li><code>public int read(byte[] b,int off,int len)&#123;&#125;</code></li>
</ul>
</li>
<li><p>OutputStream</p>
<p>字节输出流</p>
<ul>
<li><code>public void write(int n)&#123;&#125;</code></li>
<li><code>public void write(byte[] b)&#123;&#125;</code></li>
<li><code>public void write(byte[] b,int off,int len)&#123;&#125;</code></li>
</ul>
</li>
</ul>
<h3 id="字节流的子类"><a href="#字节流的子类" class="headerlink" title="字节流的子类"></a><strong>字节流的子类</strong></h3><h4 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a><strong>文件字节流</strong></h4><ul>
<li><strong>FileInputStream</strong><ul>
<li><code>public int read()</code>//从输入流中读取一个字节数据，返回读到的字节数据，如果达到文件末尾，返回-1。</li>
<li><code>public int read(byte[] b)</code>//从输入流中读取字节数组长度的字节数据存入数组中，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</li>
</ul>
</li>
<li><strong>FileOutputStream</strong><ul>
<li><code>public void write(int b)</code>//将指定字节写入输出流。</li>
<li><code>public void write(bute[] b)</code>//一次写多个字节，将b数组中所有字节，写入输出流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件字节输入流的使用</span></span><br><span class="line"><span class="comment"> * FileInputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//文件内容：abcdefg</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\aaa.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//read();读入单个字节</span></span><br><span class="line">    <span class="keyword">int</span> data=fileInputStream.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)data);<span class="comment">//a</span></span><br><span class="line">    <span class="keyword">while</span>((data=fileInputStream.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;<span class="comment">//bcdefg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//read(byte[] b);读入多个字节</span></span><br><span class="line">    <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span>((data=fileInputStream.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,data));</span><br><span class="line">    &#125;<span class="comment">//bcdefg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件字节输出流的使用</span></span><br><span class="line"><span class="comment"> * FileOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有文件会自动创建</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\bbb.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write(int b);</span></span><br><span class="line">    fileOutputStream.write(<span class="number">97</span>);</span><br><span class="line">    fileOutputStream.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    fileOutputStream.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write(byte[] b);</span></span><br><span class="line">    fileOutputStream.write(<span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>).getBytes());</span><br><span class="line">    <span class="comment">//此时文件bbb.txt内容为abc    helloworld</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件字节流小案例"><a href="#文件字节流小案例" class="headerlink" title="文件字节流小案例"></a><strong>文件字节流小案例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用文件字节流复制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//将图片读取到输入流</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\MrG1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//从输出流写入数据</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\MrG2.jpg&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//保存一次读取到的实际个数</span></span><br><span class="line">    <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((count=fileInputStream.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    fileOutputStream.write(b, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a><strong>字节缓冲流</strong></h4><ul>
<li><p><strong>缓冲流</strong>：BufferedInputStream/BufferedOutputStream</p>
<ul>
<li>提高IO效率，减少访问磁盘的次数；</li>
<li>数据存储在缓冲区中。flush可以将缓存区的内容写入文件，也可以直接close。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字节缓冲流读取</span></span><br><span class="line"><span class="comment">* BufferedInputStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用该输入流每次会从硬盘读入</span></span><br><span class="line">        FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\aaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//缓冲流需要一个底层流</span></span><br><span class="line">        <span class="comment">//缓冲流每次从缓冲区读取</span></span><br><span class="line">        BufferedInputStream bufferedInputStream=<span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">int</span> data; </span><br><span class="line">        <span class="keyword">while</span>((data=bufferedInputStream.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)data); </span><br><span class="line">        &#125;     </span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们也可以自己创建一个缓冲区；</span></span><br><span class="line">        <span class="comment">//每次读取从自己创建的缓冲区中读取。</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((count=bufferedInputStream.read(b,<span class="number">0</span>,b.length))!=-<span class="number">1</span>) &#123;    </span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedInputStream.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字节缓冲流写入文件</span></span><br><span class="line"><span class="comment">* BufferedOutputStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\buf.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//缓冲流将数据写入到缓冲区</span></span><br><span class="line">    BufferedOutputStream bufferedOutputStream=<span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    bufferedOutputStream.write(<span class="string">&quot;helloworld&quot;</span>.getBytes());</span><br><span class="line">    bufferedOutputStream.flush();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实内部也会调用flush</span></span><br><span class="line">    bufferedOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a><strong>对象流</strong></h2><ul>
<li><p><strong>对象流</strong>：ObjectOutputStream/ObjectInputStream</p>
<ul>
<li>增加了缓冲区功能。</li>
<li>增强了读写8种基本数据类型和字符串功能。</li>
<li>增强了读写对象的功能：<ul>
<li><code>readObject()</code>//从流中读取一个对象。</li>
<li><code>writeObject(Object obj)</code>向流中写入一个对象。</li>
</ul>
</li>
</ul>
<p><strong>使用流传输对象的过程称为序列化、反序列化。</strong></p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ObjectOutputStream实现对象的序列化</span></span><br><span class="line"><span class="comment"> * 注：序列化的类必要要实现Serializable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这个文件后缀名表示二进制文件，但你可以写成其他如obj等任意后缀。</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\stu.bin&quot;</span>);</span><br><span class="line">    ObjectOutputStream objectOutputStream=<span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//序列化（写入操作）</span></span><br><span class="line">    Student tang=<span class="keyword">new</span> Student(<span class="string">&quot;唐瑞&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    objectOutputStream.writeObject(tang);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;序列化完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：执行上述代码后IDE会抛出<code>java.io.NotSerializableException</code>，意思是Student类不能被序列化，需要实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不需要实现任何方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>Serializable其实是一个标志接口，用来标志该类是否可以被序列化。我们进到该接口的源码可以发现里面不含任何属性和抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ObjectInputStream实现反序列化（读取重构对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\stu.bin&quot;</span>);</span><br><span class="line">    ObjectInputStream objectInputStream=<span class="keyword">new</span> ObjectInputStream(fileInputStream);</span><br><span class="line">    <span class="comment">//读取文件（反序列化）</span></span><br><span class="line">    Student student=(Student) objectInputStream.readObject();</span><br><span class="line">    </span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化和反序列化注意事项"><a href="#序列化和反序列化注意事项" class="headerlink" title="序列化和反序列化注意事项"></a><strong>序列化和反序列化注意事项</strong></h3><ul>
<li><p>序列化类必须实现Serializable接口，前文已经说过。</p>
</li>
<li><p>序列化类中的对象属性也要求实现Serializable接口。也就是说如果Student类中有一个Grad类型的属性<code>private Grad info;</code>那么Grad这个类也要实现Serializable接口。</p>
</li>
<li><p>序列化类中可以添加序列化版本号ID，以保证序列化的类和被序列化的类是同一个类。在上面的代码中我并没有添加序列号版本，虽然IDE没有报错，但是会显示一个警告，提示我添加序列化版本号（串行版本标识）。我们可以在Student类中添加：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>  此时再运行Demo7就会报一个无效类的异常：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException:</span><br><span class="line">local class incompatible: stream classdesc serialVersionUID = -3126921853274410929, local class serialVersionUID = 666660</span><br></pre></td></tr></table></figure>

<p>  意思就是两个类的serialVersionUID不一样。可以看到之前虽然没有显式添加序列版本号，但它已经自动生成了一个。我们再运行一下Demo6序列化，再运行Demo7反序列化就可以正常执行了。</p>
<ul>
<li>使用transient（短暂的）修饰属性，可以避免该属性被序列化。用它来修饰age：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>

<p>  对象序列化后再反序列化，这个对象的age属性就变成了0。</p>
<ul>
<li><p>静态属性不能被序列化。</p>
</li>
<li><p>可以利用集合来序列化多个对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">arrayList.add(s1);</span><br><span class="line">arrayList.add(s2);</span><br><span class="line">arrayList.add(s3);</span><br><span class="line">objectOutputStream.writeObject(arrayList);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; list=(ArrayList&lt;Student&gt;)objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a><strong>编码方式</strong></h2><ul>
<li><p>IOS-8859-1</p>
<p>收录除ASCII外，还包括西欧、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。采用1个字节来表示，最多只能表示256个字符。</p>
</li>
<li><p>UTF-8</p>
<p>针对Unicode码表的可变长度字符编码。国际上使用的编码，也称为“万国码”，收录了几乎所有国家的常用字符。采用1至3个字节来表示一个字符。</p>
</li>
<li><p>GB2312</p>
<p>简体中文，采用1个或2个字节来表示字符，95年之前所采用的编码。</p>
</li>
<li><p>GBK</p>
<p>简体中文的扩充，GB2312的升级版本。</p>
</li>
<li><p>BIG5</p>
<p>台湾，繁体中文。</p>
</li>
</ul>
<p><strong>当编码方式和解码方式不一致时，会出现乱码。</strong>假如Demo1中的文件内容不是字母而是“<strong>我爱中国</strong>”这样的汉字，那么读取出来的信息就是乱码。因为字节流按字节输入输出，而这1个汉字占了12个字节，1个汉字占3个字节，把一个汉字按一个一个字节读入自然会出现问题，这时就需要使用字符流。</p>
<hr>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a><strong>字符流</strong></h2><img src="/2021-01-JavaSE-IO%E6%B5%81/4.png" class="">

<h3 id="字符流的父类（抽象类）"><a href="#字符流的父类（抽象类）" class="headerlink" title="字符流的父类（抽象类）"></a>字符流的父类（抽象类）</h3><ul>
<li><p><strong>Reader：</strong>字符输入流</p>
<ul>
<li><p><code>public int read()</code></p>
<p>从流中读取单个字符，用整型来返回读取的字符；当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] c)</code></p>
<p>从流中读取字符保存到c数组中，返回读取的字符个数，当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] cbuf,int off,int len)&#123;&#125;</code></p>
<p>抽象方法。</p>
</li>
</ul>
</li>
<li><p><strong>Writer：</strong>字符输出流</p>
<ul>
<li><p><code>public void write(int n)</code></p>
<p>写入单个字符，只能写入包含16位低阶字节的整型数值，16位高阶字节将会被忽略。</p>
</li>
<li><p><code>public void write(String str)</code></p>
<p>写入一个字符串。</p>
</li>
<li><p><code>public void write(char[] cbuf)</code></p>
<p>写入一个字符数组。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符流的子类"><a href="#字符流的子类" class="headerlink" title="字符流的子类"></a><strong>字符流的子类</strong></h3><ul>
<li><p><strong>FileReader：</strong></p>
<ul>
<li><p><code>public int read()</code></p>
<p>继承自InputStreamReader类。读取单个字符，返回读取的字符，当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] c)</code></p>
<p>继承自Reader类。</p>
</li>
<li><p><code>public int read(char[] cbuf,int offset,int length)</code></p>
<p>继承自InputStreamReader类。从流中读取部分字符到cbuf中指定位置，返回读取到的字符个数，当读到流底部时返回-1。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    <span class="comment">//文件内容：</span></span><br><span class="line">    <span class="comment">//要是能活在梦里，我情愿醒不过来。</span></span><br><span class="line">    FileReader fileReader=<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\cbuf.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">//read();与字节流不同，该方法读取单个字符而不是字节</span></span><br><span class="line">    <span class="keyword">while</span>((data=fileReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出：</span></span><br><span class="line">    <span class="comment">//要是能活在梦里，我情愿醒不过来。</span></span><br><span class="line">    fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里记录我遇到的一个问题</strong>：</p>
<p>上述代码执行后理应是正常输出一段文字，但我这里出现了文字乱码。猜测是编码出现了问题，于是查看本地文本的保存格式为UTF-8，感觉也没错，于是打开JDK API查看FileReader类的描述：</p>
<blockquote>
<p>Convenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate. To specify these values yourself, construct an InputStreamReader on a FileInputStream.</p>
</blockquote>
<p>大意就是该类的构造方法有一个默认的字符编码格式和一个默认字节缓冲区，并没有指明这个编码格式就是UTF-8。于是查看系统默认编码，打开CMD输入chcp，得到一个值为936的活动编码页，通过查询得知该代码页所对应的国家（地区）或语言为：中国 - 简体中文(GB2312)。这与本地所保存的文本编码UTF-8不一致，所以导致了文字乱码的出现。而要指定编码格式需要创建一个InputStreamReader或FileInputStream对象使用其构造方法。</p>
<p>以下是我在本地能正常运行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    <span class="comment">//指定编码格式</span></span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\cbuf.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">while</span>((data=inputStreamReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;</span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>FileWriter:</strong></p>
<ul>
<li><p><code>public void write(int c)</code></p>
<p>继承自OutputStreamWriter类，写入一个字符。</p>
</li>
<li><p><code>public void write(String str)</code></p>
<p>继承自Writer类。</p>
</li>
<li><p><code>public void Write(char[] cbuf)</code></p>
<p>继承自Writer类。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用FileWriter写入文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileWriter fileWriter=<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//写入</span></span><br><span class="line">    fileWriter.write(<span class="string">&quot;给自己一个希望。&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    fileWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符流小案例"><a href="#字符流小案例" class="headerlink" title="字符流小案例"></a><strong>字符流小案例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FileReader和FileWrite复制文本文件</span></span><br><span class="line"><span class="comment"> *  注：不能复制图片或二进制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\w.txt&quot;</span>));</span><br><span class="line">    FileWriter fileWriter=<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">int</span> data=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((data=inputStreamReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    fileWriter.write(data);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">    fileWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a><strong>字符缓冲流</strong></h4><ul>
<li><p><strong>缓冲流</strong>：BufferedReader/BufferedWriter</p>
<ul>
<li>高效读写</li>
<li>支持换行输入符</li>
<li>可一次写一行、读一行。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字符缓冲流读取文件</span></span><br><span class="line"><span class="comment">* BufferedReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\cbuf.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">    <span class="comment">//read(char[] cbuf)</span></span><br><span class="line">    <span class="keyword">char</span>[] cbuf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">while</span>((count=bufferedReader.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,count));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//readline();</span></span><br><span class="line">    <span class="comment">//该方法一次读取一行，返回一个字符串</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line=bufferedReader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字符缓冲流写入文件</span></span><br><span class="line"><span class="comment">* BufferedWriter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w3.txt&quot;</span>));</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;真有人看这篇博客吗？&quot;</span>);</span><br><span class="line">    <span class="comment">//写入一个换行符windows \r\n  linux \n</span></span><br><span class="line">    bufferedWriter.newLine();</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;不会吧不会吧！！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    bufferedWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a><strong>打印流</strong></h4><ul>
<li><p><strong>PrintWriter：</strong></p>
<ul>
<li>封装了print()/println()方法，支持写入后换行。</li>
<li>支持数据原样打印。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PrintWriter的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;d:\\p.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//打印到文件</span></span><br><span class="line">    printWriter.println(<span class="number">97</span>);<span class="comment">//97</span></span><br><span class="line">    printWriter.println(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//b</span></span><br><span class="line">    printWriter.println(<span class="number">3.14</span>);<span class="comment">//3.14</span></span><br><span class="line">    printWriter.println(<span class="keyword">true</span>);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    printWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><strong>转换流</strong></h4><ul>
<li><p><strong>桥转换流</strong>：InputStreamReader/OutputStreamWriter</p>
<ul>
<li>可将字节流转换为字符流。</li>
<li>可设置字符的编码方式。</li>
</ul>
<p>其实这个在上面的Demo中我已经用过了，这里不再演示InputStreamReader的使用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用OutputStreamWriter写入文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//可以自行指定编码</span></span><br><span class="line">    OutputStreamWriter outputStreamWriter=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\info.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.write(<span class="string">&quot;知道的越多，不明白的也就更多，学海无涯。&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用案例-总结"><a href="#常用案例-总结" class="headerlink" title="常用案例(总结)"></a>常用案例(总结)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCommon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D://IOCommon.txt&quot;</span>);<span class="comment">//字节输入流</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//转换流 字节转字符+指定编码</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);<span class="comment">//缓冲输入流</span></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="comment">//方式1</span></span><br><span class="line">        FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D://IOCommon1.txt&quot;</span>);<span class="comment">//字节输出流</span></span><br><span class="line">        OutputStreamWriter osw= <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//转换流 字符转字节+指定编码</span></span><br><span class="line">        BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(osw);<span class="comment">//缓冲输出流</span></span><br><span class="line">        <span class="comment">//方式2 原样输出 不支持指定编码</span></span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;D://IOCommon2.txt&quot;</span>);<span class="comment">//打印流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String line=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.write(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line">        br.close();</span><br><span class="line">        osw.close();</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a><strong>File类</strong></h2><ul>
<li><p><strong>概念</strong>：代表物理盘符中的一个<strong>文件</strong>或者<strong>文件夹</strong>。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><p><code>public boolean CreateNewFile()</code></p>
<p>当且仅当指定的文件名不存在时创建一个指定的新的、空的文件。创建成功返回true，如果指定文件名已存在返回false。</p>
</li>
<li><p><code>public boolean mkdir()</code></p>
<p>创建一个指定路径名的文件夹。当且仅当文件夹被创建时返回true，否则返回false。</p>
</li>
<li><p><code>public boolean delete()</code></p>
<p>删除一个指定的文件或文件夹，文件夹必须为空才能被删除。当且仅当指定的文件或文件夹被删除时返回true，否则返回false。</p>
</li>
<li><p><code>public boolean exists()</code></p>
<p>检查指定的文件或文件夹是否存在。当且仅当指定的文件或者文件夹存在时返回true，否则返回false。</p>
</li>
<li><p><code>public File[] listFiles()</code></p>
<p>列出目录中的所有内容，返回一个指定路径名中的文件数组，如果指定的路径名不代表一个文件夹（目录）就返回null。</p>
</li>
<li><p><code>public boolean renameTo(File dest)</code></p>
<p>重命名一个路径名所指定的文件。当且仅当修改操作成功时返回true，否则返回false。</p>
</li>
</ul>
</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件操作</span></span><br><span class="line"><span class="comment"> * 分隔符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//输出：</span></span><br><span class="line">    <span class="comment">//路径分隔符：;</span></span><br><span class="line">    <span class="comment">//名称分隔符：\</span></span><br><span class="line">    separator();</span><br><span class="line">    </span><br><span class="line">    fileOp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;路径分隔符：&quot;</span>+File.pathSeparator);</span><br><span class="line">    System.out.println(<span class="string">&quot;名称分隔符：&quot;</span>+File.separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileOp</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建文件</span></span><br><span class="line">    File file=<span class="keyword">new</span> File(<span class="string">&quot;d:\\file.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag=file.createNewFile();    </span><br><span class="line">    System.out.println(<span class="string">&quot;创建状态：&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.删除文件</span></span><br><span class="line">    <span class="comment">//2.1 直接删除</span></span><br><span class="line">    <span class="comment">/* System.out.println(&quot;删除结果：&quot;+file.delete()); */</span></span><br><span class="line">    <span class="comment">//2.2 使用JVM退出时删除（不是自己删除）</span></span><br><span class="line">    file.deleteOnExit();</span><br><span class="line">    <span class="comment">//调用休眠程序观察删除操作</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.获取文件信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取路径：&quot;</span>+file.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取父目录：&quot;</span>+file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件名称：&quot;</span>+file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件长度：&quot;</span>+file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件创建时间：&quot;</span>+<span class="keyword">new</span> Date(file.lastModified()).toLocaleString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否可写：&quot;</span>+file.canWrite());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可读：&quot;</span>+file.canRead());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span>+file.isHidden());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+file.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件夹：&quot;</span>+file.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a><strong>文件夹操作</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件夹的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    directorOp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">directorOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建文件夹</span></span><br><span class="line">    File dir=<span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb\\ccc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">    <span class="comment">//mkdir();只能创建单级目录</span></span><br><span class="line">    <span class="keyword">boolean</span> flag=dir.mkdirs();<span class="comment">//创建多级目录</span></span><br><span class="line">    System.out.println(<span class="string">&quot;创建结果：&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.删除文件夹</span></span><br><span class="line">    <span class="comment">//2.1 直接删除（必须为空目录）</span></span><br><span class="line">    <span class="comment">//System.out.println(&quot;删除结果：&quot;+dir.delete());</span></span><br><span class="line">    <span class="comment">//2.2 使用jvm删除</span></span><br><span class="line">    dir.deleteOnExit();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.获取文件夹信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取绝对路径：&quot;</span>+dir.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取路径：&quot;</span>+dir.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取父目录：&quot;</span>+dir.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取创建时间：&quot;</span>+<span class="keyword">new</span> Date(dir.lastModified()).toLocaleString());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件夹名称：&quot;</span>+dir.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span>+dir.isHidden());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+dir.isFile());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历文件夹</span></span><br><span class="line">    File dir2=<span class="keyword">new</span> File(<span class="string">&quot;d:\\&quot;</span>);</span><br><span class="line">    String[] files=dir2.list();</span><br><span class="line">    <span class="keyword">for</span> (String string : files) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a><strong>文件过滤器</strong></h3><ul>
<li><p><strong>FileFilter接口：</strong></p>
<p><code>public interface FileFilter</code></p>
<ul>
<li><code>boolean accepte(File pathname)</code></li>
<li>当调用File类中的listFiles()方法时，支持传入FileFilter接口实现类，对获取的文件进行过滤，只有满足条件的文件才可以出现在listFiles()的返回值中。</li>
</ul>
<p>在上文Demo2中添加演示代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">directorOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File[] files1=dir2.listFiles(<span class="keyword">new</span> FileFilter() &#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathname.getName().endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (File file : files1) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件操作小案例"><a href="#文件操作小案例" class="headerlink" title="文件操作小案例"></a><strong>文件操作小案例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.递归遍历文件夹</span></span><br><span class="line"><span class="comment"> * 2.递归删除文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//案例1：递归遍历文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDer</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    File[] files=dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        listDer(file);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//案例2：递归删除文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    File[] files=dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files!=<span class="keyword">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        deleteDir(file);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    dir.delete();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="补充：Properties"><a href="#补充：Properties" class="headerlink" title="补充：Properties"></a><strong>补充：Properties</strong></h2><ul>
<li><p><strong>Properties：</strong>属性集合</p>
</li>
<li><p><strong>特点：</strong></p>
</li>
<li><p>存储属性名和属性值（键值对）。</p>
<ul>
<li>属性名和属性值都是字符串类型。</li>
<li>没有泛型。</li>
<li>和流有关（所以没有整理在集合里面）。</li>
</ul>
</li>
<li><p><strong>方法：</strong></p>
<ul>
<li><p><code>public String getProperty(String key)</code></p>
<p>根据key在属性列表里查找value，如果原始属性列表找不到就去默认属性列表找。返回key所对应的value。</p>
</li>
<li><p><code>public void list(PrintWriter out)</code></p>
<p>将属性列表打印在指定的输出流上，在debug时很有用。</p>
</li>
<li><p><code>public Object setProperty(String key,String value)</code></p>
<p>内部调用的是Hashtable的put方法，将key和value成对地保存在属性列表中。返回这个key上一个对应的value，没有就返回null。</p>
</li>
</ul>
<p>Properties可以保存在一个流中或是从一个流中加载，属性列表中的每个键值对都是一个字符串。一个属性列表可以包括另一个第二属性列表来作为它的默认值，如果在原始属性列表中没有找到key时就搜索第二属性列表。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示集合properties的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//添加数据</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tangrui&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    System.out.println(properties.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="comment">//3.1 keySet 略</span></span><br><span class="line">    <span class="comment">//3.2 entrySet 略</span></span><br><span class="line">    <span class="comment">//3.3 stringPropertyNames()</span></span><br><span class="line">    Set&lt;String&gt; set=properties.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">    System.out.println(string+<span class="string">&quot; &quot;</span>+properties.getProperty(string));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和流有关的方法</span></span><br><span class="line">    <span class="comment">//list</span></span><br><span class="line">    PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;d:\\print.txt&quot;</span>);</span><br><span class="line">    properties.list(printWriter);</span><br><span class="line">    printWriter.close();</span><br><span class="line">    <span class="comment">//store保存</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\s.properties&quot;</span>);</span><br><span class="line">    properties.store(fileOutputStream, <span class="string">&quot;NOTES&quot;</span>);</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    <span class="comment">//load加载</span></span><br><span class="line">    Properties properties2=<span class="keyword">new</span> Properties();</span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\s.properties&quot;</span>);</span><br><span class="line">    properties2.load(fileInputStream);</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    System.out.println(properties2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用类</title>
    <url>/2021-01-JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li><strong>内部类的概念</strong><br>在一个类的内部再定义一个完整的类，一般内部类和外部类都会有依赖（层次）关系。</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类 身体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;</span><br><span class="line">    <span class="comment">//内部类 头</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>内部类的特点</strong></p>
<ul>
<li><p><strong>编译之后可生成独立的字节码文件</strong>。<br>上述代码在编译之后，除了生成一个<code>Body.class</code>文件，还会生成一个内部类文件<code>Body$Head.class</code>。</p>
</li>
<li><p><strong>内部类可以直接访问外部类的私有成员，而不破外封装性</strong>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> headNum=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//直接访问，没有问题</span></span><br><span class="line">            System.out.println(headNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>可为外部类提供必要的内部功能组件</strong>。<br>比如Head作为Body的“组件”。</p>
</li>
<li><p><strong>内部类的分类</strong></p>
<ol>
<li>成员内部类</li>
<li>静态内部类【重点】</li>
<li>局部内部类</li>
<li>匿名内部类【重点】</li>
</ol>
</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li><p><strong>在类的内部定义的</strong>，<strong>与实例变量</strong>、<strong>实例方法同级别的类</strong>。</p>
</li>
<li><p><strong>作为外部类的一个实例部分</strong>，<strong>创建内部类对象时</strong>，<strong>必须依赖外部类对象</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//访问外部类</span></span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">            <span class="comment">//访问内部类</span></span><br><span class="line">            System.out.println(phone);</span><br><span class="line">            System.out.println(address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建外部类对象</span></span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//2.创建内部类对象</span></span><br><span class="line">        Outer.Inner inner=outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一步到位</span></span><br><span class="line">        Outer.Inner inner2=<span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>当外部类</strong>、<strong>内部类存在同名属性时</strong>，<strong>会优先访问内部类属性</strong>。</p>
<p>在Inner类中新增属性<code>private int age=18;</code></p>
<p>再次运行testOuter类，控制台打印的age属性为18而不是21。</p>
<p>那么如何在Inner内部类中访问外部类的同名属性呢？很简单：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这表示访问Outer类的当前对象的age</span></span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.age);<span class="comment">//21</span></span><br><span class="line"><span class="comment">//这表示访问当前类对象的age</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.age);<span class="comment">//18</span></span><br></pre></td></tr></table></figure>

<p>第二句话中不加this也可以，但是加了会更清楚访问的是哪个类中的属性。</p>
<ul>
<li><strong>成员内部类不能定义静态成员</strong>。</li>
</ul>
<p>例外就是可以包含final修饰的静态常量。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul>
<li><strong>在成员内部类的基础之上添加一个static关键字</strong>，<strong>就变成了静态内部类</strong>。</li>
<li><strong>不依赖外部对象</strong>，<strong>可直接创建或通过类名访问</strong>，<strong>可声明静态成员</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类，相当于一个外部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//访问外部类的属性，需要创建外部类对象</span></span><br><span class="line">            Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">            System.out.println(outer.name);</span><br><span class="line">            System.out.println(outer.age);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用静态内部类的属性和方法，直接使用</span></span><br><span class="line">            System.out.println(phone);</span><br><span class="line">            System.out.println(address);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类直接创建</span></span><br><span class="line">        <span class="comment">//外部类.内部类 仅表示一种包含关系</span></span><br><span class="line">        Outer.Inner inner=<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>只有内部类才可以用static修饰，普通的类（外部类）不可以。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul>
<li><strong>类似局部变量</strong>，<strong>定义在外部类方法中</strong>；<strong>作用范围和创建对象范围仅限于当前方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示局部内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义局部变量</span></span><br><span class="line">        String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类,不能加任何访问修饰符</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> String email=<span class="string">&quot;99@qq.com&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//直接访问外部类的属性</span></span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="comment">//其实上一句省略了前缀，建议以后使用时加上。</span></span><br><span class="line">                System.out.println(Outer.<span class="keyword">this</span>.age);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//访问内部类属性</span></span><br><span class="line">                System.out.println(phone);</span><br><span class="line">                <span class="comment">//上一句省略了this</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.email);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//直接使用show方法，会有输出结果吗？</span></span><br><span class="line">        outer.show();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在testOuter中，创建了一个外部类对象调用其show方法，不会有任何结果，因为在show方法中，只是定义了一个局部变量和一个类，除此之外没有做任何事。如果要调用innerShow方法，想想该怎么修改代码？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//要调用局部内部类的方法，就要创建局部内部类对象</span></span><br><span class="line">        Inner inner=<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerShow();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候重新运行代码，控制台就正常打印了。</p>
<ul>
<li><p><strong>局部内部类访问外部类当前方法中的局部变量时</strong>，<strong>因无法保障变量的生命周期与自身相同</strong>，<strong>变量必须修饰为final</strong>。</p>
<p>举个例子，看上文的Outer类代码段，在JDK1.7之前，在局部内部类Inner的innerShow方法中添加代码：</p>
<p><code>System.out.println(address);//访问局部变量</code></p>
<p>这是不行的，除非address变量被final修饰成为一个常量。因为方法中的局部变量在离开方法体之后就会被立即销毁，而在方法体中new的局部内部类对象却不会立即消失（当然inner这个变量是没有了），而是留在堆中等待回收。想一想，局部内部类对象还存在，而他所访问的局部变量被销毁了，这是不可行的。而局部变量被final修饰之后就变成了一个常量，上文所添加的代码就相当于：</p>
<p>``System.out.println(“四川”);`</p>
<p>在JDK1.8中，局部变量即使没有被final修饰，在局部内部类使用时IDE也不会报错，这是因为在JDK1.8中会自动添加final修饰词。</p>
</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ul>
<li><p><strong>没有类名的局部内部类</strong>（<strong>一切特征都与局部内部类相同</strong>）。</p>
<p>实际上只是我们定义的时候没有取名字罢了，编译器编译之后会自动取一个名字。</p>
</li>
<li><p><strong>必须继承一个父类或者实现一个接口</strong>。</p>
<p>这不仅是使用的要求，这也是一般情况下使用匿名内部类的目的。</p>
</li>
</ul>
<p>演示一下匿名内部类的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个实现接口的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标正在工作。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        USB usb=<span class="keyword">new</span> Mouse();</span><br><span class="line">        usb.work();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是正常情况下我们新建一个实现类，可以让我们在不同类中多次使用。但是如果某个实现类只需要用到一次，之后就不会再用了，如果还是单独建一个class来实现的话是否麻烦且多余了？这时候就可以简化成局部内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机已连接。&quot;</span>);            </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        Phone phone=<span class="keyword">new</span> Phone();</span><br><span class="line">        phone.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为实现类只使用一次，类名看起来也是多余的，那么再精简优化一下就变成了<strong>匿名内部类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在new的接口中实现方法，这里也可以是一个抽象方法或者一个父类</span></span><br><span class="line">        USB phone=<span class="keyword">new</span> USB() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机已连接。&quot;</span>);        </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;;</span><br><span class="line">        phone.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>它是定义类</strong>、<strong>实现类</strong>、<strong>创建对象的语法合并</strong>，<strong>只能创建一个该类的对象</strong>。</p>
</li>
<li><p><strong>优点是减少代码量</strong>，<strong>缺点是可读性差</strong>。</p>
<p>我们可以查看一下本地生成的class文件，发现会一个<code>testUSB$1.class</code>文件，这个1就可以理解是匿名内部类的名字。</p>
</li>
</ul>
<hr>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li><p><strong>超类</strong>、<strong>基类</strong>，<strong>所有类的直接或间接父类</strong>，<strong>位于继承树的最顶层</strong>。</p>
</li>
<li><p><strong>任何类</strong>，<strong>如果没写extends关键字继承某个类</strong>，<strong>那么默认的就是直接继承Object类</strong>。</p>
</li>
<li><p><strong>Object类中所定义的方法</strong>，<strong>是所有对象都具备的方法</strong>。</p>
</li>
<li><p>Object类型可以存储任何对象</p>
<p>。</p>
<ul>
<li>作为参数，可接受任何对象。</li>
<li>作为返回值，可返回任何对象。</li>
</ul>
</li>
</ul>
<h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h3><ul>
<li><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></li>
<li><strong>返回引用中存储的实际对象类型</strong>。</li>
<li><strong>应用</strong>：<strong>通常用于判断两个引用中实际存储对象类型是否一致</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示getClass方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        Class class1=s1.getClass();</span><br><span class="line">        Class class2=s2.getClass();</span><br><span class="line">        <span class="keyword">if</span>(class1==class2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;属于同一类&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不属于同一类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><ul>
<li><p><code>pubilc int hashCode()&#123;&#125;</code></p>
</li>
<li><p><strong>返回该对象的哈希码值</strong>。</p>
</li>
<li><p><strong>哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值</strong>。</p>
</li>
<li><p><strong>一般情况下相同对象返回相同哈希码</strong>。</p>
<p>在我的另一篇有关集合的博客里就重写过这个方法使不同的对象返回相同的哈希码值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        System.out.println(s1.hashCode());<span class="comment">//96321</span></span><br><span class="line">        System.out.println(s2.hashCode());<span class="comment">//97314</span></span><br><span class="line">        <span class="comment">//相同字符串生成的哈希值相同</span></span><br><span class="line">        System.out.println(s3.hashCode());<span class="comment">//96321</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li><p><code>public String toString()&#123;&#125;</code></p>
</li>
<li><p><strong>返回该对象的字符串表示</strong>（<strong>表现形式</strong>）。</p>
<p>默认返回的是类名和一个十六进制表示的哈希值，也就是<code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code>。</p>
</li>
<li><p><strong>可以根据程序需求覆盖该方法</strong>，<strong>如展示对象的各个属性值</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//输出 包名.Student@15db9742</span></span><br><span class="line">        System.out.println(s1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般在使用这个方式时不会直接调用Object的父类方法，而是重写成自己期望的输出，例如通过调用这个方法得知当前对象的属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student类中重写方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再运行程序就是我们想看到的结果了。</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><ul>
<li><code>public boolean equals(Object obj)&#123;&#125;</code></li>
<li><strong>默认实现为（this==obj）</strong>，<strong>比较两个对象地址是否相同</strong>。</li>
<li><strong>可进行覆盖</strong>，<strong>比较两个对象的内容是否相同</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示equals的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);        </span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个对象的地址不同所以两个对象不相等，如果两个对象属性相同便认为他们是同一个对象，可以重写equals代码，重写一般会有固定的步骤：</p>
<ol>
<li>比较两个引用是否指向同一个对象。</li>
<li>判断obj是否为null。</li>
<li>判断两个引用指向的实际对象类型是否一致。</li>
<li>强制类型转换。</li>
<li>依次比较各个属性值是否相同。</li>
</ol>
<p>也可以使用IDE的快捷功能自动重写，以下是eclipes的重写内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Student other = (Student) obj;</span><br><span class="line">    <span class="keyword">if</span> (age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再次运行代码，控制台就输出true了。</p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><ul>
<li><p><strong>当对象被判定为垃圾对象时</strong>，<strong>由JVM自动调用此方法</strong>，<strong>用以标记垃圾对象</strong>，<strong>进入回收队列</strong>。</p>
<ul>
<li><p><strong>垃圾对象</strong></p>
<p>没有有效引用指向此对象时，为垃圾对象。</p>
</li>
<li><p><strong>垃圾回收</strong></p>
<p>由GC销毁垃圾对象，释放数据存储空间。</p>
</li>
<li><p><strong>自动回收机制</strong></p>
<p>JVM的内存耗尽，一次性回收所有垃圾对象。</p>
</li>
<li><p><strong>手动回收机制</strong></p>
<p>使用<code>System.gc();</code>通知JVM执行垃圾回收。</p>
</li>
</ul>
<p>这个方法实际上是不包含任何代码，它是一个空的方法，你可以重写该方法来观察JVM是否回收了某些对象，此处不再演示。</p>
</li>
</ul>
<hr>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p><strong>什么是包装类</strong>？</p>
<p>基本数据类型所对应的引用数据类型。</p>
</li>
<li><p><strong>Object可统一所有数据</strong>，<strong>包装的默认值为null</strong>。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>每个基本类型都对应着一个引用（包装）类型，基本类型存储在栈空间而引用类型存储在堆空间；把基础类型转换成引用类型的过程叫做装箱，每个引用类型都提供了一些方法和属性可供使用；把引用类型转换成基础类型的过程叫做拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拆箱和装箱演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装箱（两种方法）</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">        Integer integer1=<span class="keyword">new</span> Integer(num1);</span><br><span class="line">        Integer integer2=Integer.valueOf(num1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拆箱</span></span><br><span class="line">        <span class="keyword">int</span> num2=integer1.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.5之前，我们需要进行如上的操作来装箱和拆箱，但在JDK1.5之后，java就提供了自动装箱和拆箱的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">    Integer integer1=num1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆箱</span></span><br><span class="line">    <span class="keyword">int</span> num2=integer1;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不必调用方法传值便可以实现装箱和拆箱。但实际上并不是不需要写，而是编译的时候java自动帮你做了这些工作。我们可以使用一个小工具Xjad来验证一下，这是一个反编译的工具，可以把class文件反编译成java代码，如果有需要可以自己百度下，这里只简单描述一下。运行上一段代码，将编译的class文件拖到这个小工具中，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    Integer integer1 = Integer.valueOf(num1);</span><br><span class="line">    <span class="keyword">int</span> num2 = integer1.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件在编译后自动调用了Integer中的方法。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>8种包装类提供不同类型间的转换方式。</p>
<ol>
<li>Number父类中提供的6个共性方法。</li>
<li>parseXXX()静态方法。</li>
<li>valueOf()静态方法。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基本类型和字符串之间的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.基本类型转换成字符串</span></span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">255</span>;</span><br><span class="line">        <span class="comment">//1.1 使用+号</span></span><br><span class="line">        String s1=n1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//1.2 使用Integer中的tostring方法</span></span><br><span class="line">        String s3=Integer.toString(n1);</span><br><span class="line">        String s2=Integer.toString(n1, <span class="number">10</span>);<span class="comment">//第二个参数是基数，可以理解为x进制</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.字符串转换成基本类型</span></span><br><span class="line">        String string=<span class="string">&quot;150&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n2=Integer.parseInt(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串转换成boolean类型，&quot;true&quot;-&gt;&quot;true&quot;  &quot;非true&quot;-&gt;&quot;false&quot;</span></span><br><span class="line">        String string2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line">        String string3=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b1=Boolean.parseBoolean(string2);<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">boolean</span> b2=Boolean.parseBoolean(string3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数缓冲区【重点】"><a href="#整数缓冲区【重点】" class="headerlink" title="整数缓冲区【重点】"></a>整数缓冲区【重点】</h3><ul>
<li><p><strong>Java预先创建了256个常用的整数包装类型对象</strong>。</p>
<p>什么意思呢？给大家三个问题，在继续往下看时，你先在心里给出一个答案：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 结果输出什么？</span></span><br><span class="line">        Integer integer1=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.结果输出什么？</span></span><br><span class="line">        Integer integer3=<span class="number">100</span>;</span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer3==integer4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.结果输出什么？</span></span><br><span class="line">        Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">        System.out.println(integer5==integer6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  三个问题的结果分别是<strong>false</strong>，<strong>true</strong>，<strong>false</strong>。</p>
<p>  先来回答第一个问题，两个存储在栈空间的变量分别指向的是两个堆空间中的对象，两个对象的地址不一样，所以在比较时返回了false。</p>
<p>  第二个问题和第三个问题都是进行了自动装箱，为什么结果不一样？我们先来看看java是如何自动装箱的，同样借助Xjad小工具反编译Demo2.class文件，得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1 == integer2);</span><br><span class="line">        Integer integer3 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        Integer integer4 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer3 == integer4);</span><br><span class="line">        Integer integer5 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        Integer integer6 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        System.out.println(integer5 == integer6);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  发现java自动装箱调用的是valueOf这个方法，<strong>重点</strong>来了，进入到这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  可以看见该方法首先判断了传入值的范围，我们查看一下这个范围的大小，进入到IntegerCache类的源码（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码只截取了部分，以便更好地分析与讲解</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  IntegerCache字面意思就是整型缓冲区。该类定义了一个值为-128的变量low和一个值为127的变量high，还有一个数组大小为[(127+128)+1]=256的变量cache；并且，使用了一个for循环，用-128到127范围的值初始化了cache数组。</p>
<p>  这时候再回到valueOf方法源码中，发现if判断的就是传入值是否在-128到127之间，是的话就直接返回cache数组中的对应值，也就是说，如果传入的数字在这个范围内，那么对应装箱的Integer对象其实已经是初始化过的，直接拿来用。如果valueOf方法传入的值不在这个范围，那么返回的就是用Integer构造方法new的一个对象。</p>
<p>  所以第二个问题答案是true，它们所引用的就是cache数组中的同一个地址；而第三个问题中的变量不在cache范围内，所以所执行的代码同第一个问题。</p>
<hr>
<h2 id="可变字符串"><a href="#可变字符串" class="headerlink" title="可变字符串"></a>可变字符串</h2><ul>
<li><strong>StringBuffer</strong>：可变长字符串，JDK1.0提供，运行效率慢、线程安全。</li>
<li><strong>StringBuilder</strong>：可变长字符串，JDK1.5提供，运行效率快、线程不安全。</li>
</ul>
<p>这两个类相当于String的增强类，事先开辟了一块缓冲区；这两个类的用法是一样的，效率都比String高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示StringBuilder常用方法的使用</span></span><br><span class="line"><span class="comment"> * 效率比String高；比String节省内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//1. append();追加</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;我&quot;</span>);<span class="comment">//我</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;菜&quot;</span>);<span class="comment">//我菜</span></span><br><span class="line">        <span class="comment">//2. insert();插入</span></span><br><span class="line">        stringBuilder.insert(<span class="number">0</span>, <span class="string">&quot;前&quot;</span>);<span class="comment">//前我菜</span></span><br><span class="line">        <span class="comment">//3. replace();替换</span></span><br><span class="line">        stringBuilder.replace(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;你&quot;</span>);<span class="comment">//前你菜</span></span><br><span class="line">        <span class="comment">//4. delete();删除</span></span><br><span class="line">        stringBuilder.delete(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//你菜</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>下面的输出结果是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> b1=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> b2=<span class="number">0.9</span>;</span><br><span class="line">System.out.print(b1-b2);</span><br></pre></td></tr></table></figure>

<p>正常的运算答案是0.1，而程序输出的结果是<code>0.0999...98</code>。因为浮点类型存储的实际是一个近似值，经过计算之后肯定会有误差，只不过这种误差很小。</p>
<p>很多实际应用中需要精确计算，用double肯定不符合要求，这时候需要借助BigDecimal类来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示BigDecimal类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        BigDecimal b2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        System.out.println(b1.subtract(b2));<span class="comment">//减法 0.1</span></span><br><span class="line">        System.out.println(b1.add(b2));<span class="comment">//加法 1.9</span></span><br><span class="line">        System.out.println(b1.multiply(b2));<span class="comment">//乘法 0.90    </span></span><br><span class="line">        System.out.println(b2.divide(b1));<span class="comment">//除法 0.9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到以上计算没有问题，但是要注意的是，如果除法的结果除不尽，那么就会报一个异常；所以在除法运算的时候需要使用divide的另外一个构造方法<code>divide(divisor, scale, roundingMode)</code>。</p>
<ul>
<li>参数divisor：除数</li>
<li>参数scale：指定精确到小数点后几位</li>
<li>参数roundingMode：<ul>
<li>指定小数部分的取舍模式，通常采用四舍五入的模式。</li>
<li>取值为<code>BigDecimal.ROUND_HALF_UP</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;10&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//3.33</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;20&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//6.67</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><ul>
<li>Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代（已过时）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Date类中尚未过时的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date d1=<span class="keyword">new</span> Date();</span><br><span class="line">        Date d2=<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//当前时间 Wed Nov 04 12:01:52 CST 2020</span></span><br><span class="line">        System.out.println(d1.toString());</span><br><span class="line">        <span class="comment">//已过时，打印当地时间</span></span><br><span class="line">        <span class="comment">//2020-11-4 12:01:52</span></span><br><span class="line">        System.out.println(d1.toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//after before判断两个时间前后关系</span></span><br><span class="line">        d2=<span class="keyword">new</span> Date(d1.getTime()-<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">1000</span>);<span class="comment">//昨天此刻</span></span><br><span class="line">        System.out.println(d1.after(d2));<span class="comment">//true 今天在昨天后面</span></span><br><span class="line">        System.out.println(d1.before(d2));<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//compareTo比较，两者毫秒数相减，返回正负0</span></span><br><span class="line">        System.out.println(d1.compareTo(d2));<span class="comment">//1</span></span><br><span class="line">        System.out.println(d2.compareTo(d1));<span class="comment">//-1</span></span><br><span class="line">        System.out.println(d1.compareTo(d1));<span class="comment">//0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//equals判断是否相等</span></span><br><span class="line">        System.out.println(d1.equals(d2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li><p><strong>Calendar提供了获取或设置各种日历字段的方法</strong>。</p>
</li>
<li><p><strong>构造方法</strong><code>protected Calendar()</code></p>
<p>由于修饰符是protected，所以无法直接创建该对象。</p>
</li>
</ul>
<p>其他方法：</p>
<ul>
<li><p><code>static Calendar getInstance()</code></p>
<p>使用默认时区和区域获取日历。</p>
</li>
<li><p><code>void set(int year,int month,int date,int hourOfDay,int minute,int second)</code></p>
<p>设置日历的年、月、日、时、分、秒。</p>
</li>
<li><p><code>int get(int field)</code></p>
<p>返回给定日历字段的值。字段比如年、月、日等。</p>
</li>
<li><p><code>void setTime(Date date)</code></p>
<p>用给定的Date设置次日历的时间。Date-&gt;Calendar</p>
</li>
<li><p><code>Date getTime()</code></p>
<p>返回一个Date表示此日历的时间。Calendar-&gt;Date</p>
</li>
<li><p><code>void add(int field,int amount)</code></p>
<p>按照日历的规则，给指定字段添加或减少时间量。</p>
</li>
<li><p><code>long getTimeMillies()</code></p>
<p>毫秒为单位返回该日历的时间值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Calendar类常用方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Calendar对象</span></span><br><span class="line">        Calendar calendar=Calendar.getInstance();</span><br><span class="line">        <span class="comment">//2020-11-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        <span class="comment">//1604469056368</span></span><br><span class="line">        System.out.println(calendar.getTimeInMillis());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取时间信息</span></span><br><span class="line">        <span class="comment">//年 2020</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        <span class="comment">//月 11 值为0-11</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//日 4</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="comment">//小时 1/13 12小时/24小时</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        <span class="comment">//分钟 50</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MINUTE));</span><br><span class="line">        <span class="comment">//秒 56</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.SECOND));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改时间</span></span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">//2019-11-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加或减少时间量</span></span><br><span class="line">        calendar.add(Calendar.MONTH, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2019-10-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取时间字段的最大值、最小值</span></span><br><span class="line">        <span class="comment">//31 / 1</span></span><br><span class="line">        System.out.println(calendar.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(calendar.getActualMinimum(Calendar.DAY_OF_MONTH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><ul>
<li><p><strong>SimpleDateFormat是一个以语言环境有关的方式来格式化和解析日期的具体类</strong>。</p>
</li>
<li><p><strong>可以进行格式化</strong>（<strong>日期到文本</strong>）<strong>和解析</strong>（<strong>文本和日期</strong>）。</p>
</li>
<li><p><strong>常用的时间模式字母</strong>：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>年中月份</td>
</tr>
<tr>
<td>d</td>
<td>月中天数</td>
</tr>
<tr>
<td>H</td>
<td>1天中小时数（0-23）</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Date对象</span></span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String string=simpleDateFormat.format(date);</span><br><span class="line">        <span class="comment">//2020/11/04 14:10:21</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解析（必须按照上面格式化的形式）</span></span><br><span class="line">        Date date2=simpleDateFormat.parse(<span class="string">&quot;1999/01/30 00:00:00&quot;</span>);</span><br><span class="line">        <span class="comment">//1999-1-30 0:00:00</span></span><br><span class="line">        System.out.println(date2.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li><p>系统类，主要用于获取系统的属性数据和其他操作，其构造方法是私有的。</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p><code>static void array(...)</code></p>
<p>复制数组</p>
</li>
<li><p><code>static long currentTimeMillis()</code></p>
<p>获取当前系统时间，返回的是毫秒值。通常用来计算某个操作的用时，操作前后各获取一个时间然后相减，所得的毫秒数就是用时。</p>
</li>
<li><p><code>static void gc()</code></p>
<p>建议JVM赶快启动垃圾回收器回收垃圾，具体是否调用是由系统决定的。</p>
</li>
<li><p><code>static void exit(int status)</code></p>
<p>退出JVM，如果参数是0表示正常退出JVM，非0表示异常退出JVM。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示array的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src= &#123;<span class="number">3</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">92</span>,<span class="number">65</span>,<span class="number">35</span>,<span class="number">85</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">int</span> srcPos=<span class="number">0</span>,destPos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=src.length;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * src:源数组</span></span><br><span class="line"><span class="comment">         * scrPos：复制的源数组起始位置</span></span><br><span class="line"><span class="comment">         * dest：目标数组</span></span><br><span class="line"><span class="comment">         * destPos：复制的目标数组起始位置</span></span><br><span class="line"><span class="comment">         * length：复制的数组长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.array(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Arrays类里也有一个Of复制数组的方法，这两个方法有什么区别呢？通过查看源码发现Arrays的这个方法内部调用的就是<code>System.array()</code>方法，而array方法的源码是被native修饰的本地方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到方法体是空的，它是一个原生函数，并不是由java来实现的，而是由c/c++来实现的，java只是调用了它，由c++实现的这个方法效率会比java快很多。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-反射</title>
    <url>/2021-01-JavaSE-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="类对象概述"><a href="#类对象概述" class="headerlink" title="类对象概述"></a>类对象概述</h2><ul>
<li><p>类的对象：基于某个类 new创建出来的对象，也称实例对象。</p>
</li>
<li><p><strong>类对象</strong>：<strong>类加载的产物</strong>，<strong>封装了一个类的所有信息</strong>（类名、父类、接口、属性、方法、构造方法）。</p>
<p>每个类加载到内存后都对应一个class对象，每个类有且仅有一个class对象。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//1.通过类的对象获取类对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class c1=p1.getClass();</span><br><span class="line">    System.out.println(c1);     <span class="comment">//class classObject.Person</span></span><br><span class="line">    System.out.println(c1.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">    <span class="comment">//2.通过类名获取类对象</span></span><br><span class="line">    Class&lt;Person&gt; c2=Person.class;</span><br><span class="line">    System.out.println(c2.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">    <span class="comment">//3.通过静态方法获取类对象 [推荐方式] 以上两种可能类不存在</span></span><br><span class="line">    Class c3=Class.forName(<span class="string">&quot;classObject.Person&quot;</span>);</span><br><span class="line">    System.out.println(c3.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1298420035</span></span><br><span class="line"><span class="number">1298420035</span></span><br><span class="line"><span class="number">1298420035</span></span><br></pre></td></tr></table></figure>

<p>这三个类的hashcode一样，说明这三个类对象是同一个，而且每个类加载到内存中只对应一个类对象。</p>
<p>在获取类对象时推荐使用第三种方式，前两种看上去很简单但是代码的依赖性太强，假如编译的时候没有Person这个类就会报错 ，而第三种的参数是一个字符串，编译的时候可以没有Person类，只要运行的时候有就行。</p>
<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>常用方法：</p>
<ul>
<li><p><code>public String getName()</code></p>
<p>获取类对象所代表的类的名字。</p>
</li>
<li><p><code>public Package getPackage()</code></p>
<p>获取类对象所代表的包的名字。</p>
</li>
<li><p><code>public Class&lt;? super T&gt; getSuperclass()</code></p>
<p>获取类对象所代表的类的父类。</p>
</li>
<li><p><code>public Class&lt;?&gt;[] getInterfaces()</code></p>
<p>获取类对象所代表的类或接口实现的接口。</p>
</li>
<li><p><code>public Constructors&lt;?&gt;[] getConstructors()</code></p>
<p>获取类对象所代表的类的所有公共构造方法。</p>
</li>
<li><p><code>public T newInstance()</code></p>
<p>创建类对象所代表的类一个新实例。</p>
</li>
<li><p><code>public Method[] getMethods()</code></p>
<p>获取类对象所代表的类或接口的公共成员方法。</p>
</li>
<li><p><code>public Field[] getFields()</code></p>
<p>获取类对象所代表的类或接口的公共访问字段。</p>
</li>
</ul>
<h3 id="获取类信息（名字、包名、父类、接口）"><a href="#获取类信息（名字、包名、父类、接口）" class="headerlink" title="获取类信息（名字、包名、父类、接口）"></a>获取类信息（名字<strong>、</strong>包名<strong>、</strong>父类<strong>、</strong>接口）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class classObject=Class.forName(<span class="string">&quot;reflect.classObject.Person&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfoFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"><span class="comment">//1.获取类信息</span></span><br><span class="line"><span class="comment">//1.2.获取类的名字</span></span><br><span class="line">System.out.println(classObject.getName());</span><br><span class="line"><span class="comment">//1.2.获取包的名字</span></span><br><span class="line">System.out.println(classObject.getPackage());</span><br><span class="line"><span class="comment">//1.3.获取类的父类</span></span><br><span class="line">System.out.println(classObject.getSuperclass());</span><br><span class="line"><span class="comment">//1.4.获取类的接口</span></span><br><span class="line">System.out.println(Arrays.toString(classObject.getInterfaces()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个方法返回的是一个数组，如果该对象表示了一个<strong>不实现</strong>任何接口的类，则返回一个<strong>数组长度为0</strong>的数组。运行结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">io.gitee.lazydog036.demo.Person</span><br><span class="line"><span class="keyword">package</span> io.gitee.lazydog036.demo</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h3 id="获取类的构造方法，并创建对象"><a href="#获取类的构造方法，并创建对象" class="headerlink" title="获取类的构造方法，并创建对象"></a>获取类的构造方法<strong>，</strong>并创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stu</span><span class="params">(<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习了&quot;</span>+day+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这一个私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">protectedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这个受保护的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这个默认权限方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了这个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConstructorFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获取构造方法</span></span><br><span class="line">    <span class="comment">//2.1获取类的所有构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[]cons=classObject.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; con : cons) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>+con.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2获取无参构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; con1=classObject.getConstructor();</span><br><span class="line">    System.out.println(con1.toString());</span><br><span class="line">    <span class="comment">//通过反射实例一个对象</span></span><br><span class="line">    <span class="comment">//类对象classObject通过获取到的Constructor使用newInstance实例一个对象</span></span><br><span class="line">    Person p1=(Person)con1.newInstance();  <span class="comment">//Constructor类中的newInstance</span></span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line">    <span class="comment">//2.2.1简便方法</span></span><br><span class="line">    Person p2=(Person)classObject.newInstance();<span class="comment">//Class类重写newInstance</span></span><br><span class="line">    System.out.println(p2.toString());</span><br><span class="line">    <span class="comment">//2.3获取有参构造</span></span><br><span class="line">    Constructor con2=classObject.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person zhangsan=(Person)con2.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">44</span>);</span><br><span class="line">    System.out.println(zhangsan.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getConstructor返回的是构造方法是一个Constructor对象，参数为构造方法声明的形参类型。使用带参构造方法对象创建实例时需要传递相应的参数，如代码中的第3个演示所示。运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造方法<span class="keyword">public</span> reflect.classObject.Person(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line">构造方法<span class="keyword">public</span> reflect.classObject.Person()</span><br><span class="line"><span class="keyword">public</span> reflect.classObject.Person()</span><br><span class="line">无参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">无参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">有参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">44</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类中的方法，并调用方法"><a href="#获取类中的方法，并调用方法" class="headerlink" title="获取类中的方法，并调用方法"></a>获取类中的方法<strong>，</strong>并调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMethodFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------公开的方法--------&quot;</span>);</span><br><span class="line">    <span class="comment">//3.获取类对象中所有的方法</span></span><br><span class="line">    <span class="comment">//3.1获取类中所有公开的（public）方法</span></span><br><span class="line">    Method[] methods=classObject.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----非公开的方法-----&quot;</span>);</span><br><span class="line">    <span class="comment">//3.2获取public以外权限的方法</span></span><br><span class="line">    Method[] declaredMethods=classObject.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(declaredMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.3获取单个方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取单个方法-----&quot;</span>);</span><br><span class="line">    Method stuMethod=classObject.getMethod(<span class="string">&quot;stu&quot;</span>);</span><br><span class="line">    Person wangwu=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    stuMethod.invoke(wangwu);</span><br><span class="line">    Method stuMethod2=classObject.getMethod(<span class="string">&quot;stu&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    Person zhaoliu=<span class="keyword">new</span> Person(<span class="string">&quot;赵六&quot;</span>,<span class="number">33</span>);</span><br><span class="line">    stuMethod2.invoke(zhaoliu,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//3.4获取单个非公开方法 需要设置访问权限</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取单个非公开方法-----&quot;</span>);</span><br><span class="line">    Method privateMethod=classObject.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">    privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    privateMethod.invoke(wangwu);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;---获取静态方法---&quot;</span>);</span><br><span class="line">    Method staticMethod=classObject.getMethod(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">    staticMethod.invoke(<span class="keyword">null</span>);    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是一个Method类型的数组。控制台输出如下，为了便于观察结果，我把结果在这里分成了两部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reflect.classObject.Person.staticMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> reflect.classObject.Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">-----非公开的方法-----</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> reflect.classObject.Person.privateMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reflect.classObject.Person.staticMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> reflect.classObject.Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> reflect.classObject.Person.protectedMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu()</span><br><span class="line"><span class="keyword">void</span> reflect.classObject.Person.defaultMethod()</span><br><span class="line">-----获取单个方法-----</span><br><span class="line">有参构造被调用了</span><br><span class="line">王五正在学习</span><br><span class="line">有参构造被调用了</span><br><span class="line">学习了<span class="number">10</span>天</span><br><span class="line">-----获取单个非公开方法-----</span><br><span class="line">王五执行了这一个私有方法</span><br><span class="line">---获取静态方法---</span><br><span class="line">执行了这个静态方法</span><br><span class="line">有参构造被调用了</span><br><span class="line">zhangsan执行了这一个私有方法</span><br><span class="line">&#123;张三=<span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong> </p>
<ul>
<li><p>getMethods 包含Person类的方法，也包含了继承自Object的方法；但是在Person的方法中，没有非public方法，也就是说，该方法获取了<strong>类中和继承自父类的公开方法</strong>。</p>
</li>
<li><p>getDeclaredMethods 包括了所有公有的，私有的，受保护的和默认的方法。</p>
</li>
<li><p>获得方法后使用<code>invoke(Object obj,Object... args)</code>来调用相应的方法，第一个参数是调用这个方法的对象，第二个参数是调用方法的形参列表，没有就不写。</p>
</li>
<li><p>获取私有方法时需要使用<code>getDeclaredMethod</code>，并且需要设置访问权限无效才能调用，不然私有方法是不允许在其他类中调用的。</p>
</li>
<li><p>调用静态方法时，invoke中调用方法的对象这个参数写null。</p>
</li>
</ul>
<h3 id="实现一个可以调用任何对象方法的通用方法"><a href="#实现一个可以调用任何对象方法的通用方法" class="headerlink" title="实现一个可以调用任何对象方法的通用方法"></a>实现一个可以调用任何对象方法的通用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeAll</span><span class="params">(Object obj,String methodName,Class&lt;?&gt;[]types,Object... args)</span> <span class="keyword">throws</span>  NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class classObject=obj.getClass();</span><br><span class="line">    Method method;</span><br><span class="line">    Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method=classObject.getMethod(methodName,types);  <span class="comment">//判断这条语句是否发生异常</span></span><br><span class="line">        o=method.invoke(obj,args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;    <span class="comment">//如果是找不到方法异常，就执行以下语句</span></span><br><span class="line">        method=classObject.getDeclaredMethod(methodName,types);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        o=method.invoke(obj,args);</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取类中的属性"><a href="#获取类中的属性" class="headerlink" title="获取类中的属性"></a>获取类中的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFieldFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取所有公开属性----&quot;</span>);</span><br><span class="line">        Field[] fields1=classObject.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取所有私有属性----&quot;</span>);</span><br><span class="line">        Field[] fields2=classObject.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取单个属性----&quot;</span>);</span><br><span class="line">        Field nameField=classObject.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(nameField);</span><br><span class="line">        <span class="comment">//set get属性</span></span><br><span class="line">        Person chenqi=(Person)classObject.newInstance();</span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>); <span class="comment">//属性为私有的 设置公开权限</span></span><br><span class="line">        nameField.set(chenqi,<span class="string">&quot;周八&quot;</span>);</span><br><span class="line">        System.out.println(nameField.get(chenqi));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------获取所有属性----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> reflect.classObject.Person.count</span><br><span class="line">------获取所有私有属性----</span><br><span class="line"><span class="keyword">private</span> java.lang.String reflect.classObject.Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> reflect.classObject.Person.age</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> reflect.classObject.Person.count</span><br><span class="line">------获取单个属性----</span><br><span class="line"><span class="keyword">private</span> java.lang.String reflect.classObject.Person.name</span><br><span class="line">无参构造被调用了</span><br><span class="line">周八</span><br></pre></td></tr></table></figure>

<h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ul>
<li><p><strong>什么是设计模式</strong>？</p>
<p>一套被反复使用、多数人知晓的、经过分类编目、代码设计经验的总结。简单理解：特定问题的固定解决方法。</p>
</li>
<li><p><strong>好处</strong>？</p>
<p>使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性、重用性。</p>
</li>
<li><p>在Gof的《设计模式》书中描述了23中设计模式。本文只介绍几种常见的。</p>
</li>
</ul>
<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><ul>
<li>工厂模式主要负责对象创建的问题。</li>
<li>开发中有一个非常重要的原则“开闭原则”，对拓展开放、对修改关闭。</li>
<li>可通过反射进行工厂模式的设计，完成动态的对象创建。</li>
</ul>
<p>工厂模式一般有父类产品、子类产品、工厂和客户。以下演示工厂模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 父类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyBoard</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upan</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;u盘开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂类（负责对象创建）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Usb <span class="title">createUsb</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        Usb usb=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type==<span class="number">1</span>) &#123;<span class="comment">//鼠标</span></span><br><span class="line">            usb=<span class="keyword">new</span> Mouse();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;<span class="comment">//键盘</span></span><br><span class="line">            usb=<span class="keyword">new</span> KeyBoard();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type==<span class="number">3</span>) &#123;<span class="comment">//U盘</span></span><br><span class="line">            usb=<span class="keyword">new</span> Upan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> usb;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择产品：1.鼠标 2.键盘 3.U盘&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> type=in.nextInt();</span><br><span class="line">        Usb usb=UsbFactory.createUsb(type);</span><br><span class="line">        <span class="keyword">if</span>(usb!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购买成功。&quot;</span>);</span><br><span class="line">            usb.service();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请选择产品：1.鼠标 2.键盘 3.U盘</span><br><span class="line">2</span><br><span class="line">购买成功。</span><br><span class="line">键盘开始工作。。</span><br></pre></td></tr></table></figure>

<p>如果新增了一个产品，比如画板，那么需要新建一个子类产品类，然后在工厂类的if语句中加一个type，在new一个画板类。这么做就破坏了“开闭原则”，修改了源代码。接下来使用反射来优化这个程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂类（负责对象创建）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Usb <span class="title">createUsb</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Usb usb=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; class1=Class.forName(type);</span><br><span class="line">            usb=(Usb) class1.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> usb;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在工厂类利用反射创建新实例，传递过来的就需要一个完整的“包名.类名”。</p>
<p>但是客户还是输入数字来选择购买哪个产品，我们可以用Properties类来将<strong>客户的选择</strong>和“<strong>包名.类名</strong>”存储为键值对，并将它放在单独的配置文件中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##Usb.properties</span></span><br><span class="line"><span class="attr">1</span> = <span class="string">io.gitee.lazydog036.pattern.Mouse</span></span><br><span class="line"><span class="attr">2</span> = <span class="string">io.gitee.lazydog036.pattern.KeyBoard</span></span><br><span class="line"><span class="attr">3</span> = <span class="string">io.gitee.lazydog036.pattern.Upan</span></span><br></pre></td></tr></table></figure>

<p>那么就相应地修改客户代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请选择产品：1.鼠标 2.键盘 3.U盘 4.画板&quot;</span>);</span><br><span class="line">    Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String choice=in.next();</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//将文件读入到流中</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\Usb.properties&quot;</span>);</span><br><span class="line">    <span class="comment">//从流中加载数据</span></span><br><span class="line">    properties.load(fileInputStream);</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    Usb usb=UsbFactory.createUsb(properties.getProperty(choice));</span><br><span class="line">    <span class="keyword">if</span>(usb!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购买成功。&quot;</span>);</span><br><span class="line">        usb.service();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;产品不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Properties这个集合和IO框架的知识默认你已经知晓了，我的其他博客里也有总结。</p>
<p>执行代码，程序正常运行。还是刚才那个问题，这时候新加了一个产品画板，我们之前需要修改工厂类的代码，而现在我们只需要在<code>Usb.properties</code>文件中新加一行代码：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">4</span> = <span class="string">io.gitee.lazydog036.pattern.DrawingBoard</span></span><br></pre></td></tr></table></figure>

<p>不用去修改源代码，再新添加一个DrawingBoard类，然后执行代码，运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请选择产品：<span class="number">1.</span>鼠标 <span class="number">2.</span>键盘 <span class="number">3.</span>U盘</span><br><span class="line"><span class="number">4</span></span><br><span class="line">购买成功。</span><br><span class="line">画板开始工作。</span><br></pre></td></tr></table></figure>

<p>输入4，正常输出结果，符合了“开闭原则”。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li><p>单例（Singleton）：约束类只能创建一个该类的对象。</p>
<p>要保证整个系统在运行过程中只能创建一个对象，有两种方式：</p>
<ul>
<li><strong>方式1</strong>：<strong>饿汉式</strong>（<strong>类加载时创建</strong>，<strong>天生线程安全</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例模式-饿汉  在类初始化即实例化instanc</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 instance=<span class="keyword">new</span> Singleton1();  <span class="comment">//1.创建一个等于该类的常量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">//设置无参构造方法为私有 让外部类无法new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance1</span><span class="params">()</span> </span>&#123;  <span class="comment">//提供公开的静态方法返回常量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="comment">//return instance;   不等于return new Singleton1();  常量值不会改变，new会改变对象地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饿汉-变种</span></span><br><span class="line">    <span class="comment">//静态的概念：在全类中只有一份，不因创建多个对象而产生多份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance1=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是单列-饿汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式单例一共三个步骤，很简单：</p>
<ol>
<li>首先创建一个该类的常量对象。</li>
<li>构造方法设置为私有，类外部不能创建该对象。</li>
<li>通过一个公开的方法，返回这个对象。</li>
</ol>
<p>通过一个多线程的代码来测试其是否是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="comment">//饿汉</span></span><br><span class="line">                    System.out.println(Singleton1.getInstance1().hashCode());</span><br><span class="line">                    Singleton1 instance=Singleton1.getInstance1();</span><br><span class="line">                    <span class="comment">//instance.show();</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">                    System.out.println(Singleton1.getInstance2().hashCode());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于java多线程默认你已经有所了解，我的其他博客中总结得也很详细。</p>
<p>运行结果如下，三个对象的hashcode一样，说明三个线程获取的是同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1307179676</span><br><span class="line">1307179676</span><br><span class="line">1307179676</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式2</strong>：<strong>懒汉式</strong>（<strong>使用时创建</strong>，<strong>线程不安全</strong>，<strong>需要加同步</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例模式-懒汉 （线程不安全） 调用getInstance方法时才创建对象，比饿汉式节省空间</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//设置无参构造方法为私有 让外部类无法new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  <span class="comment">//线程不安全，下面提供三种方式保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比饿汉式先创建一个对象而言，懒汉式只有在调用方法时才创建对象，比饿汉式节省空间。</p>
<p>懒汉式单例同样是三个步骤：</p>
<ol>
<li>首先创造一个对象，赋值为null。</li>
<li>构造方法改成私有，类外部不能创建对象。</li>
<li>通过一个公开的方法，返回这个对象。</li>
</ol>
<p>通过一个多线程的代码来测试其是否是线程安全的，测试代码同上，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">727916939</span><br><span class="line">1612280362</span><br><span class="line">727916939</span><br></pre></td></tr></table></figure>

<p>hashcode不一样，说明在多线程中创建了不同的对象。怎么解决呢？很容易想到的是使用同步方法，或者是使用同步代码块，在方法名前加一个synchronized关键字，或者把需要同步的代码放进同步代码块中：</p>
<ul>
<li>保证线程安全的三种方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：在方法名中加synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程比较多的情况下，每个线程在使用实例时，如果都需要判断是否上锁的话执行效率会大打折扣；其实当第一个线程进入到同步代码块中时就说明实例已经创建了，后来的其他线程执行的只是返回语句，所以可以让后来的线程绕过同步代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二：加synchronized代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//括号里不能是instance，因为前面赋值是null，会出现空指针异常</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同步代码块中再加一个if判断，就可以让后来的线程直接执行下面的返回语句，而不必再去判断是否上锁。这样可以优化执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态的概念：在全类中只有一份，不因创建多个对象而产生多份</span></span><br><span class="line"><span class="comment">// 方式三：创建静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Holder.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它跟饿汉不同的是（很细微的差别）：饿汉是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。</p>
</li>
<li><p>总结单例模式的两种写法的优缺点：</p>
<p>饿汉式：</p>
<ul>
<li>优点：线程安全，类一加载就创建了实例。</li>
<li>缺点：实例对象就算不用也存在于内存中，生命周期长，浪费空间。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>优点：只有在调用getInstance才会实例化，生命周期短，节省空间</li>
<li>缺点：线程不安全。不过可以使用同步来保证线程互斥访问。</li>
</ul>
</li>
</ul>
<h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><h3 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h3><ul>
<li>枚举是一个引用类型，枚举是一个规定了取值范围的数据类型。反映到现实生活中，比如性别就是男和女，一个星期就是从周一到周日等。</li>
<li>枚举变量不能使用其他的数据，只能使用枚举中常量赋值，提高程序安全性。</li>
<li>定义枚举使用enum关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建枚举类</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">    MALE,FMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类中必须包含枚举常量，如上段中的MALE，多个枚举常量之间使用逗号隔开，如果类中只有枚举常量末尾可以不加分号。</p>
<p>枚举类中还可以包含属性，方法，<strong>私有</strong>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Gender &#123;</span><br><span class="line">    MALE,FMALE;    </span><br><span class="line">    public int a;</span><br><span class="line">    private String bString;</span><br><span class="line">    static HashMap&lt;Integer, String&gt; hashMap;</span><br><span class="line">    &#x2F;&#x2F;构造方法必须私有</span><br><span class="line">    private Gender() &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">    public static void show() &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示枚举类的使用，结果输出FMALE：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testGender</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法私有，不能使用new来创建</span></span><br><span class="line">        <span class="comment">//所有引用EnumDemo.FMALE的对象都是一个对象</span></span><br><span class="line">        EnumDemo enumTest1=EnumDemo.FMALE;</span><br><span class="line">        System.out.println(enumTest1);</span><br><span class="line">        EnumDemo enumTest2=EnumDemo.FMALE;</span><br><span class="line">        EnumDemo enumTest3=EnumDemo.FMALE;</span><br><span class="line">        System.out.println(enumTest1.hashCode());</span><br><span class="line">        System.out.println(enumTest2.hashCode());</span><br><span class="line">        System.out.println(enumTest3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FMALE</span><br><span class="line">1908153060</span><br><span class="line">1908153060</span><br><span class="line">1908153060</span><br></pre></td></tr></table></figure>



<h3 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h3><p>在创建枚举类的时候，注意到这个类和以前接触过的类不太一样，枚举常量没有任何修饰关键字，那它是一个怎么的存在？</p>
<p>找到编译生成的<code>Gender.class</code>文件，借助Xjad小工具将其反编译成java代码，这个小工具在百度上可以找到，得到以下的反编译结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Gender extends Enum</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static final Gender MALE;</span><br><span class="line">    public static final Gender FMALE;</span><br><span class="line">    private static final Gender ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    private Gender(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Gender[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Gender agender[];</span><br><span class="line">        int i;</span><br><span class="line">        Gender agender1[];</span><br><span class="line">        System.array(agender &#x3D; ENUM$VALUES, 0, agender1 &#x3D; new Gender[i &#x3D; agender.length], 0, i);</span><br><span class="line">        return agender1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Gender valueOf(String s)</span><br><span class="line">    &#123;</span><br><span class="line">        return (Gender)Enum.valueOf(io&#x2F;gitee&#x2F;lazydog036&#x2F;meiJu&#x2F;Gender, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        MALE &#x3D; new Gender(&quot;MALE&quot;, 0);</span><br><span class="line">        FMALE &#x3D; new Gender(&quot;FMALE&quot;, 1);</span><br><span class="line">        ENUM$VALUES &#x3D; (new Gender[] &#123;</span><br><span class="line">            MALE, FMALE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Gender类变成了final修饰的终止类，意味着这个类没有子类，而且它继承了Enum抽象类。Enum是jdk1.5之后新增的一个类，实际上我们所创建的枚举类都隐式地继承了Enum类。而FMALE和MALE都变成了用该类所创建的静态的终止的属性，尽管我们只写了常量名。</p>
<p>还可以看到java编译时还添加了一个带参的私有构造方法和两个静态方法。还有一个静态代码块，在其中对这些静态常量进行了赋值。</p>
<p>所以枚举的本质就是：</p>
<ul>
<li>一个终止类，并继承Enum抽象类。</li>
<li>枚举常量是当前类型的静态常量。</li>
</ul>
<h3 id="枚举配合switch"><a href="#枚举配合switch" class="headerlink" title="枚举配合switch"></a>枚举配合switch</h3><p>在switch语句中，括号里的内容也可以是枚举类型的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Gender gender&#x3D;Gender.FMALE;</span><br><span class="line">    switch(gender) &#123;</span><br><span class="line">        case FMALE:</span><br><span class="line">            System.out.println(&quot;女性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case MALE:</span><br><span class="line">            System.out.println(&quot;男性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case后面直接写枚举常量。结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">女性</span><br></pre></td></tr></table></figure>

<h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li><p>注解（Annotation）是代码里的特殊标记，程序可以读取注解，一般用于替代配置文件。</p>
</li>
<li><p>开发人员可以通过注解告诉类如何运行。</p>
<p>在JAVA技术里注解的典型应用是：可以通过反射技术得到类里面的注解，以决定怎么去运行类。</p>
</li>
<li><p>常见注解：<code>@Override</code>表示重写父类方法，<code>@Deprecated</code>表示方法已过时。</p>
</li>
<li><p>定义注解使用<code>@interface</code>关键字，注解中只能包含属性。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建注解类型</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    &#x2F;&#x2F;属性，无默认值</span><br><span class="line">    String nameString();</span><br><span class="line">    &#x2F;&#x2F;有默认值</span><br><span class="line">    int age() default 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解类型的属性与其他类有所不同，它需要在属性名后面加一个括号，但不叫方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注解的使用</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @MyAnnotation(nameString &#x3D; &quot;张三&quot;)</span><br><span class="line">    public void show() &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解时直接添加到方法上面，也可以添加到类上面；如果属性没有默认值的话，需要在注解名括号里写上。</p>
<ul>
<li><p>注解基本类型</p>
<ul>
<li>String类型</li>
<li>基本数据类型</li>
<li>Class类型</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>以上类型的一维数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    &#x2F;&#x2F;String类型</span><br><span class="line">    String nameString();</span><br><span class="line">    &#x2F;&#x2F;基本类型</span><br><span class="line">    int age() default 18;</span><br><span class="line">    &#x2F;&#x2F;Class类型</span><br><span class="line">    Class&lt;?&gt; class1();</span><br><span class="line">    &#x2F;&#x2F;枚举类型</span><br><span class="line">    Gender gender();</span><br><span class="line">    &#x2F;&#x2F;不允许</span><br><span class="line">    &#x2F;&#x2F;ArrayList&lt;String&gt; arrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><p>同上使用Xjad工具反编译生成的<code>MyAnnotation.class</code>文件，得到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MyAnnotation</span><br><span class="line">    extends Annotation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public abstract String nameString();</span><br><span class="line"></span><br><span class="line">    public abstract int age();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到注解类已经变成了一个接口，而在注解类中定义的两个属性也变成了两个抽象方法。</p>
<p>所以注解的本质其实就是<strong>接口</strong>。</p>
<h3 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解类</span></span><br><span class="line"><span class="meta">@Retention(value=RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PersionInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="function">String <span class="title">hobby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHobby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobby</span><span class="params">(String hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobby=hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name, <span class="keyword">int</span> age, String hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.hobby=hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PersionInfo(name=&quot;张三&quot;,age=20,hobby=&quot;足球&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name,<span class="keyword">int</span> age,String hobby)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot; 年龄：&quot;</span>+age+<span class="string">&quot; 爱好：&quot;</span>+hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPersionInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; classObject=Class.forName(<span class="string">&quot;reflect.singletonDesignPattern.annotationDemo.Persion&quot;</span>);</span><br><span class="line">        <span class="comment">//获取类方法</span></span><br><span class="line">        Method method=classObject.getMethod(<span class="string">&quot;show&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class, String.class&#125;);</span><br><span class="line">        Constructor constructor=classObject.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class, String.class&#125;);</span><br><span class="line">        <span class="comment">//获取方法注解</span></span><br><span class="line">        PersionInfo annotation=method.getAnnotation(PersionInfo.class);</span><br><span class="line">        <span class="comment">//打印方法注解</span></span><br><span class="line">        System.out.println(annotation.name()+annotation.age()+annotation.hobby());</span><br><span class="line">        <span class="comment">//通过类对象创建实例p1</span></span><br><span class="line">        Persion p1=(Persion) classObject.newInstance();</span><br><span class="line">        <span class="comment">//执行方法(参数1=执行者)</span></span><br><span class="line">        method.invoke(p1,annotation.name(),annotation.age(),annotation.hobby());</span><br><span class="line">        <span class="comment">//通过有参构造方法实例对象</span></span><br><span class="line">        Persion p2=(Persion) constructor.newInstance(annotation.name(), annotation.age(), annotation.hobby());</span><br><span class="line">        System.out.println(p2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，看是否打印成功，得到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at io.gitee.lazydog036.annotation.testPersonInfo.main(testPersonInfo.java:14)</span><br></pre></td></tr></table></figure>

<p>发现报了一个空指针异常的错误，这个错误的原因就在于personInfo的值为null。第3步不是已经赋值了吗，为什么还是null？这是因为这个注解信息在运行的时候就没有了，PersonInfo注释类的类名上有一个默认的<strong>元注解</strong><code>@RetentionPolicy.CLASS</code>，使它只作用于编译后的class文件中。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解：用来描述注解的注解。</p>
<p><code>@Retention</code>：用于指定注解可以保留的域。</p>
<ul>
<li><code>@RetentionPolicy.CLASS</code>：注解记录在class文件中，运行Java程序时，JVM不会保留。这是注解的<strong>默认值</strong>。</li>
<li><code>@RetentionPolicy.RUNTIME</code>：注解记录在class文件中，运行Java程序中，JVM会保留注解，程序可以通过反射获取该注释。</li>
<li><code>@RetentionPolicy.SOURCE</code>：编译时直接丢弃这种策略的注释。</li>
</ul>
<p>解决上一节的问题，只需要在注解类上加一个元注解即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(value &#x3D; RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PersonInfo &#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意括号里的属性为value。然后再运行一下程序，控制台成功打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tang  21  足球</span><br></pre></td></tr></table></figure>

<p>我们也可以将注解里的属性值传入show方法中并进行调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5.调用方法</span><br><span class="line">Person person&#x3D;(Person) class1.newInstance();</span><br><span class="line">method.invoke(person, personInfo.name(),personInfo.age(),personInfo.hobby());</span><br></pre></td></tr></table></figure>

<p>输出结果如下，方法成功调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名：tang 年龄：21 爱好：足球</span><br></pre></td></tr></table></figure>

<hr>
<p><code>@Target</code>：元注解，指定注解用于修饰类的哪个成员。</p>
<p>上文演示的代码中PersonInfo注解是放在show方法上的，也可以说修饰了这个方法。在不加这个元注解的时候，注解可以修饰在任何地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(value &#x3D; RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; ElementType.TYPE &#125;)</span><br><span class="line">public @interface PersonInfo &#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Target</code>有一个枚举数组ElementType类型的value属性，在赋值的时候需要使用大括号括起来。这个枚举数组中有不同的枚举常量，如上的元注解表示该注解只能放在类上，比如放在show方法上编译器就会报错；如果枚举常量为METHOD，就表示该注解只能放在方法上。</p>
<p>ElementType枚举类型的源码如下（JDK1.8）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    &#x2F;** Class, interface (including annotation type), or enum declaration *&#x2F;</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Field declaration (includes enum constants) *&#x2F;</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Method declaration *&#x2F;</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Formal parameter declaration *&#x2F;</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Constructor declaration *&#x2F;</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Local variable declaration *&#x2F;</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Annotation type declaration *&#x2F;</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Package declaration *&#x2F;</span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据程序可以自己选择枚举常量，也可以不写这个元注解，就表示注解可以加在任何地方。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-集合框架</title>
    <url>/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul>
<li><p><strong>概念:</strong> 对象的容器，实现了对象常用的操作，类似与数组的功能</p>
</li>
<li><p><strong>集合与数组的区别</strong></p>
<ol>
<li>数组的长度是固定的，集合长度不固定</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>
</ol>
</li>
</ul>
<span id="more"></span>
<h2 id="Collection体系"><a href="#Collection体系" class="headerlink" title="Collection体系"></a>Collection体系</h2><ul>
<li>Collection:  <ul>
<li>List:</li>
<li>ArrayList  <ul>
<li>LinkedList  </li>
<li>Vector  </li>
</ul>
</li>
<li>Set:<ul>
<li>HashSet  </li>
<li>SortedSet<ul>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><p><strong>特点：</strong> 代表一组任意类型的对象、无序、无下标、元素不能重复</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>boolean add(Object obj) //添加一个对象。</li>
<li>boolean addAll(Collection c) //将一个集合中的所有对象添加到此集合</li>
<li>void clear() //清空此集合中的所有对象</li>
<li>boolean contains(Object o)//检查此集合中是否包含o对象</li>
<li>boolean equals(Object o)//比较此集合是否与指定对象相等</li>
<li>boolean isEmpty()//判断此集合是否为空</li>
<li>boolean remove(Object o)//在此集合 中移除o对象</li>
<li>int size()//返回此集合中的元素个数</li>
<li>Object[] toArray() //将此集合转换成数组。</li>
</ul>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> conllection.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Collection接口使用一</span></span><br><span class="line"><span class="comment">* 1.添加元素</span></span><br><span class="line"><span class="comment">* 2.删除元素</span></span><br><span class="line"><span class="comment">* 3.遍历元素</span></span><br><span class="line"><span class="comment">* 4.判断</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        Collection collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        collection.remove(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//3.遍历元素</span></span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj:collection) &#123;</span><br><span class="line">            System.out.println(obj.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用迭代器</span></span><br><span class="line">        <span class="comment">//hasnext();判断是否有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除下一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        Iterator iterator = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//删除操作</span></span><br><span class="line">            <span class="comment">//collection.remove(s);引发错误：并发修改异常</span></span><br><span class="line">            <span class="comment">//iterator.remove();应使用迭代器的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;被迭代器删除后 集合没有元素了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;橘子&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(collection.isEmpty());<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><ul>
<li><strong>特点：</strong> 有序、有下标、元素可以重复</li>
<li><strong>常用方法：</strong><ul>
<li>void add(int index,Object o) //在index位置插入对象o。</li>
<li>boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</li>
<li>Object get(int index) //返回集合中指定位置的元素。</li>
<li>List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。</li>
</ul>
</li>
</ul>
<h3 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a>List实现类</h3><h4 id="ArrayList【重点】"><a href="#ArrayList【重点】" class="headerlink" title="ArrayList【重点】"></a>ArrayList【重点】</h4><ul>
<li>数组结构实现，查询快，增删慢；</li>
<li>JDK1.2版本开始使用，运行效率快，线程不安全(处理方法：迭代器-快速失败)。</li>
<li>有下标，允许重复</li>
</ul>
<p>代码实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        Stu s1=<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Stu s2=<span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Stu s3=<span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        arrayList.add(s1);</span><br><span class="line">        arrayList.add(s2);</span><br><span class="line">        arrayList.add(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+arrayList.size());</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//arrayList.remove(s1);</span></span><br><span class="line">        <span class="comment">//arrayList.remove(new Stu(&quot;张三&quot;, 21));</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;删除后元素个数：&quot;+arrayList.size());</span></span><br><span class="line">        <span class="comment">//注：如何删除两个不同的对象 ，见下面代码块</span></span><br><span class="line">        <span class="comment">//3.遍历元素</span></span><br><span class="line">        <span class="comment">//3.1使用迭代器</span></span><br><span class="line">        Iterator iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用列表迭代器</span></span><br><span class="line">        ListIterator listIterator=arrayList.listIterator();</span><br><span class="line">        <span class="comment">//从前往后遍历</span></span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(listIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(arrayList.isEmpty());<span class="comment">//是否为空</span></span><br><span class="line">        System.out.println(arrayList.contains(s1));<span class="comment">//是否存在</span></span><br><span class="line">        <span class="comment">//System.out.println(arrayList.contains(new Stu(&quot;张三&quot;, 21)));</span></span><br><span class="line">        <span class="comment">//注：与上文相同的问题。</span></span><br><span class="line">        <span class="comment">//5.查找</span></span><br><span class="line">        System.out.println(arrayList.indexOf(s1)));<span class="comment">//返回下标 不存在返回-1</span></span><br><span class="line">        <span class="comment">//System.out.println(arrayList.indexOf(new Stu(&quot;张三&quot;, 21)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实体Stu类中 重写equals()方法 比较是否同一对象、是否为空、是否同类型、属性是否相等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.是否为同一对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>==obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (obj==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断是否是Student类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Stu) &#123;</span><br><span class="line">        Stu stu=(Stu) obj;</span><br><span class="line">        <span class="comment">//4.比较属性</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(stu.getName())&amp;&amp;<span class="keyword">this</span>.age==stu.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不满足，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArraryList源码解析"><a href="#ArraryList源码解析" class="headerlink" title="ArraryList源码解析"></a>ArraryList源码解析</h4><h5 id="详解add方法原理"><a href="#详解add方法原理" class="headerlink" title="详解add方法原理"></a>详解add方法原理</h5><p>属性：<br>  DEFAULT_CAPACITY = 10    //默认容量（无参时用到，后面按1.5倍扩容）<br>  DEFAULTCAPACITY_EMPTY_ELEMENTDATA    //默认空数据数组(无参时用到)<br>  EMPTY_ELEMENTDATA    //空数组(有参 参数为0时用到)<br>  elementData    //存放数据的数组<br>  size   //原数组大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//第一次add时 size=0    //第十一次 size=10</span></span><br><span class="line">    elementData[size++] = e;  <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;   <span class="comment">//minCapacity=1      minCapacity=11</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  <span class="comment">//判断是否使用的是无参构造</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);   <span class="comment">//成立返回DEFAULT_CAPACITY=10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">//minCapacity=10  minCapacity=11</span></span><br><span class="line">    modCount++;                                     <span class="comment">//见下面Iterator快速失败原理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)       <span class="comment">//elementData.length=0   elementData.length=10</span></span><br><span class="line">        grow(minCapacity);                          <span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length; </span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">//newCapacity=0    newCapacity=15  扩容1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;                       <span class="comment">//newCapacity=10</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.Of(elementData, newCapacity); <span class="comment">//元素数据 容量为10的新数组  容量为15的新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayList不支持并发抛出的异常-java-util-ConcurrentModificationException"><a href="#ArrayList不支持并发抛出的异常-java-util-ConcurrentModificationException" class="headerlink" title="ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException"></a><div id="failfast">ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException</div></h5><p>Iterator快速失败原理 迭代器中为什么不能使用列表的操作方法</p>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="number">1</span>);</span><br><span class="line">    arrayList.add(<span class="number">2</span>);</span><br><span class="line">    arrayList.add(<span class="number">3</span>);</span><br><span class="line">    Iterator iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="keyword">int</span> num= (<span class="keyword">int</span>) iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">2</span>)&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arrayList.remove(1);  //会抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码解析</p>
<p>属性：<br>    expectedModCount  //预期操作次数<br>    modCount  //操作次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractList</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArraryList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;  </span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)               <span class="comment">//再次判断中途是否操作了列表</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)                   <span class="comment">//ArrayList操作函数中都写入了 modCount++  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iterator和ListIterator"><a href="#Iterator和ListIterator" class="headerlink" title="Iterator和ListIterator"></a>Iterator和ListIterator</h4><h5 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h5><p>我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p>
<ol>
<li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
</ol>
<p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p>
<h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。</p>
<ul>
<li><p>常用方法：</p>
<ul>
<li>forEachRemaining(Consumer&lt;? super E&gt; action)：为每个剩余元素执行给定的操作,直到所有的元素都已经被处理或行动将抛出一个异常</li>
<li>hasNext()：如果迭代器中还有元素，则返回true。</li>
<li>next()：返回迭代器中的下一个元素</li>
<li>remove()：删除迭代器新返回的元素。</li>
</ul>
</li>
<li><p>注意：</p>
<ol>
<li>Iterator只能单向移动。</li>
<li>Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。详见<a href="#failfast">ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException</a></li>
</ol>
</li>
</ul>
<p><a href="#failfast">Iterator代码实例</a></p>
<h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p>
<ul>
<li><p>ListIterator特点:</p>
<ol>
<li>双向移动（向前/向后遍历）.</li>
<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.</li>
<li>可以使用set()方法替换它访问过的最后一个元素.</li>
<li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</li>
</ol>
</li>
<li><p>注意：使用反向列表迭代前必须使用正向列表迭代</p>
</li>
</ul>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI0MTM5Ny9hcnRpY2xlL2RldGFpbHMvNzk2ODc3ODk=">https://blog.csdn.net/weixin_39241397/article/details/79687789<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>问题</strong><br>由于一次大意 在反向列表迭代中使用了nextIndex获取下标，发现下标不对，其中原因如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Stu s1 = <span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">Stu s2 = <span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Stu s3 = <span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">linkedList.add(s1);</span><br><span class="line">linkedList.add(s2);</span><br><span class="line">linkedList.add(s3);</span><br><span class="line"></span><br><span class="line">ListIterator listIterator = linkedList.listIterator();</span><br><span class="line"><span class="comment">//使用正向列表迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---------使用列表迭代器---------&quot;</span>);</span><br><span class="line">ListIterator listIterator = linkedList.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//因为还位执行.next()，游标指向在列表后(并没有指向第一个元素)， 所以当前下标-1 ，nextIndex为0，previousIndex为-1</span></span><br><span class="line">    <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">    <span class="comment">//在正向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的开头，则返回-1）</span></span><br><span class="line">    <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">    <span class="comment">//每次执行next()后 游标向前移一位  下标递减</span></span><br><span class="line">    Stu stu = (Stu) listIterator.next();</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.5 使用反向列表迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---------使用反向列表迭代器---------&quot;</span>);</span><br><span class="line">LinkedList stuLinkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">ArrayList stuArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">    <span class="comment">//因为还位执行previous()，光标指向在列表前(并没有指向最后一个元素)， 所以当前下标3 ，previousIndex为2，nextIndex为3(列表)</span></span><br><span class="line">    <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">    <span class="comment">//在反向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的末尾，则返回列表大小）</span></span><br><span class="line">    <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">    <span class="comment">//每次执行previous()后 游标向后移一位  下标递减</span></span><br><span class="line">    Stu stu = (Stu) listIterator.previous();</span><br><span class="line">    <span class="comment">//存进新的集合 完成集合反向排序</span></span><br><span class="line">    stuLinkedList.add(stu);</span><br><span class="line">    stuArrayList.add(stu);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li>数组结构实现，查询快、增删慢；</li>
<li>JDK1.0版本，运行效率慢、线程安全。</li>
<li>有下标，允许重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector的演示使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *1.添加数据</span></span><br><span class="line"><span class="comment"> *2.删除数据</span></span><br><span class="line"><span class="comment"> *3.遍历</span></span><br><span class="line"><span class="comment"> *4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Vector vector=<span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="comment">//1.添加数据</span></span><br><span class="line">    vector.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    vector.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    vector.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素个数：&quot;</span>+vector.size());</span><br><span class="line">    <span class="comment">//2.删除数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * vector.remove(0);</span></span><br><span class="line"><span class="comment">        * vector.remove(&quot;张三&quot;);</span></span><br><span class="line"><span class="comment">        * vector.clear();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//使用枚举器 于迭代器功能相同</span></span><br><span class="line">    Enumeration enumeration=vector.elements();</span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">        String s = (String) enumeration.nextElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(vector.isEmpty());</span><br><span class="line">    System.out.println(vector.contains(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="comment">//5. Vector其他方法</span></span><br><span class="line">    <span class="comment">//firstElement()  lastElement()  ElementAt();</span></span><br><span class="line">    System.out.println(vector.elementAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>链表结构实现，增删快，查询慢。</li>
<li>无下标，允许重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stu s1 = <span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    Stu s2 = <span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Stu s3 = <span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//1.添加元素</span></span><br><span class="line">    linkedList.add(s1);</span><br><span class="line">    linkedList.add(s2);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素个数：&quot;</span> + linkedList.size());</span><br><span class="line">    System.out.println(linkedList.toString());</span><br><span class="line">    <span class="comment">//2.删除元素</span></span><br><span class="line">    <span class="comment">//linkedList.remove(1);</span></span><br><span class="line">    <span class="comment">//linkedList.remove(new Stu(&quot;张三&quot;, 21));</span></span><br><span class="line">    <span class="comment">//System.out.println(linkedList.toString());</span></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//3.1 使用for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用for---------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); ++i) &#123;</span><br><span class="line">        System.out.println(linkedList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 使用增强for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用foreach---------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object object : linkedList) &#123;</span><br><span class="line">        Stu student = (Stu) object;</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.3 使用迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用迭代器---------&quot;</span>);</span><br><span class="line">    Iterator iterator = linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) iterator.next();</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.4 使用列表迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用正向列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator = linkedList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//因为还位执行.next()，游标指向在列表后(并没有指向第一个元素)， 所以当前下标-1 ，nextIndex为0，previousIndex为-1</span></span><br><span class="line">        <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">        <span class="comment">//在正向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的开头，则返回-1）</span></span><br><span class="line">        <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">        <span class="comment">//每次执行next()后 游标向前移一位  下标递减</span></span><br><span class="line">        Stu stu = (Stu) listIterator.next();</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.5 使用反向列表迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用反向列表迭代器---------&quot;</span>);</span><br><span class="line">    LinkedList stuLinkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    ArrayList stuArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">        <span class="comment">//因为还位执行previous()，光标指向在列表前(并没有指向最后一个元素)， 所以当前下标3 ，previousIndex为2，nextIndex为3(列表)</span></span><br><span class="line">        <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">        <span class="comment">//在反向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的末尾，则返回列表大小）</span></span><br><span class="line">        <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">        <span class="comment">//每次执行previous()后 游标向后移一位  下标递减</span></span><br><span class="line">        Stu stu = (Stu) listIterator.previous();</span><br><span class="line">        <span class="comment">//存进新的集合 完成集合反向排序</span></span><br><span class="line">        stuLinkedList.add(stu);</span><br><span class="line">        stuArrayList.add(stu);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//4. 判断</span></span><br><span class="line">    System.out.println(linkedList.contains(s1));</span><br><span class="line">    System.out.println(linkedList.isEmpty());</span><br><span class="line">    System.out.println(linkedList.indexOf(s3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合反向排序 &amp; Test LinkedList &amp; ArraryList</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------LinkedList使用列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator2 = stuLinkedList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator2.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) listIterator2.next();</span><br><span class="line">        <span class="keyword">int</span> index=listIterator2.nextIndex()-<span class="number">1</span>;</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;---------ArrayList使用列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator3 = stuArrayList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator3.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) listIterator3.next();</span><br><span class="line">        <span class="keyword">int</span> index=listIterator3.nextIndex()-<span class="number">1</span>;</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h4><p>属性：<br>    size //列表大小<br>    Node<E> first  //第一个节点<br>    Node<E> last   //最后一个节点<br>        prev   //节点指针  指向上一个节点<br>        element  //节点元素数据<br>        next  //节点指针  指向下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;          <span class="comment">//第一次add    第二次</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;   <span class="comment">//将最后一个节点赋值给l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);  <span class="comment">//新建一个节点 上一个节点=最后一个节点，下一个节点=null</span></span><br><span class="line">    last = newNode;     <span class="comment">//最后一个节点=新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)            <span class="comment">//成立         不成立</span></span><br><span class="line">        first = newNode;  <span class="comment">//第一个节点=新的节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;     <span class="comment">//上一次最后节点的下一个节点=新的节点</span></span><br><span class="line">    size++;            <span class="comment">//列表大小+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/QQ%E6%88%AA%E5%9B%BE20210305181826.jpg" class="">

<h4 id="ArraryList和LinkedList区别"><a href="#ArraryList和LinkedList区别" class="headerlink" title="ArraryList和LinkedList区别"></a>ArraryList和LinkedList区别</h4><ul>
<li>ArrayList：必须开辟连续空间，查询快，增删慢。</li>
<li>LinkedList：无需开辟连续空间，查询慢，增删快。</li>
</ul>
<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/febe000331d03d391696.png" class="">

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><strong>概述:</strong><ul>
<li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。  </li>
<li>常见形式有泛型类、泛型接口、泛型方法。</li>
<li>语法：<ul>
<li>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</li>
</ul>
</li>
</ul>
</li>
<li><strong>好处：</strong><ul>
<li>提高代码的重用性</li>
<li>防止类型转换异常，提高代码安全性</li>
</ul>
</li>
</ul>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 泛型类</span></span><br><span class="line"><span class="comment">* 语法：类名&lt;T&gt;</span></span><br><span class="line"><span class="comment">* T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//1.创建泛型变量</span></span><br><span class="line">  <span class="comment">//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span></span><br><span class="line">  T t;</span><br><span class="line">  <span class="comment">//2.泛型作为方法的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//泛型作为方法的返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 泛型接口</span></span><br><span class="line"><span class="comment">  * 语法：接口名&lt;T&gt;</span></span><br><span class="line"><span class="comment">  * 注意：不能创建泛型静态常量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//创建常量</span></span><br><span class="line">    String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function">T <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">*实现接口时确定泛型类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实现接口时不确定泛型类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericInterfaceImpl2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">show2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1.泛型只能使用引用类型</span></span><br><span class="line"><span class="comment"> * 2.不同泛型类型的对象不能相互赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> MyGeneric&lt;String&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;泛型作为参数&quot;</span>;</span><br><span class="line">        myGeneric1.show(<span class="string">&quot;这是泛型类&quot;</span>);</span><br><span class="line">        String t = myGeneric1.getT();</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*MyGeneric&lt;Integer&gt; myGeneric2=new MyGeneric&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">        myGeneric2.t=10;</span></span><br><span class="line"><span class="comment">        myGeneric2.show(20);</span></span><br><span class="line"><span class="comment">        Integer integer=myGeneric2.getT();</span></span><br><span class="line"><span class="comment">        System.out.println(integer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyGenericInterfaceImpl myGenericInterface=<span class="keyword">new</span> MyGenericInterfaceImpl();</span><br><span class="line">        myGenericInterface.show(<span class="string">&quot;这是泛型借口&quot;</span>);</span><br><span class="line">        MyGenericInterfaceImpl2&lt;String&gt; myGenericInterface2=<span class="keyword">new</span> MyGenericInterfaceImpl2();</span><br><span class="line">        myGenericInterface2.show(<span class="string">&quot;这是泛型借口2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyGenericMethod myGenericMethod = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        myGenericMethod.show(<span class="string">&quot;这是泛型方法 泛型作为参数&quot;</span>);</span><br><span class="line">        System.out.println(myGenericMethod.show2(<span class="string">&quot;这是泛型方法 泛型作为返回值&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h4><ul>
<li><p><strong>概念：</strong> 参数化类型，类型安全的集合，强制集合元素的类型必须一直。</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>编译时即可检查，而非运行时抛出异常。</li>
<li>访问时，不必类型转换（拆箱）。</li>
<li>不同泛型之间引用不能相互赋值，泛型不存在多态。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>特点：无序，无下标，元素不可重复</li>
<li>方法：全部继承于Collection中的方法</li>
</ul>
<p>代码实列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">//1.添加数据</span></span><br><span class="line">    set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;数据个数：&quot;</span>+set.size());</span><br><span class="line">    System.out.println(set.toString());<span class="comment">//无序输出</span></span><br><span class="line">    <span class="comment">//2.删除数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * set.remove(&quot;tang&quot;); System.out.println(set.toString());</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//3.遍历【重点】</span></span><br><span class="line">    <span class="comment">//3.1 使用增强for</span></span><br><span class="line">    <span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 使用迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(set.contains(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    System.out.println(set.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set实现类"><a href="#Set实现类" class="headerlink" title="Set实现类"></a>Set实现类</h3><h4 id="HashSet【重点】"><a href="#HashSet【重点】" class="headerlink" title="HashSet【重点】"></a>HashSet【重点】</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Person&gt; hashSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Person p3=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">//1.添加元素</span></span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    <span class="comment">//重复，添加失败</span></span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    <span class="comment">//直接new一个相同属性的对象，依然会被添加，不难理解。</span></span><br><span class="line">    <span class="comment">//假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">    hashSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    System.out.println(hashSet.toString());</span><br><span class="line">    <span class="comment">//2.删除元素</span></span><br><span class="line">    <span class="comment">//hashSet.remove(p2);</span></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//3.1 增强for</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : hashSet) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 迭代器</span></span><br><span class="line">    Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(hashSet.isEmpty());</span><br><span class="line">    <span class="comment">//直接new一个相同属性的对象结果输出是false，不难理解。</span></span><br><span class="line">    <span class="comment">//注：假如相同属性便认为是同一个对象，该怎么做？</span></span><br><span class="line">    System.out.println(hashSet.contains(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注：hashSet存储过程：<ol>
<li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li>
<li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li>
</ol>
</li>
</ul>
<p>注： 重写hashCode和equals方法</p>
<p>idea 快捷键alt+insert</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hashCode方法里为什么要使用31这个数字大概有两个原因：<ol>
<li>31是一个质数，这样的数字在计算时可以尽量减少散列冲突。</li>
<li>可以提高执行效率，因为31*i=(i&lt;&lt;5)-i，31乘以一个数可以转换成移位操作，这样能快一点；但是也有网上一些人对这两点提出质疑</li>
</ol>
</li>
</ul>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li>基于排序顺序实现不重复。</li>
<li>实现了SortedSet接口，对集合元素自动排序。</li>
<li>元素对象的类型必须实现Comparable接口，指定排序规则。</li>
<li>通过CompareTo方法确定是否为重复元素。</li>
</ul>
<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/QQ%E6%88%AA%E5%9B%BE20210305233210.jpg" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用TreeSet保存数据</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> * 要求：元素类必须实现Comparable接口，compareTo方法返回0，认为是重复元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> TreeSet&lt;Person&gt;();</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p3=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//注：直接添加会报类型转换错误，需要实现Comparable接口</span></span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        persons.remove(p1);</span><br><span class="line">        persons.remove(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">//3.遍历（略）</span></span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(persons.contains(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类实现Comparable接口，重写compareTo方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//1.先按姓名比</span></span><br><span class="line">    <span class="comment">//2.再按年龄比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">        <span class="keyword">int</span> n2=<span class="keyword">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Comparator 定制比较（比较器）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet&lt;Person&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;  <span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">                <span class="keyword">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;d&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;e&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p5 = <span class="keyword">new</span> Person(<span class="string">&quot;c&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        treeSet.add(p1);</span><br><span class="line">        treeSet.add(p2);</span><br><span class="line">        treeSet.add(p3);</span><br><span class="line">        treeSet.add(p4);</span><br><span class="line">        treeSet.add(p5);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小作业 要求按字符串长度比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 要求：按字符串长度比较</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=o1.length()-o2.length();     <span class="comment">//大于0排右边，小于0排左边</span></span><br><span class="line">                <span class="keyword">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;  <span class="comment">//匿名内部类</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;hjba&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h3><ul>
<li><p><strong>特点：</strong> 存储一对数据（Key-Value），无序、无下标，键不可重复，值可以重复。</p>
</li>
<li><p><strong>方法：</strong></p>
</li>
<li><p>V put(K key,V value)//将对象存入到集合中，关联键值。key重复则覆盖原值。</p>
</li>
<li><p>Object get(Object key)//根据键获取相应的值。</p>
</li>
<li><p>Set<K> keySet()//返回所有的key</p>
</li>
<li><p>Collection<V> values()//返回包含所有值的Collection集合。</p>
</li>
<li><p>Set&lt;Map.Entry&lt;K,V&gt; entrySet()//键值匹配的set集合</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//1添加</span></span><br><span class="line">        map.put(<span class="string">&quot;cn&quot;</span>,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;uk&quot;</span>,<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;usa&quot;</span>,<span class="string">&quot;美国&quot;</span>);</span><br><span class="line">        <span class="comment">//map.put(&quot;cn&quot;,&quot;china&quot;);  //key不允许重复 --- 替换</span></span><br><span class="line">        map.put(<span class="string">&quot;us&quot;</span>,<span class="string">&quot;美国&quot;</span>);    <span class="comment">//值允许重复</span></span><br><span class="line">        map.put(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span>+map.size());</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        <span class="comment">//2删除</span></span><br><span class="line">        <span class="comment">//map.remove(&quot;us&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span>+map.size());</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        <span class="comment">//3遍历</span></span><br><span class="line">        <span class="comment">//3.1使用keySet</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; keyset = map.keySet();   //遍历获取key</span></span><br><span class="line">        <span class="keyword">for</span> (String key:map.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot;------&quot;</span>+map.get(key));   <span class="comment">//通过key获取value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用entrySet</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entryMap:entries)&#123;</span><br><span class="line">            System.out.println(entryMap.getKey()+<span class="string">&quot;-------&quot;</span>+entryMap.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3扩展 通过values获取keys</span></span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        Map&lt;String,String&gt; map2=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;cn&quot;</span>,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;uk&quot;</span>,<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;usa&quot;</span>,<span class="string">&quot;美国&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map2.values();</span><br><span class="line">        System.out.println(demo.forValuesGetKeys(map,values));</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;zh&quot;</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;中国&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">forValuesGetKeys</span><span class="params">(Map&lt;String,String&gt; map,Collection values)</span> </span>&#123;</span><br><span class="line">        Collection collection=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Object [] arrayValues = values.toArray();</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayValues.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entryMap : map.entrySet()) &#123;</span><br><span class="line">                <span class="comment">//arrayValues[i].equals(entryMap.getValue()) &amp;&amp;</span></span><br><span class="line">                <span class="keyword">if</span> ( arrayValues[i]==entryMap.getValue()) &#123;</span><br><span class="line">                     collection.add(entryMap.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map实现类"><a href="#Map实现类" class="headerlink" title="Map实现类"></a>Map实现类</h3><h4 id="HashMap【重点】"><a href="#HashMap【重点】" class="headerlink" title="HashMap【重点】"></a>HashMap【重点】</h4><p>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Stu, String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;Stu, String&gt;();</span><br><span class="line">        Stu s1=<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Stu s2=<span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Stu s3=<span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        hashMap.put(s1, <span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">        hashMap.put(s2, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashMap.put(s3, <span class="string">&quot;贵州&quot;</span>);</span><br><span class="line">        <span class="comment">//添加成功，不过两个属性一模一样；</span></span><br><span class="line">        <span class="comment">//注：假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">        hashMap.put(<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>),<span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">        System.out.println(hashMap.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//hashMap.remove(s3);</span></span><br><span class="line">        System.out.println(hashMap.toString());</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1 使用keySet()遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Stu key : hashMap.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot; &quot;</span>+hashMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用entrySet()遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Stu, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        <span class="comment">//注：同上</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)));</span><br><span class="line">        System.out.println(hashMap.containsValue(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可,为了保证数据安全,不重复，尽可能在实体中重写hashCode方法和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stu stu = (Stu) o;</span><br><span class="line">        <span class="keyword">return</span> age == stu.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, stu.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a><strong>HashMap源码分析</strong></h4></li>
<li><p>默认初始化容量：<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></p>
<ul>
<li>数组最大容量：<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li>
</ul>
</li>
<li><p>默认加载因子：<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p>
</li>
<li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：<code>static final int TREEIFY_THRESHOLD = 8;</code></p>
</li>
<li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：<code>static final int UNTREEIFY_THRESHOLD = 6;</code></p>
</li>
<li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：<code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p>
</li>
<li><p>HashMap存储的数组：<code>transient Node&lt;K,V&gt;[] table;</code></p>
</li>
<li><p>HashMap存储的元素个数：<code>transient int size;</code></p>
<blockquote>
<ul>
<li>默认加载因子是什么？<ul>
<li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。</li>
</ul>
</li>
<li>链表调整为红黑树的链表长度阈值是什么？<ul>
<li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li>
</ul>
</li>
<li>红黑树调整为链表的链表长度阈值是什么？<ul>
<li>当红黑树的元素个数小于该阈值时就会转换成链表。</li>
</ul>
</li>
<li>链表调整为红黑树的数组最小阈值是什么？<ul>
<li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li>
</ul>
</li>
</ul>
</blockquote>
<p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p>
<p>  当我们往对象里添加元素时调用put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  扩容的代码如下（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newCap;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//略&#125;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p>
<ul>
<li>*注**：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</li>
</ul>
<hr>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h4><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><strong>Hashtable</strong></h4><ul>
<li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p>
</li>
<li><p>初始容量11，加载因子0.75。</p>
<p>这个集合在开发过程中已经不用了，稍微了解即可。</p>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h4><ul>
<li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li>
</ul>
<p>它继承了Hashtable的方法，与流关系密切，此处不详解。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h4><ul>
<li>实现了SortedMap接口（是Map的子接口），可以对key自动排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student, Integer&gt; treeMap=<span class="keyword">new</span> TreeMap&lt;Student, Integer&gt;();</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">        Student s3=<span class="keyword">new</span> Student(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        treeMap.put(s1, <span class="number">21</span>);</span><br><span class="line">        treeMap.put(s2, <span class="number">22</span>);</span><br><span class="line">        treeMap.put(s3, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span></span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        treeMap.remove(<span class="keyword">new</span> Student(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1 使用keySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Student key : treeMap.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot; &quot;</span>+treeMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用entrySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(treeMap.containsKey(s1));</span><br><span class="line">        System.out.println(treeMap.isEmpty());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学生类中实现Comparable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="keyword">this</span>.id-o.id;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以使用比较器来定制比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap2=<span class="keyword">new</span> TreeMap&lt;Student, Integer&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h4><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p>
<hr>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul>
<li><p><strong>概念</strong>：集合工具类，定义了除了存取以外的集合常用方法。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><code>public static void reverse(List&lt;?&gt; list)</code>//反转集合中元素的顺序</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>//随机重置集合元素的顺序</li>
<li><code>public static void sort(List&lt;T&gt; list)</code>//升序排序（元素类型必须实现Comparable接口）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示Collections工具类的使用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">20</span>);</span><br><span class="line">    list.add(<span class="number">10</span>);</span><br><span class="line">    list.add(<span class="number">30</span>);</span><br><span class="line">    list.add(<span class="number">90</span>);</span><br><span class="line">    list.add(<span class="number">70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sort排序</span></span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//binarySearch二分查找</span></span><br><span class="line">    <span class="keyword">int</span> i=Collections.binarySearch(list, <span class="number">10</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复制</span></span><br><span class="line">    List&lt;Integer&gt; list2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;<span class="number">5</span>;++i1) &#123;</span><br><span class="line">        list2.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法要求目标元素容量大于等于源目标</span></span><br><span class="line">    Collections.(list2, list);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reserve反转</span></span><br><span class="line">    Collections.reverse(list2);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//shuffle 打乱</span></span><br><span class="line">    Collections.shuffle(list2);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//补充：list转成数组</span></span><br><span class="line">    Integer[] arr=list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//补充：数组转成集合 </span></span><br><span class="line">    String[] nameStrings= &#123;<span class="string">&quot;tang&quot;</span>,<span class="string">&quot;he&quot;</span>,<span class="string">&quot;yu&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//受限集合，不能添加和删除</span></span><br><span class="line">    List&lt;String&gt; list3=Arrays.asList(nameStrings);</span><br><span class="line">    System.out.println(list3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注：基本类型转成集合时需要修改为包装类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-多线程</title>
    <url>/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><blockquote>
<p>关于进程和线程的知识都是操作系统里学过的内容，此处作为JAVA多线程的前置知识进行复习回顾，补充的内容可看可不看。</p>
</blockquote>
<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p><strong>进程是系统进行资源分配的基本单位</strong>，<strong>也是独立运行的基本单位</strong>。多个进程可以同时存在于内存中，能在一段时间内同时运行，在windows操作中，可以打开任务管理器看到各种各样的进程和对应的PID，并且都占用了一定的系统资源。单核CPU在同一个时刻，只能运行一个进程。所谓同时运行是宏观上的概念，微观上进程之间是在不停地快速切换。</p>
<blockquote>
<p>补充：</p>
<p>进程具有几个基本特性：</p>
<ul>
<li>动态性。进程是程序在处理器上的一次执行过程，它因创建而产生，由调度而执行，因得不到资源而暂停，最后因撤销而消亡。</li>
<li>并发性：如概述里所说，多个进程可以同时存在于内存中，能在一段时间内同时运行。进程的目的是使程序能与其他程序并行，以提高资源利用率。</li>
<li>独立性：进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</li>
<li>异步性：进程以各自独立的、不可预知的速度向前推进。</li>
<li><strong>结构特征</strong>：为了描述和记录进程的运动变化过程，并使之能正确运行，每个进程都由程序段、数据段和一个进程控制块 (Process Control Block,PCB)组成。</li>
</ul>
<p>系统根据PCB感知进程的存在。PCB是进程存在的唯一标志。</p>
</blockquote>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程又称<strong>轻量级进程</strong> (Light Weight Process),它是进程内一个相对独立的、可调度的执行单元，也是CPU的基本调度单位。一个进程由一个或多个线程组成，彼此间完成不同的工作，同时执行，称为多线程，此处的同时执行也是宏观上的。在windows操作系统中，可以打开任务管理器，找到性能分页下的资源管理器，可以查看每个进程所拥有的线程数。</p>
<p>JAVA虚拟机是一个进程，当中默认包含主线程 (main)，可通过代码创建多个独立线程，与main并发执行。</p>
<blockquote>
<p>补充：</p>
<ul>
<li><p><strong>线程的引入</strong></p>
<p>在操作系统中引入线程，是为了减少程序并发执行时所付出的时空开销，使操作系统具有更好的并发性，为了说明这一点，先来回顾一下进程的两个基本属性：</p>
<ol>
<li>进程是一个拥有资源的独立单位。</li>
<li>进程同时又是一个可以被处理器独立调度和分配的单元。</li>
</ol>
<p>上述两个属性构成了程序并发执行的基础。然而，为了使进程能并发执行，操作系统还必须进行一系列的操作，如进程的创建、撤销进程和进程切换。在进行这些操作时，操作系统要为进程分配资源及回收资源，为运行进程保存现场信息，这些工作都需要付出较多的时空开销。为了使多个程序更好地并发执行，并尽量减少操作系统的开销，操作系统设计者考虑将进程的两个属性分离开来，让线程去完成第二个基本属性的任务，而进程只完成第一个基本属性的任务。</p>
</li>
<li><p><strong>线程的定义</strong></p>
<p>线程的定义存在多种不同的提法，前文概述中已阐述一二，此处进行补充说明。线程本身不能单独运行，只能包含在进程中，只能在进程中执行。线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源，但它可以与同属一个进程的其他线程<strong>共享</strong>该进程资源。多线程是指一个进程中有多个线程，这些线程共享该进程资源。如果一个线程修改了一个数据项，其他线程可以了解和使用此结果数据。一个线程打开并读一个文件时，同一进程中的其他线程也可以同时读此文件。</p>
</li>
</ul>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>进程是操作系统资源分配的基本单位，而线程是CPU的基本调度单位。</li>
<li>一个程序运行后之后有一个进程。</li>
<li>一个进程可以包含多个线程，但是至少需要有一个线程，否则这个线程是没有意义的。</li>
<li>进程间不能共享数据段地址，但同进程的线程之间可以。</li>
</ol>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><ul>
<li>任何一个线程都具有基本的组成部分：<ul>
<li>CPU时间片：操作系统会为每个线程分配执行时间。</li>
<li>运行数据：<ul>
<li>堆空间：存储线程需要使用的对象，多个线程可以共享堆中的对象。</li>
<li>栈空间：存储线程需要使用的局部变量，每个线程都拥有独立的栈。</li>
</ul>
</li>
<li>线程的逻辑代码</li>
</ul>
</li>
</ul>
<h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ul>
<li>线程抢占式执行。<ul>
<li>效率高。</li>
<li>可防止单一线程长时间独占CPU。</li>
</ul>
</li>
<li>在单核CPU中，宏观上同时执行，微观上顺序执行。</li>
</ul>
<hr>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><ul>
<li>创建线程的三种方式：<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口。</li>
<li>实现Callable接口。 (6.4节演示)</li>
</ol>
</li>
</ul>
<h3 id="继承Thread创建线程"><a href="#继承Thread创建线程" class="headerlink" title="继承Thread创建线程"></a>继承Thread创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testMyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//启动子线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----<span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">----<span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">----<span class="number">2</span></span><br><span class="line">----<span class="number">3</span></span><br><span class="line">----<span class="number">4</span></span><br><span class="line">----<span class="number">5</span></span><br><span class="line">----<span class="number">6</span></span><br><span class="line">----<span class="number">7</span></span><br><span class="line">----<span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">----<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>每次运行后得到的结果都不一样，而且主线程和子线程都是交替执行的，并且是抢占式执行。</p>
<p>需要<strong>注意</strong>的是，在main方法中需要调用线程类的start方法来启动线程，如果调用run方法就相当于调用了一个普通类中的方法，那么还是由主线程执行。</p>
<h3 id="获取和修改线程名称"><a href="#获取和修改线程名称" class="headerlink" title="获取和修改线程名称"></a>获取和修改线程名称</h3><ul>
<li><p><strong>获取线程ID和线程名称</strong></p>
<ol>
<li>在Thread的子类中调用<code>this.getId()</code>或<code>this.getName()</code>。</li>
<li>使用<code>Thread.currentThread().getId()</code>和<code>Thread.currentTread().getName()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类</span></span><br><span class="line"><span class="comment"> * 获取线程名方法演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//第一种方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程ID：&quot;</span>+<span class="keyword">this</span>.getId()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;线程名：&quot;</span>+<span class="keyword">this</span>.getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            <span class="comment">//第二种方法</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;线程ID：&quot;+Thread.currentThread().getId()+&quot; &quot;+&quot;线程名：&quot;+Thread.currentThread().getName());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用第一种方法的线程类必须继承Thread父类，否则不能使用这两个方法。</p>
<p>第二种方法调用的静态方法currentThread表示获取当前线程，哪个线程执行的当前代码就获取谁。</p>
<p>在<code>testMyThread</code>类中<strong>再新创建</strong>一个线程类对象并启动，可以看到如下结果：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">1</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">6</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">9</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">6</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">9</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">主线程：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改线程名称</strong></li>
</ul>
<ol>
<li>调用线程对象的<code>setName()</code>方法。</li>
<li>使用线程子类的构造方法赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用setName方法</span></span><br><span class="line">myThread.setName(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread2.setName(<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">myThread2.start();</span><br></pre></td></tr></table></figure>

<p>使用该方法需要注意必须在线程启动之前修改线程名，否则就没有意义了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程类的带参构造方法调用了父类的构造方法，也可以把name赋给线程名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">MyThread myThread=<span class="keyword">new</span> MyThread(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">MyThread myThread2=<span class="keyword">new</span> MyThread(<span class="string">&quot;子线程2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在创建线程对象时可以直接通过构造方法为线程修改名字，运行后结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">6</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">8</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">9</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">5</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">6</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">7</span></span><br><span class="line">主线程：<span class="number">9</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="一个线程小案例"><a href="#一个线程小案例" class="headerlink" title="一个线程小案例"></a>一个线程小案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用继承Thread类实现4个窗口各卖100张票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWin</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWin</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    ticket--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+ticket+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//四个窗口</span></span><br><span class="line">        TicketWin ticketWin1=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        TicketWin ticketWin2=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        TicketWin ticketWin3=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        TicketWin ticketWin4=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口4&quot;</span>);</span><br><span class="line">        ticketWin1.start();</span><br><span class="line">        ticketWin2.start();</span><br><span class="line">        ticketWin3.start();</span><br><span class="line">        ticketWin4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码后结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">95</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">94</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">93</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">92</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">91</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable创建线程"><a href="#实现Runnable创建线程" class="headerlink" title="实现Runnable创建线程"></a>实现Runnable创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象，实现run功能</span></span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程类</span></span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(myRunnable, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">子线程：<span class="number">0</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">子线程：<span class="number">1</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">子线程：<span class="number">2</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">子线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">5</span></span><br><span class="line">子线程：<span class="number">6</span></span><br><span class="line">子线程：<span class="number">7</span></span><br><span class="line">子线程：<span class="number">8</span></span><br><span class="line">子线程：<span class="number">9</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">主线程：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>上述代码段中使用的构造方法是<code>Thread((Runnable target, String name)</code>，Runnable是一个接口类，方法体只包含一个抽象方法run。既然参数传进来的是接口类，那么也可以使用匿名内部类 (如果线程只使用一次):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建可运行对象</span></span><br><span class="line">        Runnable runnable=<span class="keyword">new</span> Runnable() &#123;    </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(runnable, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable小案例"><a href="#Runnable小案例" class="headerlink" title="Runnable小案例"></a>Runnable小案例</h3><ol>
<li><strong>实现四个窗口共卖100张票</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 票类，实现买票功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建票对象</span></span><br><span class="line">        Ticket ticket=<span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread w1=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread w2=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread w3=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        Thread w4=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口4&quot;</span>);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">        w4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以这样的逻辑写代码是没有错的，但是在运行的时候大家会发现控制台打印的似乎并没有实现“共享”，但最终都会有某一个窗口卖完票：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">93</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">94</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">95</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">89</span>张。</span><br><span class="line">    ......</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">2</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">1</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">0</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">16</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">17</span>张。</span><br></pre></td></tr></table></figure>

<p>  这是因为线程是抢夺式占用CPU，每个线程都以各自的不可预知的进度执行。等后面讲完线程的同步之后你可以再来理解这个案例。<br>2. <strong>你和你女朋友同时向银行卡里面存取钱</strong>。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 银行卡 (普通类)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        Money = money;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 存钱功能 (功能类)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BankCard card;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddMoney</span><span class="params">(BankCard bankCard)</span> </span>&#123;</span><br><span class="line">        card=bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//往卡里存200</span></span><br><span class="line">            card.setMoney(card.getMoney()+<span class="number">200</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存了200元，卡里余额为：&quot;</span>+(card.getMoney()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取钱功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubMoney</span><span class="params">(BandCard bandCard)</span> </span>&#123;</span><br><span class="line">        card=bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(card.getMoney()&gt;=<span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//往卡里取200</span></span><br><span class="line">                card.setMoney(card.getMoney()-<span class="number">200</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了200元，卡里还剩&quot;</span>+card.getMoney());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//余额不足，回退这次取钱过程，否则有效的取钱次数可能不到10次</span></span><br><span class="line">                i--;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testBankCard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建银行卡对象</span></span><br><span class="line">        BandCard bandCard=<span class="keyword">new</span> BandCard();</span><br><span class="line">        <span class="comment">//创建功能对象</span></span><br><span class="line">        AddMoney addMoney=<span class="keyword">new</span> AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney=<span class="keyword">new</span> SubMoney(bandCard);</span><br><span class="line">        <span class="comment">//创建线程对象并启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(addMoney,<span class="string">&quot;爸爸&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(subMoney,<span class="string">&quot;我&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行代码结果如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">0</span></span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">200</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">400</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">600</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">800</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1000</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1000</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1200</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1400</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1600</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">800</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1400</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1000</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">800</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">600</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">400</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>  当然每次运行结果是不一样的，而且可以注意到控制台打印的数据似乎并不“正确”，原因同上一个案例，不过最终的结果卡里还是0元。这个案例也可以写成匿名内部类以减少代码量，缺点是可读性差，这里不再演示。</p>
<h3 id="Thread和Runnable的区别及正确写法"><a href="#Thread和Runnable的区别及正确写法" class="headerlink" title="Thread和Runnable的区别及正确写法"></a>Thread和Runnable的区别及正确写法</h3><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0NTM2MS9hcnRpY2xlL2RldGFpbHMvOTMyMjM0ODg=">https://blog.csdn.net/weixin_43145361/article/details/93223488<i class="fa fa-external-link-alt"></i></span></p>
<p>Thread正确写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line">        java.lang.Thread tA=<span class="keyword">new</span> java.lang.Thread(t1, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        tA.setPriority(<span class="number">5</span>);</span><br><span class="line">        java.lang.Thread tB=<span class="keyword">new</span> java.lang.Thread(t1, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        tB.setPriority(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程优先执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line"></span><br><span class="line">        tA.join();  <span class="comment">//插队 让主线程等待子线程进行完后执行</span></span><br><span class="line">        tB.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + i + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Runnable正确写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable=<span class="keyword">new</span> Runnable();</span><br><span class="line">        java.lang.Thread t1=<span class="keyword">new</span> java.lang.Thread(runnable);</span><br><span class="line">        java.lang.Thread t2=<span class="keyword">new</span> java.lang.Thread(runnable);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程基本状态-源码补充"><a href="#线程基本状态-源码补充" class="headerlink" title="线程基本状态 (源码补充)"></a>线程基本状态 (源码补充)</h2><p>在JDK1.5之后，把就绪状态和运行状态合成了一个Runnable状态，可以通过<code>public Thread.State getState()</code>方法获取当前线程的状态。</p>
<p>我们可以通过源码来查看一下这几个状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个State返回类型实际上一个枚举类。</p>
<ul>
<li><p><strong>NEW</strong> 初始状态<br>线程还没有启动时的状态。</p>
</li>
<li><p><strong>RUNNABLE</strong> 就绪状态和执行状态<br>线程启动时的状态。线程被JVM所执行但它还可能需要一些来自操作系统的其他资源才能执行。</p>
</li>
<li><p><strong>BLOCKED</strong> 阻塞状态<br>当线程访问临界区 (同步块代码)时，如果没有拿到访问锁，便进入阻塞状态。<br>线程被一个监听锁所阻塞时的状态。</p>
</li>
<li><p><strong>WAITING</strong>  (无期限)等待状态<br>线程正在等待时的状态。线程被以下方法所调用就会进入等待状态：</p>
<ul>
<li><code>Object.wait</code>无参方法</li>
<li><code>Thread.join</code>无参方法</li>
<li><code>LockSupport.park</code><br>wait方法可以让当前线程进入等待状态，需要其他线程调用此线程对象的notify方法或者notifyAll方法来唤醒此线程；调用join方法的线程需要等到被调用线程终止才能结束等待状态。</li>
</ul>
</li>
<li><p><strong>TIMED_WAITING</strong> 有限等待状态<br>线程在指定时间后才能结束等待的一种等待状态。是由于调用了以下方法所引起的一种状态：</p>
<ul>
<li><code>Thread.sleep</code></li>
<li><code>Object.wait</code>带参方法</li>
<li><code>Thread.join</code>带参方法</li>
<li><code>LockSupport.parkNanos</code></li>
<li><code>LockSupport.parkUntil</code></li>
</ul>
</li>
<li><p><strong>TERMINATED</strong> 终止状态<br>线程终止时的状态。该线程已经执行完毕。</p>
</li>
</ul>
<img src="/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/QQ%E6%88%AA%E5%9B%BE20210312104252.jpg" class="">

<hr>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><ul>
<li><p><code>public static void sleep(long millis)</code></p>
<p>当前线程主动休眠millis毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示sleep的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">// (主线程)每隔一秒打印一次</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>public static void yield()</code></p>
<p>当前线程主动放弃时间片，回到就绪状态，竞争下一次时间片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示yield的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">            <span class="comment">//打印一次后主动放弃时间片，释放CPU</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类里创建两个线程对象执行上述代码，所得到的打印结果会更接近于交替打印。</p>
</li>
<li><p><code>public final void join()</code></p>
<p>允许其他线程加入到当前线程中。当某线程调用该方法时，加入并阻塞当前线程，直到加入的线程执行完毕，当前线程才继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示join的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//加入到当前线程 (主线程main)，并阻塞当前线程</span></span><br><span class="line">        <span class="comment">//必须要在线程启动之后调用</span></span><br><span class="line">        thread.join();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉join这行代码，就和之前运行的结果一样，两个线程抢占执行；调用join之后结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子线程：<span class="number">0</span></span><br><span class="line">子线程：<span class="number">1</span></span><br><span class="line">子线程：<span class="number">2</span></span><br><span class="line">子线程：<span class="number">3</span></span><br><span class="line">子线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">5</span></span><br><span class="line">子线程：<span class="number">6</span></span><br><span class="line">子线程：<span class="number">7</span></span><br><span class="line">子线程：<span class="number">8</span></span><br><span class="line">子线程：<span class="number">9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>子线程加入到主线程并阻塞了主线程，子线程执行完毕后才恢复主线程的运行。</p>
</li>
<li><p><code>pubic final void setPriority(int newPriority)</code></p>
<p>改变该线程的优先级，线程优先级为1-10，默认为5，优先级越高，表示获取CPU机会越多。</p>
<p>把前面<code>MyRunnable</code>类中的循环次数写多一点，比如改成50次，然后在测试类里设置优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程3&quot;</span>);</span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t3.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会发现每次运行的结果都是子线程1最后执行完，说明优先级设置成功了。</p>
</li>
<li><p><code>public final void setDaemon(boolean on)</code></p>
<p>如果参数为true，则标记该线程为守护线程。</p>
<p>在JAVA中线程有两类：<strong>用户线程</strong> (前台线程)、<strong>守护线程</strong> (后台线程)。守护可以理解为守护用户线程。如果程序中所有用户线程都执行完毕了，守护线程会自动结束。<strong>垃圾回收线程属于守护线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示守护线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread thread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//必须在start之前设置</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道线程争夺的情况，但当某个线程被设置成守护线程时，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当主线程执行完毕后，子线程只打印了4次，但因为前者的结束而结束。</p>
</li>
</ul>
<hr>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>这里有一个线程安全问题，假设有A、B两个线程，他们都往一个数组中的index位置存入一个数据并且执行index+1。</p>
<p>A线程存入<code>&quot;hello&quot;</code>，然后使<code>index++</code>；B线程存入<code>&quot;world&quot;</code>，然后使<code>index++</code>。当这两个线程同时执行时，数组中存入的结果会是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String[] strings=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//存入hello</span></span><br><span class="line">        Runnable runnableA=<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                strings[index]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//存入world</span></span><br><span class="line">        Runnable runnableB=<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                strings[index]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread A=<span class="keyword">new</span> Thread(runnableA);</span><br><span class="line">        Thread B=<span class="keyword">new</span> Thread(runnableB);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">        <span class="comment">//加入主线程，用来阻塞主线程使最后的输出语句最后执行</span></span><br><span class="line">        A.join();</span><br><span class="line">        B.join();        </span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行代码，发现得到的结果并不一致，有可能出现<code>[hello, world, null, null, null]</code>，也有可能出现<code>[world, null, null, null, null]</code>；以第二个结果为例，当线程A存入hello之后，CPU马上就被线程B所抢夺，B存入了world覆盖了A存入的hello，这之后才执行了各自的<code>index++</code>。</p>
<p><strong>多线程安全问题</strong>：</p>
<ul>
<li><p>当多线程并发访问</p>
<p>临界资源</p>
<p>时，如果破坏了</p>
<p>原子操作</p>
<p>，可能会造成数据不一致。</p>
<ul>
<li>临界资源：共享资源 (对于同一个对象)，一次仅允许一个线程使用，才可以保证其正确性。</li>
<li>原子操作：不可分割的多步操作，被视为一个整体，其顺序和步骤不可打乱或缺省，比如上一段代码的存hello和存world应当被看成两个原子操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：</p>
<p><strong>临界资源和临界区</strong> (针对线程而言)：</p>
<p>线程在运行过程中，会与同一进程内的其他线程共享资源，把同时只允许一个线程使用的资源称为临界资源。为了保证临界资源的正确使用，可以把临界资源的访问分成以下四个部分：</p>
<ol>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区；如果可以进入临界区，通常设置相应的“正在访问临界区”标志，以阻止其他线程同时进入临界区。</li>
<li><strong>临界区</strong>。<strong>线程用于访问临界资源的代码</strong>，<strong>又称临界段</strong>。</li>
<li><strong>退出区</strong>。临界区后用于将“正在访问临界区”标志清除部分。</li>
<li>剩余区。线程中除上述3部分以外的其他部分。</li>
</ol>
<p>简单来说，临界资源是一种系统资源，需要不同的线程互斥访问，例如前文代码中的数组；而临界区则是每个线程中访问临界资源的一段代码，是属于对应线程的，前文代码中的存hello和存world就可以看成是两个临界区，临界区前后需要设置进入区和退出区以进行检查和恢复。</p>
</blockquote>
<p>JAVA中，在程序应用里要保证线程的安全性就需要用到<strong>同步代码块</strong>。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对临界资源对象加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(临界资源对象)&#123;</span><br><span class="line">    <span class="comment">//代码 (原子操作)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  把上文存hello和存world两个临界区放进同步代码块中就可以保证输出结果不会出现覆盖的情况：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (strings) &#123;</span><br><span class="line">    strings[index]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (strings) &#123;</span><br><span class="line">    strings[index]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>  现在就能解决之前的卖票小案例，你可以从目录跳转到Runnable小案例，并使用同步代码块来实现互斥访问票这个临界资源：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注：这个锁可以是任意一种对象，但不能直接在里面new</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;            </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再次运行你就能看到期望的结果，这里不再演示。</p>
<blockquote>
<p>注：</p>
<p><strong>每个对象都有一个互斥锁标记</strong>，<strong>用来分配给线程的</strong>。</p>
<p>只有拥有对象互斥锁标记的线程，才能进入对该对象加锁的同步代码块。</p>
<p>线程退出同步代码块时，会释放相应的互斥锁标记。</p>
</blockquote>
<p>  前文的银行卡存取案例同样也能解决了：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取钱</span></span><br><span class="line"><span class="keyword">synchronized</span> (card) &#123;</span><br><span class="line">    <span class="keyword">if</span>(card.getMoney()&gt;=<span class="number">200</span>) &#123;</span><br><span class="line">        card.setMoney(card.getMoney()-<span class="number">200</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了200元，卡里还剩&quot;</span>+card.getMoney());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i--;</span><br><span class="line">        System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存钱</span></span><br><span class="line"><span class="keyword">synchronized</span> (card) &#123;</span><br><span class="line">    card.setMoney(card.getMoney()+<span class="number">200</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存了200元，卡里余额为：&quot;</span>+(card.getMoney()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行一下，没有问题。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对当前对象 (this)加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> 返回值类型 方法名称 (形参列表)&#123;</span><br><span class="line">    <span class="comment">//代码 (原子操作)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  用这种同步方式改写2.5节中的第一个案例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;            </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  得到的也是一样的正确结果。在这个同步方法中，锁就是<code>this</code>当前对象；如果是静态类，那么锁就是类对象，就相当于在同步代码块的括号里写<code>XXX.class</code>，XXX代表当前的类。</p>
<blockquote>
<p>注：</p>
<p>只有拥有对象互斥锁标记的线程，才能进入该对象加锁的同步方法中。线程退出同步方法时，会释放相应的互斥锁标记。</p>
</blockquote>
<ul>
<li><strong>同步规则</strong><ul>
<li>只有在调用包含同步代码块的方法，或者同步方法时，才需要对象的锁标记。<br>临界区 (互斥执行)才需要加锁。</li>
<li>如调用不包含同步代码块的方法，或普通方法时，则不需要锁标记，可直接调用。</li>
<li>已知JDK中线程安全的类：<ul>
<li>StringBuffer</li>
<li>Vector</li>
<li>Hashtable</li>
<li>以上类中的公开方法，均为synchronized修饰的同步方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经典问题-死锁"><a href="#经典问题-死锁" class="headerlink" title="经典问题 (死锁)"></a>经典问题 (死锁)</h3><p><strong>死锁</strong>：</p>
<ul>
<li>当第一个线程拥有A对象锁标记，并等待B对象锁标记，同时第二个线程拥有B对象锁标记，并等待A对象锁标记时，产生死锁。</li>
<li>一个线程可以同时拥有多个对象的锁标记，当线程阻塞时，不会释放已经拥有的锁标记，由此可能造成死锁。</li>
</ul>
<blockquote>
<p>补充：</p>
<p><strong>死锁的概念</strong> (对于线程)：</p>
<p>当多个线程因竞争系统资源或互相通信而处于半永久阻塞状态时，若无外力作用，这些线程都将无法向前推进。这些线程中的每一个线程，均无限期地等待此组线程中某个其他线程占用的、自己永远无法得到的资源，这种现象称为死锁。</p>
<p><strong>资源分类</strong>：</p>
<p>现代操作系统所管理的资源类型十分丰富，并且可以从不同角度出发对其进行分类，例如，可以把资源分为可剥夺资源和不可剥夺资源。</p>
<ul>
<li><strong>可剥夺资源</strong>是指虽然资源占有者线程需要使用该资源，但另一个线程可以强行把该资源从占有者线程处剥夺过来自己使用。</li>
<li><strong>不可剥夺资源</strong>是指<strong>除非</strong>占有者线程不再需要使用该资源而主动释放资源，否则其他线程不得在占有者线程使用资源过程中强行剥夺。</li>
</ul>
<p>死锁产生的原因是<strong>竞争资源</strong>。可剥夺资源的竞争不会引起死锁。更进一步看，死锁产生的原因是<strong>系统资源不足</strong>和线程<strong>推进顺序不当</strong>；后者是重要原因而前者是根本原因。</p>
</blockquote>
<p>通过一个小案例来演示死锁的产生，假如男孩和女孩桌子上同时吃饭，桌上只有一双筷子，当一个人同时拥有A，B两根筷子的时候才能吃：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;男孩拿到了a&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;男孩拿到了b&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;男孩可以吃东西了...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;女孩拿到了b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;女孩拿到了a&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;女孩可以吃东西了...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个锁(两个筷子)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object a=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object b=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boy boy=<span class="keyword">new</span> Boy();</span><br><span class="line">        Girl girl=<span class="keyword">new</span> Girl();</span><br><span class="line">        girl.start();</span><br><span class="line">        <span class="comment">//加上休眠 解决死锁问题</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            // TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        boy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后程序进入死锁状态，并且无限期地等待下去：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//控制台打印 (程序未结束)</span><br><span class="line">男孩拿到了a</span><br><span class="line">女孩拿到了b</span><br></pre></td></tr></table></figure>

<p>男孩和女还各持有一根筷子，并且都在等待对方的一根筷子，导致两个人都吃不了饭。可以通过sleep方式使其中一个线程休眠一小会，男孩用A (B)吃完女孩用B (A)再吃；或者把B (A)同步代码块中的锁换一下位置A (B)，一开始两个人都抢同一根筷子，有第一根筷子就有第二根筷子，没抢到的就等另一个吃完饭再吃。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>在2.5节中的第二个案例银行卡存取中，打印出了很多余额不足，取钱线程在银行卡里没钱时也在不停地取钱，为了让取钱线程只在银行卡里有钱时再取，就需要实现线程间通信。</p>
<ul>
<li><p>等待</p>
<p>：</p>
<ul>
<li><code>public final void wait()</code></li>
<li><code>public final void wait(long timeout)</code></li>
<li>必须在对obj加锁的同步代码块中调用。在一个线程中，调用<code>obj.wait()</code>时，此线程会释放其拥有的所有锁标记。同时此线程阻塞在obj的等待队列中。总而言之，就是释放锁，进入等待队列。</li>
</ul>
</li>
<li><p>通知</p>
<p>：</p>
<ul>
<li><code>public final void notify()</code></li>
<li><code>public final void notifyAll()</code></li>
<li>进入等待的线程需要其他线程调用该线程的通知方法来将其唤醒。</li>
</ul>
</li>
</ul>
<p>还是银行卡存取案例，此处应用线程通信再来演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 银行卡 (普通类)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BandCard &#123;</span><br><span class="line">    private double Money;</span><br><span class="line">    &#x2F;&#x2F;标志，true表示卡里有钱-可取，false表示无钱-可存</span><br><span class="line">    boolean flag&#x3D;false;    </span><br><span class="line">    public synchronized void put(double money) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;有钱不用存</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            &#x2F;&#x2F;进入等待队列 (锁.wait)，同时释放锁和CPU</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.Money+&#x3D;money;</span><br><span class="line">        System.out.println(&quot;你爸存了&quot;+money+&quot;元，卡里还剩&quot;+this.Money+&quot;元。&quot;);</span><br><span class="line">        &#x2F;&#x2F;存完之后卡里有钱</span><br><span class="line">        flag&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;唤醒取钱线程</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void take(double money) throws InterruptedException &#123;    </span><br><span class="line">        &#x2F;&#x2F;没钱不能取</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.Money-&#x3D;money;</span><br><span class="line">        System.out.println(&quot;你取了&quot;+money+&quot;元，卡里还剩&quot;+this.Money+&quot;元。&quot;);</span><br><span class="line">        flag&#x3D;false;</span><br><span class="line">        &#x2F;&#x2F;唤醒存钱线程</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存钱功能 (功能类)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AddMoney implements Runnable&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    public AddMoney(BandCard bandCard) &#123;</span><br><span class="line">        card&#x3D;bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;存10次</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                card.put(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 取钱功能</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SubMoney implements Runnable&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    public SubMoney(BandCard bandCard) &#123;</span><br><span class="line">        card&#x3D;bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;取10次</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                card.take(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testBankCard &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建银行卡对象</span><br><span class="line">        BandCard bandCard&#x3D;new BandCard();</span><br><span class="line">        &#x2F;&#x2F;创建操作</span><br><span class="line">        AddMoney addMoney&#x3D;new AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney&#x3D;new SubMoney(bandCard);</span><br><span class="line">        &#x2F;&#x2F;创建线程对象并启动</span><br><span class="line">        new Thread(addMoney).start();</span><br><span class="line">        new Thread(subMoney).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后得到如下正确交替结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br></pre></td></tr></table></figure>

<p><strong>多存多取问题：</strong></p>
<ul>
<li><p><strong>if和while的区别</strong></p>
<p>if只适用用于单进单出，while适用于多进多出</p>
<p>但是如果往代码中再加入两个线程，比如你妈担心你钱不够用，也给你存钱；你妹妹来找你玩，往你卡里取钱。这时候就出现问题了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你妹取了200.0元，卡里还剩0.0元。</span><br><span class="line">你妈存了200.0元，卡里还剩200.0元。</span><br><span class="line">你妹取了200.0元，卡里还剩0.0元。</span><br><span class="line">你取了200.0元，卡里还剩-200.0元。</span><br><span class="line">......</span><br><span class="line">你取了200.0元，卡里还剩-2000.0元。</span><br><span class="line">你妈存了200.0元，卡里还剩-1800.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩-1600.0元。</span><br></pre></td></tr></table></figure>

<p>不仅余额负数，程序也并没有结束而进入永久等待的状态。</p>
<p>出现余额负数的原因是当“你”，“你妹”两个取钱线程都因为flag为false而进入等待队列时，然后“你妹”被存钱线程所唤醒，此时余额为200，被唤醒的“你妹”继续取钱，此时余额为0，然后唤醒“你”，<strong>注意</strong>，“你”被唤醒后接着从wait语句之后往下执行取钱操作，此时余额为-200。问题就出在“你”这里，“你”被唤醒后是继续往下执行的，并没有重新判断flag，解决办法很简单，将<mark>if改为while</mark>就可以了，如果flag为false被唤醒的你就会接着等待：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">你爸存了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">200</span>.<span class="number">0</span>元。</span><br><span class="line">你取了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">0</span>.<span class="number">0</span>元。</span><br><span class="line">你妈存了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">200</span>.<span class="number">0</span>元。</span><br><span class="line">你取了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">0</span>.<span class="number">0</span>元。</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>notify和notifyAll</strong></p>
<p>余额负数的问题解决了，但是程序陷入永久等待的问题还没解决，分析下原因：</p>
</li>
</ul>
<ol>
<li><strong>你爸存钱成功</strong>，flag为true，<strong>余额200</strong>；</li>
<li>你妈存钱失败，进入等待队列； (你妈)</li>
<li>你爸存钱失败，进入等待队列； (你妈，你爸)</li>
<li><strong>你取钱成功</strong>，flag为false，唤醒你妈，<strong>余额为0</strong>； (你爸)</li>
<li>你妹取钱失败，进入等待队列； (你爸，你妹)</li>
<li>你取钱失败，进入等待队列； (你爸，你妹，你)</li>
<li><strong>你妈存钱成功</strong>，flag为true，唤醒你，<strong>余额为200</strong>； (你爸，你妹)</li>
<li>你妈存钱失败，进入等待队列； (你爸，你妹，你妈)</li>
<li><strong>你取钱成功</strong>，flag为false，唤醒你妹，<strong>余额为0</strong>； (你爸，你妈)</li>
<li>你妹取钱失败，进入等待队列； (你爸，你妈，你妹)</li>
<li>你取钱失败，进入等待队列； (你爸，你妈，你妹，你)</li>
</ol>
<p>至此四个线程全部进入等待状态，在没有别的线程将其唤醒的情况下将陷入无限期等待。原因出在第9步，如果取钱线程“你”唤醒的是存钱线程，那么程序就会正常执行。修改方式也很简单，将代码中notify方法改成notifyAll就可以了，一次唤醒所有线程。结果正常运行不再演示，这里说这么多主要是体会线程同步的一个过程。</p>
<h3 id="经典问题-生产者消费者"><a href="#经典问题-生产者消费者" class="headerlink" title="经典问题 (生产者消费者)"></a>经典问题 (生产者消费者)</h3><p>若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个能存储多个产品的缓冲区，生产者将生产的产品放入缓冲区中，消费者从缓冲区取走产品进行消费，显然生产者和消费者之间必须保持<strong>同步</strong>，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个满的缓冲区中放入产品。</p>
<p>这个例子和上一节的案例差不多，理解了上一节的案例这个问题就能解决，以下是演示代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductBuf &#123;</span><br><span class="line">    &#x2F;&#x2F;产品仓库 (缓冲区)</span><br><span class="line">    String[] products&#x3D;new String[6];</span><br><span class="line">    &#x2F;&#x2F;下标从-1开始，往0到5位置放产品</span><br><span class="line">    int index&#x3D;-1;</span><br><span class="line">    &#x2F;&#x2F;生产者生产</span><br><span class="line">    public synchronized void Productor() &#123;</span><br><span class="line">        while(index&gt;&#x3D;5) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;仓库已满，等待</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;放入产品</span><br><span class="line">        products[++index]&#x3D;&quot;product&quot;;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;生产了一个产品，产品数量：&quot;+(index+1));</span><br><span class="line">        System.out.println(Arrays.toString(products));</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;消费者消费</span><br><span class="line">    public synchronized void Consumer() &#123;</span><br><span class="line">        while (index&lt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;仓库已空，等待</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;取出产品</span><br><span class="line">        products[index--]&#x3D;null;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;消费了一个产品，产品数量：&quot;+(index+1));</span><br><span class="line">        System.out.println(Arrays.toString(products));</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Productor implements Runnable&#123;</span><br><span class="line">    ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">    public Productor() &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    public Productor(ProductBuf productBuf) &#123;</span><br><span class="line">        this.productBuf&#x3D;productBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;生产30个产品</span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++) &#123;</span><br><span class="line">            productBuf.Productor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line">    ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">    public Consumer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Consumer(ProductBuf productBuf) &#123;</span><br><span class="line">        this.productBuf&#x3D;productBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;消费30个产品</span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++) &#123;</span><br><span class="line">            productBuf.Consumer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">        Productor productor&#x3D;new Productor(productBuf);</span><br><span class="line">        Consumer consumer&#x3D;new Consumer(productBuf);</span><br><span class="line">        new Thread(productor,&quot;生产者1号&quot;).start();</span><br><span class="line">        new Thread(productor,&quot;生产者2号&quot;).start();</span><br><span class="line">        new Thread(consumer,&quot;消费者1号&quot;).start();</span><br><span class="line">        new Thread(consumer,&quot;消费者2号&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示，没有问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者1号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者1号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：2</span><br><span class="line">[product, product, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：3</span><br><span class="line">[product, product, product, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：4</span><br><span class="line">[product, product, product, product, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：5</span><br><span class="line">[product, product, product, product, product, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：6</span><br><span class="line">[product, product, product, product, product, product]</span><br><span class="line">消费者2号消费了一个产品，产品数量：5</span><br><span class="line">[product, product, product, product, product, null]</span><br><span class="line">......</span><br><span class="line">消费者2号消费了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者2号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者2号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h3><p>首先有关线程的使用会出现两个问题：</p>
<ol>
<li>线程是宝贵的内存资源、单个线程约占1MB空间，过多分配易造成内存溢出。</li>
<li>频繁的创建及销毁线程会增加虚拟机回收频率、资源开销，造成性能下降。</li>
</ol>
<p>基于如上的问题，出现了线程池：</p>
<ul>
<li><strong>线程容器</strong>，<strong>可设定线程分配的数量</strong>。</li>
<li><strong>将预先创建的线程对象存入池中</strong>，<strong>并重用线程池中的线程对象</strong>。</li>
<li><strong>避免频繁的创建和销毁</strong>。</li>
</ul>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>假如线程池里固定有三个线程，有四个任务。线程池中的三个线程分别完成三个任务，第四个任务则进入等待状态，线程执行完前三个任务后继续执行第四个任务。</p>
<p><img src="https://pic.downk.cc/item/5fa5382b1cd1bbb86bb07912.png" alt="img"></p>
<ul>
<li>将任务提交给线程池，由线程池分配线程、运行任务，并在当前任务结束后复用线程。</li>
</ul>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul>
<li><p>常用的线程池接口的类 (所在包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.concurrent</span><br></pre></td></tr></table></figure>

<p>)</p>
<ul>
<li><p><strong>Executor</strong>：线程池的顶级接口。</p>
</li>
<li><p><strong>ExecutorService</strong>：线程池接口，可通过<code>submit(Runnable task)</code>提交任务代码。</p>
</li>
<li><p>Executors</p>
<p>工厂类：创建线程池的工具类。</p>
<ol>
<li>创建固定线程个数的线程池。</li>
<li>创建缓存线程池，由任务的多少决定。</li>
<li>创建单线程池。</li>
<li>创建调度线程池。调度：周期、定时执行。</li>
</ol>
</li>
<li><p>通过<code>newFixedThreadPool(int nThreads)</code>获得固定数量的线程池。参数：指定线程池中线程的数量。</p>
</li>
<li><p>通过<code>newCachedThreadPool()</code>获得动态数量的线程池，如不够则创建新的，没有上限。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示线程池的创建 (结果同银行卡案例，不再演示)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        &#x2F;&#x2F;银行卡案例</span><br><span class="line">        BandCard bandCard&#x3D;new BandCard();</span><br><span class="line">        AddMoney addMoney&#x3D;new AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney&#x3D;new SubMoney(bandCard);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;1.1创建固定线程个数的线程池</span><br><span class="line">        &#x2F;&#x2F;ExecutorService executorService&#x3D;Executors.newFixedThreadPool(4);</span><br><span class="line">        &#x2F;&#x2F;1.2创建缓存线程池，线程个数由任务个数决定</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F;1.3创建单线程线程池</span><br><span class="line">        &#x2F;&#x2F;Executors.newSingleThreadExecutor();</span><br><span class="line">        &#x2F;&#x2F;1.4创建调度线程池</span><br><span class="line">        &#x2F;&#x2F;Executors.newScheduledThreadPool(corePoolSize);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务</span><br><span class="line">        executorService.submit(addMoney);</span><br><span class="line">        executorService.submit(subMoney);</span><br><span class="line">        executorService.submit(addMoney);</span><br><span class="line">        executorService.submit(subMoney);</span><br><span class="line">        &#x2F;&#x2F;等待所有已执行的任务执行完毕后关闭线程池，不再接受新任务</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        &#x2F;&#x2F;会试图停止所有正在执行的任务</span><br><span class="line">        &#x2F;&#x2F;executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt;&#123;</span><br><span class="line">    public V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JDK1.5加入，与Runnable接口类似，实现之后代表一个线程任务。</li>
<li>Callable具有泛型返回值、可以声明异常。</li>
</ul>
<p><strong>与Runnable接口的区别</strong>：</p>
<ol>
<li>Callable接口中call方法有返回值，Runnable接口中run方法没有返回值。</li>
<li>Callable接口中call方法有声明异常，Runnable接口中run方法没有异常。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示Callable接口的使用</span><br><span class="line"> * 功能需求：使用Callable实现1-100的和。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建Callable对象</span><br><span class="line">        Callable&lt;Integer&gt; callable&#x3D;new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            private int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;2.Thread的构造方法中没有带Callable的构造方法</span><br><span class="line">        &#x2F;&#x2F;需要把Callable对象转成可执行任务，FutureTask表示将要执行的任务</span><br><span class="line">        &#x2F;&#x2F;该类实现了RunnableFuture&lt;V&gt;接口，而该接口又继承了Runnable类</span><br><span class="line">        FutureTask&lt;Integer&gt; task&#x3D;new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;3.创建线程对象</span><br><span class="line">        Thread thread&#x3D;new Thread(task);</span><br><span class="line">        &#x2F;&#x2F;4.启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        &#x2F;&#x2F;5.获取结果 (等待call方法执行完毕，才会返回)</span><br><span class="line">        Integer sum&#x3D;task.get();</span><br><span class="line">        System.out.println(&quot;结果是&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable结合线程池使用"><a href="#Callable结合线程池使用" class="headerlink" title="Callable结合线程池使用"></a>Callable结合线程池使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用线程池计算1-100的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newFixedThreadPool(1);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务,Future表示将要执行任务的结果；</span><br><span class="line">        &#x2F;&#x2F;submit可以传入一个Callable&lt;T&gt;对象</span><br><span class="line">        Future&lt;Integer&gt; future&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            private int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;开始计算。。&quot;);</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;3.获取任务的结果 (等待任务完成才会返回)</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        &#x2F;&#x2F;4.关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><ul>
<li><strong>Future</strong>：<strong>表示将要完成任务的结果</strong>。</li>
</ul>
<p>演示一个案例：使用两个线程，并发计算1-50、51-100的和，再进行汇总统计。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示Future接口的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newFixedThreadPool(2);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务</span><br><span class="line">        Future&lt;Integer&gt; future1&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            &#x2F;&#x2F;计算1-50的和</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;50;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;1-50的和计算完毕。&quot;);</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; future2&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            &#x2F;&#x2F;计算51-100的和</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;51;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;51-100的和计算完毕。&quot;);</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;3.获取结果</span><br><span class="line">        System.out.println(future1.get()+future2.get());</span><br><span class="line">        &#x2F;&#x2F;4.关系线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>表示</strong><code>ExecutorService.submit()</code><strong>所返回的状态结果</strong>，<strong>就是call的返回值</strong>。</li>
<li><strong>方法</strong><code>V get()</code><strong>以阻塞形式等待Future中的异步处理结果</strong> (<strong>call的返回值</strong>)。</li>
</ul>
<h3 id="线程的同步与异步"><a href="#线程的同步与异步" class="headerlink" title="线程的同步与异步"></a>线程的同步与异步</h3><ul>
<li><p><strong>同步</strong></p>
<p>形容一次方法调用，同步一旦开始，调用者必须等待该方法返回，才能继续。</p>
<p>当主线程调用子线程执行任务时，必须等到子线程返回结果后才能继续。</p>
</li>
<li><p><strong>异步</strong></p>
<p>形容一次方法调用，异步一旦开始就像是一次消息传递，调用者告知之后立刻返回。二者竞争时间片，并发执行。<strong>异步有多条执行路径</strong>。</p>
</li>
</ul>
<p><img src="https://pic.downk.cc/item/5fa610c41cd1bbb86bd6d0d9.png" alt="img"></p>
<hr>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><ul>
<li>JDK1.5加入，与synchronized比较，不仅显示定义，而且结构更灵活。</li>
<li>提供了更多实用性方法，功能更强大、性能更优越。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><p><code>void lock</code></p>
<p>获取锁，如果锁被占用，当前线程则进入等待状态。</p>
</li>
<li><p><code>boolean tryLock()</code></p>
<p>尝试获取锁 (成功返回true，失败返回false，不阻塞)</p>
</li>
<li><p><code>void unlock()</code></p>
<p>释放锁。</p>
</li>
</ul>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><ul>
<li><p>ReentrantLock： Lock接口的<strong>实现类</strong>，与synchronized一样具有互斥锁功能。</p>
<p>所谓重入锁，<strong>是指一个线程拿到该锁后</strong>，<strong>还可以再次成功获取</strong>，而不会因为该锁已经被持有 (尽管是自己所持有)而陷入等待状态 (死锁)。<strong>之前说过的synchronized也是可重入锁</strong>。</p>
</li>
</ul>
<h4 id="可重入锁解释及应用"><a href="#可重入锁解释及应用" class="headerlink" title="可重入锁解释及应用"></a>可重入锁解释及应用</h4><p>为了具体解释什么叫可重入锁，这里重写5.4节死锁关于两个人拿筷子吃饭的案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Chopsticks &#123;</span><br><span class="line">    boolean getOne&#x3D;false;</span><br><span class="line">    boolean getAnother&#x3D;false;</span><br><span class="line">    &#x2F;&#x2F;拿筷子，获取锁，该锁是当前Chopsticks对象</span><br><span class="line">    public synchronized void getOne() &#123;</span><br><span class="line">        getOne&#x3D;true;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;拿到了一根筷子。&quot;);</span><br><span class="line">        &#x2F;&#x2F;if语句块调用了另外的同步方法，需要再次获取锁，而该锁也是当前Chopsticks对象</span><br><span class="line">        if(getAnother) &#123;</span><br><span class="line">            &#x2F;&#x2F;有两根筷子，吃饭</span><br><span class="line">            canEat();</span><br><span class="line">            &#x2F;&#x2F;吃完放下两根筷子</span><br><span class="line">            getOne&#x3D;false;</span><br><span class="line">            getAnother&#x3D;false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;只有一根筷子，去拿另一根，然后吃饭</span><br><span class="line">            getAnother();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void getAnother() &#123;</span><br><span class="line">        getAnother&#x3D;true;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;拿到了一根筷子。&quot;);</span><br><span class="line">        if(getOne) &#123;</span><br><span class="line">            &#x2F;&#x2F;有两根筷子，吃饭</span><br><span class="line">            canEat();</span><br><span class="line">            &#x2F;&#x2F;吃完放下两根筷子</span><br><span class="line">            getOne&#x3D;false;</span><br><span class="line">            getAnother&#x3D;false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;只有一根筷子，去拿另一根，然后吃饭</span><br><span class="line">            getOne();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void canEat() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;拿到了两根筷子，开恰！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个筷子类中，拿第一根筷子的时候获取了一把锁，锁对象是this，也就是当前Chopsticks对象；拿第二根筷子的时候又获取了一次锁，锁对象是this，也是当前Chopsticks对象。测试类如下，说明在后面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class testChopstick &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Chopsticks chopsticks&#x3D;new Chopsticks();</span><br><span class="line">        &#x2F;&#x2F;线程A,模拟人A</span><br><span class="line">        Thread A&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                chopsticks.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;线程B，模拟人B</span><br><span class="line">        Thread B&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                chopsticks.getAnother();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程都执行的是<strong>同一个对象</strong>chopsticks中的方法，这两个同步方法在执行时将会<strong>获取同样的锁</strong>；当线程1抢到CUP进入getOne时获取锁然后执行代码，如果线程1<strong>还未</strong>执行完毕就被线程2抢占了CPU，当线程2进入getAnother时发现锁在线程1那里，<strong>于是线程2等待</strong>；线程1重新拿到CPU继续执行代码，进入getAnother方法获取锁，<strong>发现锁就在自己这里</strong>，<strong>于是继续执行</strong>，<strong>这就是可重入锁</strong>。可重入锁避免了死锁的发生，避免线程因获取不了锁而进入永久等待状态。</p>
<p>上述代码运行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0拿到了一根筷子。</span><br><span class="line">Thread-0拿到了一根筷子。</span><br><span class="line">Thread-0拿到了两根筷子，开恰！</span><br><span class="line">Thread-1拿到了一根筷子。</span><br><span class="line">Thread-1拿到了一根筷子。</span><br><span class="line">Thread-1拿到了两根筷子，开恰！</span><br></pre></td></tr></table></figure>

<h4 id="重入锁的使用"><a href="#重入锁的使用" class="headerlink" title="重入锁的使用"></a>重入锁的使用</h4><p>还是以2.5节卖票案例为例进行演示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重入锁的使用</span><br><span class="line">public class Ticket implements Runnable&#123;</span><br><span class="line">    int ticket&#x3D;100;</span><br><span class="line">    &#x2F;&#x2F;创建重入锁对象</span><br><span class="line">    Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;    </span><br><span class="line">        while(true) &#123;    </span><br><span class="line">            &#x2F;&#x2F;上锁        </span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;                    </span><br><span class="line">                if(ticket&gt;0)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;卖出了一张票，还剩&quot;+(--ticket)+&quot;张。&quot;);</span><br><span class="line">                else break;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F;解锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要注意一下上锁后记得解锁，有几个lock就要有对应的几个unlock。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class testTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket&#x3D;new Ticket();</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(4);</span><br><span class="line">        &#x2F;&#x2F;2.提交四次，让四个线程来运行</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++) &#123;</span><br><span class="line">            eService.submit(new Ticket());</span><br><span class="line">        &#125;</span><br><span class="line">        eService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果不再演示。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>ReentrantReadWriteLock：</p>
<ul>
<li>一种支持一写多读的同步锁，读写分离，可以分别分配读锁和写锁。</li>
<li>支持多次分配读锁，使多个读操作可以并发执行。</li>
</ul>
<p>互斥规则：</p>
<ul>
<li>写—-写：互斥，一个线程在写的同时其他线程会被阻塞。</li>
<li>读—-写：互斥，读的时候不能写，写的时候不能读。</li>
<li>读—-读：不互斥、不阻塞。</li>
<li>在读操作远远高于写操作的环境中，可在保证线程安全的情况下，提高运行效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;演示读写锁的使用</span><br><span class="line">public class ReadWriteLock &#123;</span><br><span class="line">        &#x2F;&#x2F;创建读写锁对象</span><br><span class="line">        ReentrantReadWriteLock rrlLock&#x3D;new ReentrantReadWriteLock();</span><br><span class="line">        ReadLock readLock&#x3D;rrlLock.readLock();&#x2F;&#x2F;获得读锁</span><br><span class="line">        WriteLock writeLock&#x3D;rrlLock.writeLock();&#x2F;&#x2F;获得写锁</span><br><span class="line">        private int value&#x3D;999;</span><br><span class="line">        &#x2F;&#x2F;读方法</span><br><span class="line">        public int getValue() &#123;</span><br><span class="line">            readLock.lock();&#x2F;&#x2F;开启读锁</span><br><span class="line">            try &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return this.value;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                readLock.unlock();&#x2F;&#x2F;释放读锁</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;写方法</span><br><span class="line">        public void setValue(int value) &#123;</span><br><span class="line">            writeLock.lock();&#x2F;&#x2F;开启写锁</span><br><span class="line">            try &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                this.value&#x3D;value;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                writeLock.unlock();&#x2F;&#x2F;释放写锁</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testReadWriteLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(20);</span><br><span class="line">        ReadWriteLock rwlLock&#x3D;new ReadWriteLock();</span><br><span class="line">        Runnable read&#x3D;new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(rwlLock.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write&#x3D;new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                rwlLock.setValue(666);</span><br><span class="line">                System.out.println(&quot;改写为666&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;写2次</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++) &#123;</span><br><span class="line">            eService.submit(write);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读18次</span><br><span class="line">        for(int i&#x3D;0;i&lt;18;i++) &#123;</span><br><span class="line">            eService.submit(read);</span><br><span class="line">        &#125;    </span><br><span class="line">        eService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用sleep可以观察到，只有在读写交替和两个写操作的时候程序是互斥执行，而在读操作时线程之间是并发执行。</p>
<hr>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>下图中蓝色的表示线程安全的集合，绿色表示现代开发中已经很少使用的线程安全的集合。</p>
<ul>
<li><p>Collection体系集合</p>
</li>
<li><p>Map安全集合体系</p>
</li>
</ul>
<p><strong>在多线程中使用线程不安全的集合会出现异常</strong>。在JDK1.5之前，可以使用Collections中的工具类方法。</p>
<p>Collections工具类中提供了多个可以获得线程安全集合的方法：</p>
<ul>
<li><code>public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></li>
<li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li><code>public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
<li><code>public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></li>
<li><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt;)</code></li>
</ul>
<p>以上为JDK1.2提供，接口单一、维护性高，但性能没有提升，均以synchronized实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.使用ArrayList (不经过2步骤则报异常)</span><br><span class="line">        ArrayList&lt;String&gt; arrayList&#x3D;new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2 使用Collections中的线程安全方法转成线程安全的集合</span><br><span class="line">        List&lt;String&gt; synList&#x3D;Collections.synchronizedList(arrayList);</span><br><span class="line">        &#x2F;&#x2F;3 使用并发包里提供的集合</span><br><span class="line">        &#x2F;&#x2F;OnWriteArrayList&lt;String&gt; arrayList2&#x3D;new OnWriteArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;20;i++) &#123;</span><br><span class="line">            int temp&#x3D;i;</span><br><span class="line">            new Thread(new Runnable() &#123;            </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;10;j++) &#123;</span><br><span class="line">                        synList.add(Thread.currentThread().getName()+&quot;:&quot;+temp);</span><br><span class="line">                        System.out.println(synList.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把ArrayList转成线程安全的集合后程序正常运行，结果不再演示。</p>
<h3 id="OnWriteArrayList集合"><a href="#OnWriteArrayList集合" class="headerlink" title="OnWriteArrayList集合"></a>OnWriteArrayList集合</h3><ul>
<li>线程安全的ArrayList，加强版的读写分离。</li>
<li>写有锁，读无锁，读写之间不堵塞，优于读写锁。</li>
<li>写入时，先一个容器副本、再添加新元素，最后替换引用。所以说它是用空间换安全的一种方式。</li>
<li>使用ArrayList无异。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示OnWriteArrayList的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建集合</span><br><span class="line">        OnWriteArrayList&lt;String&gt; list&#x3D;new OnWriteArrayList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F;2.使用多线程操作</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(5);</span><br><span class="line">        &#x2F;&#x2F;3.提交任务</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++) &#123;</span><br><span class="line">            eService.submit(new Runnable() &#123;            </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;10;j++) &#123;</span><br><span class="line">                        list.add(Thread.currentThread().getName()+&quot;...&quot;+new Random().nextInt(1000));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;4.关闭线程池</span><br><span class="line">        eService.shutdown();</span><br><span class="line">        &#x2F;&#x2F;等所有线程都执行完毕</span><br><span class="line">        while(!eService.isTerminated());</span><br><span class="line">        &#x2F;&#x2F;5.打印结果</span><br><span class="line">        System.out.println(&quot;元素个数：&quot;+list.size());</span><br><span class="line">        for (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，没有问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素个数：50</span><br><span class="line">pool-1-thread-2...222</span><br><span class="line">pool-1-thread-2...688</span><br><span class="line">pool-1-thread-2...770</span><br><span class="line">    ......</span><br><span class="line">pool-1-thread-4...568</span><br><span class="line">pool-1-thread-4...537</span><br><span class="line">pool-1-thread-4...413</span><br></pre></td></tr></table></figure>

<h3 id="OnWriteArrayList源码分析"><a href="#OnWriteArrayList源码分析" class="headerlink" title="OnWriteArrayList源码分析"></a>OnWriteArrayList源码分析</h3><ul>
<li><p><code>final transient ReentrantLock lock = new ReentrantLock();</code></p>
<p>此集合所使用的的锁lock是重入锁ReentrantLock。</p>
</li>
<li><p><code>private transient volatile Object[] array;</code></p>
<p>此集合实际存储的数组array。</p>
</li>
<li><p>在上节中调用的无参构造方法创建的是一个空的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public OnWriteArrayList() &#123;</span><br><span class="line">    setArray(new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void setArray(Object[] a) &#123;</span><br><span class="line">    array &#x3D; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>add(E)</code>添加元素是先把原来的数组到一个长度减1的新数组里，然后对新数组进行操作，最后再把新数组赋给原数组。这个操作上了锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        Object[] newElements &#x3D; Arrays.Of(elements, len + 1);</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove(int)</code>删除元素同样是复制原数组到一个长度加1的新数组里，然后对新数组进行操作，最后再把新数组赋给原数组。这个操作也上了锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        E oldValue &#x3D; get(elements, index);</span><br><span class="line">        int numMoved &#x3D; len - index - 1;</span><br><span class="line">        if (numMoved &#x3D;&#x3D; 0)</span><br><span class="line">            setArray(Arrays.Of(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">            System.array(elements, 0, newElements, 0, index);</span><br><span class="line">            System.array(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关数组修改的操作都上了锁，也就说写操作是互斥访问的。</p>
<p>有关读操作的代码都是直接进行了访问，没有上锁，也就是说在写的同时可以读。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="OnWriteArraySet集合"><a href="#OnWriteArraySet集合" class="headerlink" title="OnWriteArraySet集合"></a>OnWriteArraySet集合</h3><ul>
<li><p>线程安全的Set，底层使用OnWriteArrayList实现。</p>
</li>
<li><p>唯一不同在于，使用<code>addIfAbsent()</code>添加元素，会遍历数组，如果已有元素 (比较依据是equals)，则不添加 (扔掉副本)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;演示OnWriteArraySet的使用</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OnWriteArraySet&lt;String&gt; set&#x3D;new OnWriteArraySet&lt;String&gt;();</span><br><span class="line">        set.add(&quot;tang&quot;);</span><br><span class="line">        set.add(&quot;he&quot;);</span><br><span class="line">        set.add(&quot;yu&quot;);</span><br><span class="line">        set.add(&quot;wang&quot;);</span><br><span class="line">        set.add(&quot;tang&quot;);&#x2F;&#x2F;重复元素，添加失败</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个set集合是顺序输出的，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">[tang, he, yu, wang]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="OnWriteArraySet源码分析"><a href="#OnWriteArraySet源码分析" class="headerlink" title="OnWriteArraySet源码分析"></a>OnWriteArraySet源码分析</h3><ul>
<li><p><code>private final OnWriteArrayList&lt;E&gt; al</code></p>
<p>这个集合实际上使用的就是OnWriteArrayList集合。</p>
</li>
<li><p>它的无参构造方法new的就是OnWriteArrayList对象，所以它是有序的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public OnWriteArraySet() &#123;</span><br><span class="line">    al &#x3D; new OnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素的操作和OnWriteArrayList大同小异。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean addIfAbsent(E e) &#123;</span><br><span class="line">    Object[] snapshot &#x3D; getArray();</span><br><span class="line">    return indexOf(e, snapshot, 0, snapshot.length) &gt;&#x3D; 0 ? false :</span><br><span class="line">    addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个三元表达式，意思是存在相同元素返回false，否则添加元素。</p>
<p>先进入indexOf方法查看源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int indexOf(Object o, Object[] elements,</span><br><span class="line">                           int index, int fence) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; index; i &lt; fence; i++)</span><br><span class="line">            if (elements[i] &#x3D;&#x3D; null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; index; i &lt; fence; i++)</span><br><span class="line">            if (o.equals(elements[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是添加单个元素，index参数就是0，这个方法就是在遍历数组，如果数组中已经存在相同元素则返回数组下标，注意看它的比较依据是equals方法；如果不存在则返回-1。</p>
<p>在<code>addIfAbsent</code>所返回的三元表达式中，如果indexOf方法返回数组下标，则返回false，表示已经存在相同元素，添加失败；否则返回-1执行<code>addIfAbsent(e, snapshot)</code>，进入该方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] current &#x3D; getArray();</span><br><span class="line">        int len &#x3D; current.length;</span><br><span class="line">        if (snapshot !&#x3D; current) &#123;</span><br><span class="line">            &#x2F;&#x2F; Optimize for lost race to another addXXX operation</span><br><span class="line">            int common &#x3D; Math.min(snapshot.length, len);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; common; i++)</span><br><span class="line">                if (current[i] !&#x3D; snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    return false;</span><br><span class="line">            if (indexOf(e, current, common, len) &gt;&#x3D; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements &#x3D; Arrays.Of(current, len + 1);</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以忽略if语句，重点关注它的添加操作，发现它也将原数组到长度加一的新数组中，再对新数组进行操作，这个写操作上了锁。其他的写方法都调用了OnWriteArrayList的方法，同样是写操作上锁，读操作可以同时执行。</p>
</li>
</ul>
<h2 id="Queue接口-队列"><a href="#Queue接口-队列" class="headerlink" title="Queue接口 (队列)"></a>Queue接口 (队列)</h2><p>Collection的子接口，表示队列FIFO (First In First Out)，先进先出。</p>
<p>常用方法：</p>
<ul>
<li><p>抛出异常：</p>
<ul>
<li><p><code>boolean add(E e)</code></p>
<p>顺序添加一个元素 (到达上限后，再添加则会抛出异常)。</p>
</li>
<li><p><code>E remove()</code></p>
<p>获得第一个元素并移除 (如果队列没有元素时，则抛出异常)。</p>
</li>
<li><p><code>E element()</code></p>
<p>获得第一个元素但不移除 (如果队列没有元素时，则抛异常)。</p>
</li>
</ul>
</li>
<li><p>返回特殊值： (<strong>建议使用以下方法</strong>)</p>
<ul>
<li><p><code>boolean offer(E e)</code></p>
<p>顺序添加一个元素 (到达上限后，再添加则会返回false)。</p>
</li>
<li><p><code>E poll()</code></p>
<p>获得第一个元素并移除 (如果队列没有元素时，则返回null)。</p>
</li>
<li><p><code>E peek()</code></p>
<p>获得第一个元素但不移除 (如果队列没有元素时，则返回null)。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;演示Queue实现类的使用</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建队列</span><br><span class="line">        Queue&lt;String&gt; queue&#x3D;new LinkedList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F;入队</span><br><span class="line">        queue.offer(&quot;tang&quot;);</span><br><span class="line">        queue.offer(&quot;he&quot;);</span><br><span class="line">        queue.offer(&quot;yu&quot;);</span><br><span class="line">        queue.offer(&quot;wang&quot;);</span><br><span class="line">        queue.offer(&quot;fan&quot;);</span><br><span class="line">        System.out.println(&quot;队首元素：&quot;+queue.peek());</span><br><span class="line">        System.out.println(&quot;元素个数：&quot;+queue.size());</span><br><span class="line">        &#x2F;&#x2F;出队</span><br><span class="line">        int size&#x3D;queue.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;size;i++) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;出队完毕：&quot;+queue.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是因为LinkedList是线程不安全的集合，所以不能在多线程的环境中使用。该程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队首元素：tang</span><br><span class="line">元素个数：5</span><br><span class="line">tang</span><br><span class="line">he</span><br><span class="line">yu</span><br><span class="line">wang</span><br><span class="line">fan</span><br><span class="line">出队完毕：0</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentLinkedQueue类"><a href="#ConcurrentLinkedQueue类" class="headerlink" title="ConcurrentLinkedQueue类"></a>ConcurrentLinkedQueue类</h3><ul>
<li><p>Queue接口的实现类。线程安全、可高效读写的队列，高并发下性能最好的队列。</p>
</li>
<li><p>无锁、CAS (Compare and Swap)比较交换算法，修改的方法包含三个核心参数 (V,E,N)。</p>
</li>
<li><p>V：要更新的变量；E：预期值；N：新值。</p>
</li>
<li><p>只有当V==E，V=N；否则表示V已被更新过，则取消当前操作。</p>
<p>也就是说假如当前值V是80，要将其改成100，先将V读取出来，读取的V就是预期值；如果预期值E和V相等，就把V的值更新成新值100；如果不等，说明中间有其他线程更新了V，就取消当前操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;演示线程安全的队列</span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建安全队列</span><br><span class="line">        ConcurrentLinkedQueue&lt;Integer&gt; queue&#x3D;new ConcurrentLinkedQueue&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;两个线程执行入队操作</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;5;i++) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;6;i&lt;&#x3D;10;i++) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;启动线程</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;10;i++) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是两个线程同时添加，所以结果不是顺序的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue接口-阻塞队列"><a href="#BlockingQueue接口-阻塞队列" class="headerlink" title="BlockingQueue接口 (阻塞队列)"></a>BlockingQueue接口 (阻塞队列)</h3><ul>
<li><p><strong>Queue的子接口</strong>，阻塞的队列，增加了两个线程状态为无限期等待的方法。</p>
</li>
<li><p>方法</p>
<ul>
<li><p><code>void put(E e)</code></p>
<p>将指定元素插入此队列中，如果没有可用空间，则等待。</p>
</li>
<li><p><code>E take()</code></p>
<p>获取并移除此队列头部元素，如果没有可用元素，则等待。</p>
</li>
</ul>
</li>
<li><p><strong>可用于解决生产者</strong>、<strong>消费者问题</strong>。</p>
</li>
</ul>
<h4 id="阻塞队列-实现类"><a href="#阻塞队列-实现类" class="headerlink" title="阻塞队列 (实现类)"></a>阻塞队列 (实现类)</h4><ul>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组结构实现，有界队列。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链表结构实现，有界队列。默认上限<code>Integer.MAX_VALUE</code>。</p>
</li>
</ul>
<p>通过一个小程序演示一下所谓的阻塞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个有界队列</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue&#x3D;new ArrayBlockingQueue&lt;Integer&gt;(3);</span><br><span class="line">        &#x2F;&#x2F;添加数据使用put</span><br><span class="line">        arrayBlockingQueue.put(1);</span><br><span class="line">        arrayBlockingQueue.put(2);</span><br><span class="line">        arrayBlockingQueue.put(3);</span><br><span class="line">        System.out.println(arrayBlockingQueue.size());</span><br><span class="line">        System.out.println(arrayBlockingQueue.toString());</span><br><span class="line">        arrayBlockingQueue.put(4);</span><br><span class="line">        System.out.println(&quot;我不会被执行。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序执行后可以通过控制台看见程序并没有结束，也没有打印最后一句话，说明当前线程 (主线程)被阻塞了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="重写生产者消费者问题"><a href="#重写生产者消费者问题" class="headerlink" title="重写生产者消费者问题"></a>重写生产者消费者问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建队列</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue&#x3D;new ArrayBlockingQueue&lt;Integer&gt;(6);</span><br><span class="line">        &#x2F;&#x2F;创建两个线程</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;30;i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(i);</span><br><span class="line">                        System.out.println(&quot;生产者生产了一个产品，产品ID：&quot;+i);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;30;i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者消费了一个产品，产品ID：&quot;+i);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是插入队尾的方法是put，删除队首元素的方法是take。结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者生产了一个产品，产品ID：1</span><br><span class="line">生产者生产了一个产品，产品ID：2</span><br><span class="line">生产者生产了一个产品，产品ID：3</span><br><span class="line">生产者生产了一个产品，产品ID：4</span><br><span class="line">生产者生产了一个产品，产品ID：5</span><br><span class="line">生产者生产了一个产品，产品ID：6</span><br><span class="line">消费者消费了一个产品，产品ID：1</span><br><span class="line">    ......</span><br><span class="line">消费者消费了一个产品，产品ID：25</span><br><span class="line">消费者消费了一个产品，产品ID：26</span><br><span class="line">消费者消费了一个产品，产品ID：27</span><br><span class="line">消费者消费了一个产品，产品ID：28</span><br><span class="line">消费者消费了一个产品，产品ID：29</span><br><span class="line">消费者消费了一个产品，产品ID：30</span><br></pre></td></tr></table></figure>

<h2 id="10-ConcurrentHashMap"><a href="#10-ConcurrentHashMap" class="headerlink" title="10. ConcurrentHashMap"></a>10. ConcurrentHashMap</h2><ul>
<li>初始容量默认为16段 (Segment)，使用分段锁设计。每一段都对应着一个哈希表。</li>
<li>不对整个Map加锁，而是为每个Segment加锁。对一个Segment的操作不影响其他Segment。</li>
<li>当多个对象存入同一个Segment时，才需要互斥。</li>
<li>最理想状态为16个对象分别存入16个Segment，并行数量16。</li>
<li>使用方式与HashMap无异。</li>
</ul>
<p>注：在JDK1.8之后，ConcurrentHashMap不再采用分段锁，而是采用无锁算法CAS。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;演示线程安全的Map</span><br><span class="line">public class Demo8 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建集合</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; hashMap&#x3D;new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;使用多线程添加数据</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;                </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int k&#x3D;0;k&lt;10;k++) &#123;</span><br><span class="line">                        hashMap.put(Thread.currentThread().getName(), k);</span><br><span class="line">                        System.out.println(hashMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有问题，不再演示结果。</p>
<p>这篇博客真的好长，但想着分成几篇又不方便回顾。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021-03-Spring/</url>
    <content><![CDATA[<blockquote>
<p>简介</p>
</blockquote>
<p>Spring : 春天 —&gt;给软件行业带来了春天</p>
<p>2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。</p>
<p>2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。</p>
<p>很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</p>
<p>Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术</p>
<p>官网 : <span class="exturl" data-url="aHR0cDovL3NwcmluZy5pby8=">http://spring.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>官方下载地址 : <span class="exturl" data-url="aHR0cHM6Ly9yZXBvLnNwcmluZy5pby9saWJzLXJlbGVhc2UtbG9jYWwvb3JnL3NwcmluZ2ZyYW1ld29yay9zcHJpbmcv">https://repo.spring.io/libs-release-local/org/springframework/spring/<i class="fa fa-external-link-alt"></i></span></p>
<p>GitHub : <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1wcm9qZWN0cw==">https://github.com/spring-projects<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<blockquote>
<p>优点</p>
</blockquote>
<p>1、Spring是一个开源免费的框架 , 容器  .</p>
<p>2、Spring是一个轻量级的框架 , 非侵入式的 .</p>
<p><strong>3、控制反转 IoC  , 面向切面 Aop</strong></p>
<p>4、对事物的支持 , 对框架的支持</p>
<p>…….</p>
<p>一句话概括：</p>
<p><strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p>
<p><strong>个人理解 Spring原理</strong></p>
<ul>
<li>IOC  控制反转<ul>
<li>方式1 通过xml文件配置beans，然后通过反射（反序列化）获取对象</li>
<li>方式2 通过注解注册beans ，也是通过反射获取对象</li>
</ul>
</li>
<li>AOP 面向切面<ul>
<li>原理  通过动态代理 （也是基于反射）完成切入</li>
</ul>
</li>
</ul>
<blockquote>
<p>组成</p>
</blockquote>
<img src="/2021-03-Spring/1.png" class="">
<p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p>
<img src="/2021-03-Spring/2.png" class="">
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<blockquote>
<p>拓展</p>
</blockquote>
<p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li>
<li>Spring Cloud是基于Spring Boot实现的；</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
<li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li>
</ul>
<img src="/2021-03-Spring/3.png" class="">

<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h3><p>在一开始学习 Spring 的时候，就接触 IoC 了，作为 Spring 第一个最核心的概念，我们在解读它源码之前一定需要对其有深入的认识。</p>
<p>IoC 全称为 <code>InversionofControl</code>，翻译为 “控制反转”，它还有一个别名为 DI（ <code>DependencyInjection</code>）,即依赖注入。</p>
<p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>
<ol>
<li>谁控制谁</li>
<li>控制什么</li>
<li>为何是反转</li>
<li>哪些方面反转了</li>
</ol>
<ul>
<li><strong>分析实现</strong></li>
</ul>
<p>1.先写一个UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.再去写Dao的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;获取用户数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>3.然后去写UserService的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>4.最后写Service的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">     UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">     service.getUser();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这是最原始的方法，现在来修改一下</p>
<p>把UserDao的实现类增加一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMySqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;MySql获取用户数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要实现MySQL就要去service实现类里修改对应的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoMySqlImpl();</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         userDao.getUser();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果我们再增加一个userdao的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Oracle获取用户数据&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p>
<ul>
<li><strong>如何解决这个问题呢</strong></li>
</ul>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">       <span class="comment">// 利用set实现</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          userDao.getUser();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在去我们的测试类里 , 进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      UserServiceImpl service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">     service.setUserDao( <span class="keyword">new</span> UserDaoMySqlImpl() );</span><br><span class="line">      service.getUser();</span><br><span class="line">      <span class="comment">//那我们现在又想用Oracle去实现呢</span></span><br><span class="line">      service.setUserDao( <span class="keyword">new</span> UserDaoOracleImpl() );</span><br><span class="line">      service.getUser();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这看起来可能没有什么变化，但是他们已经发生了根本的变化，很多地方都不一样了，以前所有东西都是由程序去进行控制创建，而现在是我们自行控制创建对象，把主动权交给了调用者， 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p>
<p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<img src="/2021-03-Spring/4.png" class="">

<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<img src="/2021-03-Spring/5.png" class="">

<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="HelloSpring"><a href="#HelloSpring" class="headerlink" title="HelloSpring"></a>HelloSpring</h2><blockquote>
<p>导入Jar包</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Hello,&quot;</span>+ name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、我们可以去进行测试了 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   <span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line">   Hello hello = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   hello.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的</li>
<li>Hello 对象的属性是怎么设置的 ?  hello 对象的属性是由Spring容器设置的</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p>依赖注入 : 就是利用set方法来进行注入的.</p>
<p> IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>我们在案例一中， 新增一个Spring配置文件beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;OracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;OracleImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(<span class="string">&quot;ServiceImpl&quot;</span>);</span><br><span class="line">   serviceImpl.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p>
<h2 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h2><blockquote>
<p>通过无参构造方法来创建</p>
</blockquote>
<p>1、User.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;user无参构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、beans.xml</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">      xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">      xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;kuangshen&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   <span class="comment">//在执行getBean的时候, user已经创建好了 , 通过无参构造</span></span><br><span class="line">   User user = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="comment">//调用对象的方法 .</span></span><br><span class="line">   user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<blockquote>
<p>通过有参构造方法来创建</p>
</blockquote>
<p>1、UserT . java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">UserT</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、beans.xml 有三种方式编写</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userT&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span><br><span class="line">   &lt;!-- index指构造方法 , 下标从<span class="number">0</span>开始 --&gt;</span><br><span class="line">   &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> value=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userT&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span><br><span class="line">   &lt;!-- name指参数名 --&gt;</span><br><span class="line">   &lt;constructor-arg name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 第三种根据参数类型设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userT&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span><br><span class="line">   &lt;constructor-arg type=<span class="string">&quot;java.lang.String&quot;</span> value=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testT</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   UserT user = (UserT) context.getBean(<span class="string">&quot;userT&quot;</span>);</span><br><span class="line">   user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><blockquote>
<p>别名</p>
</blockquote>
<p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bean的配置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">   如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">   name可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class是bean的全限定名=包名+类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 h2,h3;h4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>import</p>
</blockquote>
<p>团队的合作通过import来实现 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;&#123;path&#125;/beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
<h3 id="对象注入"><a href="#对象注入" class="headerlink" title="对象注入"></a>对象注入</h3><p>我们在之前的案例已经讲过了，直白意思就是将类或则对象以bean的形式注入给IOC,用户只需通过IOC就能使用对象</p>
<h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p>Address.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbys;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books &#x3D; books;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbys(List&lt;String&gt; hobbys) &#123;</span><br><span class="line">        this.hobbys &#x3D; hobbys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card &#x3D; card;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games &#x3D; games;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife &#x3D; wife;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info &#x3D; info;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name</span><br><span class="line">                + &quot;,address&#x3D;&quot;+ address.getAddress()</span><br><span class="line">                + &quot;,books&#x3D;&quot;</span><br><span class="line">       );</span><br><span class="line">        for (String book:books)&#123;</span><br><span class="line">            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(&quot;\n爱好:&quot;+hobbys);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;card:&quot;+card);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;games:&quot;+games);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;wife:&quot;+wife);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;info:&quot;+info);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、<strong>常量注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    Student student &#x3D; (Student) context.getBean(&quot;student&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>Bean注入</strong> </p>
<p>注意点：这里的值是一个引用，ref</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;addr&quot; class&#x3D;&quot;com.kuang.pojo.Address&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; value&#x3D;&quot;重庆&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;addr&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、<strong>数组注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;addr&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;books&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;西游记&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;水浒传&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>4、<strong>List注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;hobbys&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;听歌&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;看电影&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;爬山&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;list&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>5、<strong>Map注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;card&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key&#x3D;&quot;中国邮政&quot; value&#x3D;&quot;456456456465456&quot;&#x2F;&gt;</span><br><span class="line">        &lt;entry key&#x3D;&quot;建设&quot; value&#x3D;&quot;1456682255511&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;map&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>6、<strong>set注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;games&quot;&gt;</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;value&gt;LOL&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;BOB&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;COC&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>7、<strong>Null注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8、<strong>Properties注入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<img src="/2021-03-Spring/6.png" class="">

<blockquote>
<p>p命名和c命名注入</p>
</blockquote>
<p>User.java ：【注意：这里没有有参构造器！】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、P命名空间注入 : 需要在头文件中加入约束文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、c 命名空间注入 : 需要在头文件中加入约束文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现问题：爆红了，刚才我们没有写有参构造！</p>
<p>解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test02()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    User user &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<img src="/2021-03-Spring/7.png" class="">

<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.csdn.service.ServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    User user2 = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;  </span><br><span class="line"> 或者</span><br><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; singleton&#x3D;&quot;false&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;cn.csdn.LoginAction&quot; scope&#x3D;&quot;request&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.foo.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
<p>Bean的自动装配</p>
<blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="xml自动装配-不推荐"><a href="#xml自动装配-不推荐" class="headerlink" title="xml自动装配 不推荐"></a>xml自动装配 不推荐</h3><blockquote>
<p>测试环境搭建</p>
</blockquote>
<p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">   public void shout() &#123;</span><br><span class="line">       System.out.println(&quot;miao~&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog &#123;</span><br><span class="line">   public void shout() &#123;</span><br><span class="line">       System.out.println(&quot;wang~&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、新建一个用户类 User</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   private Cat cat;</span><br><span class="line">   private Dog dog;</span><br><span class="line">   private String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、编写Spring配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;cat&quot; ref&#x3D;&quot;cat&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dog&quot; ref&#x3D;&quot;dog&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;qinjiang&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>5、测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void testMethodAutowire() &#123;</span><br><span class="line">       ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       User user &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果正常输出，环境OK</p>
<blockquote>
<p>byName</p>
</blockquote>
<h4 id="autowire-byName-按名称自动装配"><a href="#autowire-byName-按名称自动装配" class="headerlink" title="autowire byName (按名称自动装配)"></a><strong>autowire byName (按名称自动装配)</strong></h4><p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=”byName”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; autowire&#x3D;&quot;byName&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;qinjiang&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li><p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li><p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li><p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<blockquote>
<p>byType</p>
</blockquote>
<h4 id="autowire-byType-按类型自动装配"><a href="#autowire-byType-按类型自动装配" class="headerlink" title="autowire byType (按类型自动装配)"></a><strong>autowire byType (按类型自动装配)</strong></h4><p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=”byType”</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat2&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; autowire&#x3D;&quot;byType&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;qinjiang&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="注解自动装配"><a href="#注解自动装配" class="headerlink" title="注解自动装配"></a>注解自动装配</h3><p>使用注解</p>
<blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br></pre></td></tr></table></figure>

<p>2、开启属性注解支持！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private Cat cat;</span><br><span class="line">   @Autowired</span><br><span class="line">   private Dog dog;</span><br><span class="line">   private String str;</span><br><span class="line"></span><br><span class="line">   public Cat getCat() &#123;</span><br><span class="line">       return cat;</span><br><span class="line">  &#125;</span><br><span class="line">   public Dog getDog() &#123;</span><br><span class="line">       return dog;</span><br><span class="line">  &#125;</span><br><span class="line">   public String getStr() &#123;</span><br><span class="line">       return str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、此时配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试，成功输出结果！</p>
<ul>
<li>题外</li>
</ul>
<blockquote>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果允许对象为null，设置required &#x3D; false,默认为true</span><br><span class="line">@Autowired(required &#x3D; false)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure>

<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dog1&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dog2&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat1&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat2&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value &#x3D; &quot;cat2&quot;)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value &#x3D; &quot;dog2&quot;)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>

<p>测试，成功输出！</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   &#x2F;&#x2F;如果允许对象为null，设置required &#x3D; false,默认为true</span><br><span class="line">   @Resource(name &#x3D; &quot;cat2&quot;)</span><br><span class="line">   private Cat cat;</span><br><span class="line">   @Resource</span><br><span class="line">   private Dog dog;</span><br><span class="line">   private String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat1&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat2&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cat1&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>实体类上只保留注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private Cat cat;</span><br><span class="line">@Resource</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>

<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><blockquote>
<p>说明</p>
</blockquote>
<p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<img src="/2021-03-Spring/7-8.png" class="">

<p>在配置文件当中，还得要引入一个context约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><blockquote>
<p>Bean的实现</p>
</blockquote>
<p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--指定注解扫描包--&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>2、在指定包下编写类，增加注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于配置文件中 &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;当前注解的类&quot;&#x2F;&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">   public String name &#x3D; &quot;秦疆&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">   ApplicationContext applicationContext &#x3D;</span><br><span class="line">       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   User user &#x3D; (User) applicationContext.getBean(&quot;user&quot;);</span><br><span class="line">   System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><blockquote>
<p>属性注入</p>
</blockquote>
<p>使用注解直接给属性赋值</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于配置文件中 &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;当前注解的类&quot;&#x2F;&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   &#x2F;&#x2F; 相当于配置文件中 &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;秦疆&quot;&#x2F;&gt;</span><br><span class="line">   public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果提供了set方法，在set方法上添加@value(“值”);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">   public String name;</span><br><span class="line"></span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">       this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>衍生注解</p>
</blockquote>
<p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<h3 id="Component三个衍生注解"><a href="#Component三个衍生注解" class="headerlink" title="@Component三个衍生注解"></a><strong>@Component三个衍生注解</strong></h3><p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<h3 id="scope作用域"><a href="#scope作用域" class="headerlink" title="@scope作用域"></a>@scope作用域</h3><ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller(&quot;user&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   @Value(&quot;秦疆&quot;)</span><br><span class="line">   public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XML与注解比较"><a href="#XML与注解比较" class="headerlink" title="XML与注解比较"></a><strong>XML与注解比较</strong></h3><ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config&#x2F;&gt;  </span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li><p>进行注解驱动注册，从而使注解生效</p>
</li>
<li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li><p>如果不扫描包，就需要手动配置bean</p>
</li>
<li><p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<h3 id="Configuration-使用Java配置类进行配置"><a href="#Configuration-使用Java配置类进行配置" class="headerlink" title="@Configuration 使用Java配置类进行配置"></a>@Configuration 使用Java配置类进行配置</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component  &#x2F;&#x2F;将这个类标注为Spring的一个组件，放到容器中！</span><br><span class="line">public class Dog &#123;</span><br><span class="line">   public String name &#x3D; &quot;dog&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration  &#x2F;&#x2F;代表这是一个配置类</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">   @Bean &#x2F;&#x2F;通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span><br><span class="line">   public Dog dog()&#123;</span><br><span class="line">       return new Dog();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext applicationContext &#x3D;</span><br><span class="line">           new AnnotationConfigApplicationContext(MyConfig.class);</span><br><span class="line">   Dog dog &#x3D; (Dog) applicationContext.getBean(&quot;dog&quot;);</span><br><span class="line">   System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、成功输出结果！</p>
<h3 id="Import-导入其他配置"><a href="#Import-导入其他配置" class="headerlink" title="@Import 导入其他配置"></a><strong>@Import 导入其他配置</strong></h3><p>1、我们再编写一个配置类！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration  &#x2F;&#x2F;代表这是一个配置类</span><br><span class="line">public class MyConfig2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(MyConfig2.class)  &#x2F;&#x2F;导入合并其他配置类，类似于配置文件中的 inculde 标签</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Dog dog()&#123;</span><br><span class="line">       return new Dog();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p><strong>个人理解</strong>：不仅具有真实对象的功能，还具备一些附属操作</p>
<p>eg：房屋中介 具有出租房子的功能，还具备：看房，收中介费等</p>
</li>
</ul>
<p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p>
<p>代理模式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>学习aop之前 , 我们要先了解一下代理模式！</p>
<img src="/2021-03-Spring/8.png" class="">

<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li><p>抽象角色 : 一般使用接口或者抽象类来实现</p>
</li>
<li><p>真实角色 : 被代理的角色</p>
</li>
<li><p>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</p>
</li>
<li><p>客户  :  使用代理角色来进行一些操作 .</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>Rent . java 即抽象角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">   public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host . java 即真实角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真实角色: 房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">   public void rent() &#123;</span><br><span class="line">       System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Proxy . java 即代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代理角色：中介</span><br><span class="line">public class Proxy implements Rent &#123;</span><br><span class="line"></span><br><span class="line">   private Host host;</span><br><span class="line">   public Proxy() &#123; &#125;</span><br><span class="line">   public Proxy(Host host) &#123;</span><br><span class="line">       this.host &#x3D; host;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;租房</span><br><span class="line">   public void rent()&#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       host.rent();</span><br><span class="line">       fare();</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;看房</span><br><span class="line">   public void seeHouse()&#123;</span><br><span class="line">       System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;收中介费</span><br><span class="line">   public void fare()&#123;</span><br><span class="line">       System.out.println(&quot;收中介费&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client . java 即客户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;客户类，一般客户都会去找代理！</span><br><span class="line">public class Client &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;房东要租房</span><br><span class="line">       Host host &#x3D; new Host();</span><br><span class="line">       &#x2F;&#x2F;中介帮助房东</span><br><span class="line">       Proxy proxy &#x3D; new Proxy(host);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;你去找中介！</span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h3 id="静态代理再理解"><a href="#静态代理再理解" class="headerlink" title="静态代理再理解"></a>静态代理再理解</h3><p>同学们练习完毕后，我们再来举一个例子，巩固大家的学习！</p>
<p>练习步骤：</p>
<p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象角色：增删改查业务</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">   void add();</span><br><span class="line">   void delete();</span><br><span class="line">   void update();</span><br><span class="line">   void query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、我们需要一个真实对象来完成这些增删改查操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真实对象，完成增删改查操作的人</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">   public void add() &#123;</span><br><span class="line">       System.out.println(&quot;增加了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       System.out.println(&quot;删除了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void update() &#123;</span><br><span class="line">       System.out.println(&quot;更新了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void query() &#123;</span><br><span class="line">       System.out.println(&quot;查询了一个用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
<p>4、设置一个代理类来处理日志！代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代理角色，在这里面增加日志的实现</span><br><span class="line">public class UserServiceProxy implements UserService &#123;</span><br><span class="line">   private UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">   public void setUserService(UserServiceImpl userService) &#123;</span><br><span class="line">       this.userService &#x3D; userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void add() &#123;</span><br><span class="line">       log(&quot;add&quot;);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       log(&quot;delete&quot;);</span><br><span class="line">       userService.delete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void update() &#123;</span><br><span class="line">       log(&quot;update&quot;);</span><br><span class="line">       userService.update();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void query() &#123;</span><br><span class="line">       log(&quot;query&quot;);</span><br><span class="line">       userService.query();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void log(String msg)&#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试访问类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;真实业务</span><br><span class="line">       UserServiceImpl userService &#x3D; new UserServiceImpl();</span><br><span class="line">       &#x2F;&#x2F;代理类</span><br><span class="line">       UserServiceProxy proxy &#x3D; new UserServiceProxy();</span><br><span class="line">       &#x2F;&#x2F;使用代理类实现日志功能！</span><br><span class="line">       proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">       proxy.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<img src="/2021-03-Spring/9.png" class="">

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li><p><strong>个人理解</strong>：代理生成器根据不同真实对象来动态生成代理类，具备真实对象的功能，还可以在真实对象功能的前后加功能（AOP）</p>
<p>eg：大中介 （包租房，租车 等等）</p>
</li>
</ul>
<p>​    生成代理之前 代理生成器只具有一个收钱功能  </p>
<p>​    代理生成器根据租房生成一个租房代理后，具有租房的功能，还具有收钱的</p>
<p>​    代理生成器根据租房生成一个租车代理后，具有租车的功能，还具有收钱的</p>
<ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<img src="/2021-03-Spring/10.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, 方法 method, Object[] args)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//proxy - 调用该方法的代理实例</span></span></span><br><span class="line"><span class="function"><span class="comment">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span></span></span><br><span class="line"><span class="function"><span class="comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span></span></span><br></pre></td></tr></table></figure>

<p>【Proxy  : 代理】</p>
<img src="/2021-03-Spring/11.png" class="">

<img src="/2021-03-Spring/12.png" class="">

<img src="/2021-03-Spring/13.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                 rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host . java 即真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyInvocationHandler. java 即代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">   private Rent rent;</span><br><span class="line"></span><br><span class="line">   public void setRent(Rent rent) &#123;</span><br><span class="line">       this.rent &#x3D; rent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span><br><span class="line">   public Object getProxy()&#123;</span><br><span class="line">       return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span><br><span class="line">   &#x2F;&#x2F; 处理代理实例上的方法调用并返回结果</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       &#x2F;&#x2F;核心：本质利用反射实现！</span><br><span class="line">       Object result &#x3D; method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;看房</span><br><span class="line">   public void seeHouse()&#123;</span><br><span class="line">       System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;收中介费</span><br><span class="line">   public void fare()&#123;</span><br><span class="line">       System.out.println(&quot;收中介费&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client . java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;租客</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;真实角色</span><br><span class="line">       Host host &#x3D; new Host();</span><br><span class="line">       &#x2F;&#x2F;代理实例的调用处理程序</span><br><span class="line">       ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();</span><br><span class="line">       pih.setRent(host); &#x2F;&#x2F;将真实角色放置进去！</span><br><span class="line">       Rent proxy &#x3D; (Rent)pih.getProxy(); &#x2F;&#x2F;动态生成对应的代理类！</span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<h3 id="深化理解"><a href="#深化理解" class="headerlink" title="深化理解"></a>深化理解</h3><p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 生成的代理实例的调用处理程序</span></span><br><span class="line"><span class="comment">* InvocationHandler：代理实例的调用处理程序</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 代理生成器</span></span><br><span class="line"><span class="comment">    * 参数: 通过反射获取ClassLoader，需要代理类（target）的接口 可以是多个接口，</span></span><br><span class="line"><span class="comment">    * 生成的代理实例的调用处理程序 调用方法是（invoke）</span></span><br><span class="line"><span class="comment">    * 返回结果：生成的代理实列</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 执行生成代理实例的方法</span></span><br><span class="line"><span class="comment">    * 可以进行切入编程</span></span><br><span class="line"><span class="comment">    * 参数：代理对象，需要执行的方法，方法参数</span></span><br><span class="line"><span class="comment">    * 返回值：需要执行的方法的返回值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//切入log方法</span></span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="comment">//执行被代理类的方法（参数：被代理类，方法参数）</span></span><br><span class="line">        Object result=method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需要切入的方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String method)</span></span>&#123;</span><br><span class="line">        System.out.println(method+<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//房东 真实角色</span></span><br><span class="line">    Host host=<span class="keyword">new</span> Host();</span><br><span class="line">    <span class="comment">//生成代理器</span></span><br><span class="line">    ProxyInvocationHandler pih=<span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">    <span class="comment">//根据房东生成房屋代理</span></span><br><span class="line">    pih.setTarget(host);</span><br><span class="line">    Rent rentProxy=(Rent) pih.getProxy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//房屋代理出租房源</span></span><br><span class="line">    rentProxy.rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h3><p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>上一讲中我们讲解了代理模式，这是AOP的基础，一定要先搞懂它</p>
<p>那我们接下来就来聊聊AOP吧！</p>
<blockquote>
<p>什么是AOP</p>
</blockquote>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<img src="/2021-03-Spring/14.png" class="">

<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<img src="/2021-03-Spring/15.png" class="">

<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<img src="/2021-03-Spring/16.png" class="">

<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<blockquote>
<p>使用Spring实现Aop</p>
</blockquote>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第一种方式</strong></p>
<h3 id="通过-Spring-API-实现"><a href="#通过-Spring-API-实现" class="headerlink" title="通过 Spring API 实现"></a><strong>通过 Spring API 实现</strong></h3><p>首先编写我们的业务接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;增加用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeLog</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line">   <span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line">   <span class="comment">//Object : 目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println( o.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">   <span class="comment">//returnValue 返回值</span></span><br><span class="line">   <span class="comment">//method被调用的方法</span></span><br><span class="line">   <span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line">   <span class="comment">//target 被调用的目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;执行了&quot;</span> + target.getClass().getName()</span><br><span class="line">       +<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法,&quot;</span></span><br><span class="line">       +<span class="string">&quot;返回值：&quot;</span>+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.chenmw.user.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.chenmw.BeforeLog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.chenmw.AfterLog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点 需要切入的对象(需要被代理的对象) expression:表达式匹配要执行的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.chenmw.user.impl.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">ApplicationContext context&#x3D;new ClassPathXmlApplicationContext(&quot;Application.xml&quot;);</span><br><span class="line">&#x2F;&#x2F;为什么是接口类型</span><br><span class="line">&#x2F;&#x2F;同代理生成器需要被代理的接口，让Spring AOP去生成代理类 实现切面编程</span><br><span class="line">UserService userServiceImpl&#x3D;(UserService) context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">userServiceImpl.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<p><strong>第二种方式</strong></p>
<h3 id="自定义类来实现Aop"><a href="#自定义类来实现Aop" class="headerlink" title="自定义类来实现Aop"></a><strong>自定义类来实现Aop</strong></h3><p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去spring中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;diy&quot; class&#x3D;&quot;com.kuang.config.DiyPointcut&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">   &lt;aop:aspect ref&#x3D;&quot;diy&quot;&gt;</span><br><span class="line">       &lt;aop:pointcut id&#x3D;&quot;diyPonitcut&quot; expression&#x3D;&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:before pointcut-ref&#x3D;&quot;diyPonitcut&quot; method&#x3D;&quot;before&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:after pointcut-ref&#x3D;&quot;diyPonitcut&quot; method&#x3D;&quot;after&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void test()&#123;</span><br><span class="line">       ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       UserService userService &#x3D; (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第三种方式</strong></p>
<h3 id="使用注解实现"><a href="#使用注解实现" class="headerlink" title="使用注解实现"></a><strong>使用注解实现</strong></h3><p>第一步：编写一个注解实现的增强类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;环绕前&quot;);</span><br><span class="line">       System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">       &#x2F;&#x2F;执行目标方法proceed</span><br><span class="line">       Object proceed &#x3D; jp.proceed();</span><br><span class="line">       System.out.println(&quot;环绕后&quot;);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;annotationPointcut&quot; class&#x3D;&quot;com.kuang.config.AnnotationPointcut&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>aop:aspectj-autoproxy：说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy &#x2F;&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy &#x2F;&gt;隐藏起来了</span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy &#x2F;&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>

<h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><blockquote>
<p> 步骤</p>
</blockquote>
<p>1、导入相关jar包</p>
<p>junit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>mybatis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.5.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>mysql-connector-java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>spring相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>aspectJ AOP 织入器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>mybatis-spring整合包 【重点】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置Maven静态资源过滤问题！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>2、编写配置文件</p>
<p>3、代码实现</p>
<h3 id="回顾MyBatis"><a href="#回顾MyBatis" class="headerlink" title="回顾MyBatis"></a>回顾MyBatis</h3><p><strong>编写pojo实体类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">   private int id;  &#x2F;&#x2F;id</span><br><span class="line">   private String name;   &#x2F;&#x2F;姓名</span><br><span class="line">   private String pwd;   &#x2F;&#x2F;密码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现mybatis的配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line"></span><br><span class="line">   &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">       &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">           &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">           &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;</span><br><span class="line">           &lt;&#x2F;dataSource&gt;</span><br><span class="line">       &lt;&#x2F;environment&gt;</span><br><span class="line">   &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.dao&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p><strong>UserDao接口编写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">   public List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口对应的Mapper映射文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.kuang.dao.UserMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;select id&#x3D;&quot;selectUser&quot; resultType&#x3D;&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="comment">//1.读取核心配置文件 返回inputStream流</span></span><br><span class="line">   InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">//2.（build）根据inputStream流对象解析出（反序列化）Configuration对象，然后创建SqlSessionFactory工厂对象</span></span><br><span class="line">   SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//3.根据一系列属性，从工厂中创建SqlSession</span></span><br><span class="line">   SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//4.</span></span><br><span class="line">   UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line">   <span class="keyword">for</span> (User user: userList)&#123;</span><br><span class="line">       System.out.println(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="MyBatis-Spring学习"><a href="#MyBatis-Spring学习" class="headerlink" title="MyBatis-Spring学习"></a>MyBatis-Spring学习</h3><p>引入Spring之前需要了解mybatis-spring包中的一些重要类；</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5teWJhdGlzLm9yZy9zcHJpbmcvemgvaW5kZXguaHRtbA==">http://www.mybatis.org/spring/zh/index.html<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\Spring\640" alt="图片"></p>
<p><strong>什么是 MyBatis-Spring？</strong></p>
<p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p>
<p><strong>知识基础</strong></p>
<p>在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要</p>
<p>MyBatis-Spring 需要以下版本：</p>
<table>
<thead>
<tr>
<th align="left">MyBatis-Spring</th>
<th align="left">MyBatis</th>
<th align="left">Spring 框架</th>
<th align="left">Spring Batch</th>
<th align="left">Java</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2.0</td>
<td align="left">3.5+</td>
<td align="left">5.0+</td>
<td align="left">4.0+</td>
<td align="left">Java 8+</td>
</tr>
<tr>
<td align="left">1.3</td>
<td align="left">3.4+</td>
<td align="left">3.2.2+</td>
<td align="left">2.1+</td>
<td align="left">Java 6+</td>
</tr>
</tbody></table>
<p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。</p>
<p>在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line"> &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p>
<p>在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。</p>
<p>在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p>
<p>SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p>
<p>一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。</p>
<p>需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（<environments>），数据源（<DataSource>）和 MyBatis 的事务管理器（<transactionManager>）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。</p>
<p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。</p>
<p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p>
<p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;</span><br><span class="line"> &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line"> private SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"> public void setSqlSession(SqlSession sqlSession) &#123;</span><br><span class="line">   this.sqlSession &#x3D; sqlSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public User getUser(String userId) &#123;</span><br><span class="line">   return sqlSession.getMapper...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按下面这样，注入 SqlSessionTemplate：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;</span><br><span class="line"> &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSession&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>



<h4 id="整合实现一"><a href="#整合实现一" class="headerlink" title="整合实现一"></a>整合实现一</h4><p>1、引入Spring配置文件beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置数据源替换mybaits的数据源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置SqlSessionFactory，关联MyBatis</p>
<p>SqlSessionFactory，根据属性地址，反射生成SqlSession</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置SqlSessionFactory--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!--关联Mybatis--&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;kuang&#x2F;dao&#x2F;*.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>4、注册sqlSessionTemplate，关联sqlSessionFactory；</p>
<p>sqlSessionTemplate相当于是代理生成器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;</span><br><span class="line">   &lt;!--利用构造器注入--&gt;</span><br><span class="line">   &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>5、增加Dao接口的实现类；私有化sqlSessionTemplate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserMapper &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;sqlSession不用我们自己创建了，Spring来管理</span><br><span class="line">   private SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;</span><br><span class="line">       this.sqlSession &#x3D; sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、注册bean实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.kuang.dao.UserDaoImpl&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSession&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>7、测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public void test2()&#123;</span><br><span class="line">     ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">     UserMapper mapper &#x3D; (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">     List&lt;User&gt; user &#x3D; mapper.selectUser();</span><br><span class="line">     System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>



<h4 id="整合实现二"><a href="#整合实现二" class="headerlink" title="整合实现二"></a>整合实现二</h4><p>mybatis-spring1.2.3版以上的才有这个 .</p>
<p>官方文档截图 :</p>
<p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\Spring\640" alt="图片"></p>
<p>测试：</p>
<p>1、将我们上面写的UserDaoImpl修改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;</span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       UserMapper mapper &#x3D; getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、修改bean的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.kuang.dao.UserDaoImpl&quot;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper &#x3D; (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user &#x3D; mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合</strong></p>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><blockquote>
<p>回顾事务</p>
</blockquote>
<ul>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
<li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li>
</ul>
<p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p>
<h3 id="事务四个属性ACID"><a href="#事务四个属性ACID" class="headerlink" title="事务四个属性ACID"></a><strong>事务四个属性ACID</strong></h3><ol>
<li><p>原子性（atomicity）</p>
</li>
<li><ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li><p>一致性（consistency）</p>
</li>
<li><ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li><p>隔离性（isolation）</p>
</li>
<li><ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
</ul>
</li>
<li><p>持久性（durability）</p>
</li>
<li><ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></blockquote>
<p>将上面的代码拷贝到一个新项目中</p>
<p>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加一个用户</span><br><span class="line">int addUser(User user);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据id删除用户</span><br><span class="line">int deleteUser(int id);</span><br></pre></td></tr></table></figure>

<p>mapper文件，我们故意把 deletes 写错，测试！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">deletes from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure>

<p>编写接口的实现类，在实现类中，我们去操作一波</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;增加一些操作</span><br><span class="line">   public List&lt;User&gt; selectUser() &#123;</span><br><span class="line">       User user &#x3D; new User(4,&quot;小明&quot;,&quot;123456&quot;);</span><br><span class="line">       UserMapper mapper &#x3D; getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       mapper.addUser(user);</span><br><span class="line">       mapper.deleteUser(4);</span><br><span class="line">       return mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;新增</span><br><span class="line">   public int addUser(User user) &#123;</span><br><span class="line">       UserMapper mapper &#x3D; getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.addUser(user);</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;删除</span><br><span class="line">   public int deleteUser(int id) &#123;</span><br><span class="line">       UserMapper mapper &#x3D; getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       return mapper.deleteUser(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper &#x3D; (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user &#x3D; mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：sql异常，delete写错了</p>
<p>结果 ：插入成功！</p>
<p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要<strong>事务！</strong></p>
<p>以前我们都需要自己手动管理事务，十分麻烦！</p>
<p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p>
<h3 id="Spring中的事务管理"><a href="#Spring中的事务管理" class="headerlink" title="Spring中的事务管理"></a>Spring中的事务管理</h3><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置事务通知--&gt;</span><br><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">   &lt;tx:attributes&gt;</span><br><span class="line">       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;add&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;delete&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;update&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;search*&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;get&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure>

<h3 id="spring事务传播特性"><a href="#spring事务传播特性" class="headerlink" title="spring事务传播特性"></a><strong>spring事务传播特性</strong></h3><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<p><strong>配置AOP</strong></p>
<p>导入aop的头文件！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置aop织入事务--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:pointcut id&#x3D;&quot;txPointcut&quot; expression&#x3D;&quot;execution(* com.kuang.dao.*.*(..))&quot;&#x2F;&gt;</span><br><span class="line">   &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;txPointcut&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">   ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">   UserMapper mapper &#x3D; (UserMapper) context.getBean(&quot;userDao&quot;);</span><br><span class="line">   List&lt;User&gt; user &#x3D; mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021-03-SpringMVC/</url>
    <content><![CDATA[<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><ul>
<li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码。</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li>
</ul>
<span id="more"></span>

<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<img src="/2021-03-SpringMVC/1.png" class="">

<h3 id="Model1时代"><a href="#Model1时代" class="headerlink" title="Model1时代"></a>Model1时代</h3><ul>
<li>在web早期的开发中，通常采用的都是Model1。</li>
<li>Model1中，主要分为两层，视图层和模型层。</li>
</ul>
<img src="/2021-03-SpringMVC/2.png" class="">

<p>Model1优点：架构简单，比较适合小型项目开发；</p>
<p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p>
<h3 id="Model2时代"><a href="#Model2时代" class="headerlink" title="Model2时代"></a>Model2时代</h3><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型。</strong></p>
<img src="/2021-03-SpringMVC/3.png" class="">

<ol>
<li>用户发请求</li>
<li>Servlet接收请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到JSP，由JSP来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<p><strong>职责分析：</strong></p>
<ul>
<li><strong>Controller：控制器</strong></li>
</ul>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<ul>
<li><strong>Model：模型</strong></li>
</ul>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<ul>
<li><strong>View：视图</strong></li>
</ul>
<ol>
<li>显示页面</li>
</ol>
<p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p>
<h3 id="回顾Servlet"><a href="#回顾Servlet" class="headerlink" title="回顾Servlet"></a>回顾Servlet</h3><ol>
<li><p>新建一个Maven工程当做父工程！pom依赖！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！</p>
</li>
<li><p>导入servlet 和 jsp 的 jar 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个Servlet类，用来处理用户的请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Servlet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">//取得参数</span></span><br><span class="line">       String method = req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">if</span> (method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">           req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//业务逻辑</span></span><br><span class="line">       <span class="comment">//视图跳转</span></span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/hello.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Kuangshen<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在web.xml中注册Servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Tomcat，并启动测试</p>
</li>
<li><p>访问测试</p>
<ul>
<li>localhost:8080/user?method=add</li>
<li>localhost:8080/user?method=delete</li>
</ul>
</li>
</ol>
<ul>
<li><strong>MVC框架要做哪些事情</strong><ol>
<li>将url映射到java类或java类的方法 .</li>
<li>封装用户提交的数据 .</li>
<li>处理请求–调用相关的业务处理–封装响应数据 .</li>
<li>将响应的数据进行渲染 . jsp / html 等表示层数据 .</li>
</ol>
</li>
</ul>
<p><strong>说明：</strong></p>
<p>常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….</p>
<h2 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><img src="/2021-03-SpringMVC/4.png" class="">

<p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p>查看官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy81LjIuMC5SRUxFQVNFL3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL3dlYi5odG1sI3NwcmluZy13ZWI=">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>我们为什么要学习SpringMVC呢?</strong></p>
<p> Spring MVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p>
<p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong></p>
<h3 id="中心控制器"><a href="#中心控制器" class="headerlink" title="中心控制器"></a>中心控制器</h3><p>Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p>
<img src="/2021-03-SpringMVC/5.png" class="">

<p>SpringMVC的原理如下图所示：</p>
<p>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<img src="/2021-03-SpringMVC/6.png" class="">

<h3 id="SpringMVC执行原理"><a href="#SpringMVC执行原理" class="headerlink" title="SpringMVC执行原理"></a>SpringMVC执行原理</h3><img src="/2021-03-SpringMVC/7.png" class="">

<p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL1NwcmluZ01WQy9oZWxsbw==">http://localhost:8080/SpringMVC/hello<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>如上url拆分成三部分：</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgw5pyN5Yqh5Zmo5Z+f5ZCN">http://localhost:8080服务器域名<i class="fa fa-external-link-alt"></i></span></p>
<p>SpringMVC部署在服务器上的web站点</p>
<p>hello表示控制器</p>
<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
</li>
<li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p>
</li>
<li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p>
</li>
<li><p>Handler让具体的Controller执行。</p>
</li>
<li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p>
</li>
<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<p>在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！</p>
<p>Hello，SpringMVC</p>
<h2 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h2><p>1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p>
<p>2、确定导入了SpringMVC 的依赖！</p>
<p>3、配置web.xml  ， 注册DispatcherServlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml  : [servletname]-servlet.xml</p>
<p>说明，这里的名称要求是按照官方来的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、添加 处理映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>6、添加 处理器适配器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>7、添加 视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里我们先导入Controller接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//封装对象，放在ModelAndView中。Model</span></span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMVC!&quot;</span>);</span><br><span class="line">       <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">       mv.setViewName(<span class="string">&quot;hello&quot;</span>); <span class="comment">//: /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、将自己的类交给SpringIOC容器，注册bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>11、配置Tomcat 启动测试！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p>
<ol>
<li>查看控制台输出，看一下是不是缺少了什么jar包。</li>
<li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</li>
<li>重启Tomcat 即可解决！</li>
</ol>
<p>小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。</p>
<h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><ol>
<li><p><strong>新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！</strong></p>
</li>
<li><p>由于Maven可能存在资源过滤的问题，我们将配置完善</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！</p>
</li>
<li><p><strong>配置web.xml</strong></p>
<p> 注意点：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>/ 和 /* 的区别：</strong><code>&lt; url-pattern &gt; / &lt;/ url-pattern &gt;</code> 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。<code>&lt; url-pattern &gt; /* &lt;/ url-pattern &gt;</code> 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。<ul>
<li>注意web.xml版本问题，要最新版！</li>
<li>注册DispatcherServlet</li>
<li>关联SpringMVC的配置文件</li>
<li>启动级别为1</li>
<li>映射路径为 / 【不要用/*，会404】</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>添加Spring MVC配置文件</strong></p>
<p> 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">支持mvc注解驱动</span></span><br><span class="line"><span class="comment">    在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">    要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">    必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">    和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">    这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">    而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p>
<ul>
<li>让IOC的注解生效</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li>
<li>MVC的注解驱动</li>
<li>配置视图解析器</li>
</ul>
</li>
<li><p><strong>创建Controller</strong></p>
<p> 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/HelloController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实访问地址 : 项目名/HelloController/hello</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,SpringMVC&quot;</span>);</span><br><span class="line">    <span class="comment">//web-inf/jsp/hello.jsp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li>
<li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；</li>
<li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>hello</strong>.jsp。</li>
</ul>
</li>
<li><p><strong>创建视图层</strong></p>
<p> 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p>
<p> 可以通过EL表示取出Model中存放的值，或者对象；</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置Tomcat运行</strong></p>
<p> 配置Tomcat ，  开启服务器 ， 访问 对应的请求路径！</p>
<p> localhost:8080/HelloController/hello</p>
<p> <strong>OK，运行成功！</strong></p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实现步骤其实非常的简单：</p>
<ol>
<li>新建一个web项目</li>
<li>导入相关jar包</li>
<li>编写web.xml , 注册DispatcherServlet</li>
<li>编写springmvc配置文件</li>
<li>接下来就是去创建对应的控制类 , controller</li>
<li>最后完善前端视图和controller之间的对应</li>
<li>测试运行调试.</li>
</ol>
<p>使用springMVC必须配置的三大件：</p>
<ul>
<li><strong>处理器映射器、处理器适配器、视图解析器</strong></li>
</ul>
<p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p>
<p>再来回顾下原理吧~</p>
<img src="/2021-03-SpringMVC/7.png" class="">

<h2 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h2><ul>
<li><p>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p>
</li>
<li><p>控制器负责解析用户的请求并将其转换为一个模型。</p>
</li>
<li><p>在Spring MVC中一个控制器类可以包含多个方法</p>
</li>
<li><p>在Spring MVC中，对于Controller的配置方式有很多种</p>
</li>
</ul>
<h3 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h3><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现该接口的类获得控制器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="comment">//处理请求且返回一个模型与视图对象</span></span><br><span class="line">   <span class="function">ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试</strong></li>
</ul>
<ol>
<li><p>新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！</p>
</li>
<li><p>删掉HelloController mvc的配置文件只留下 视图解析器！</p>
</li>
<li><p>编写一个Controller类，ControllerTest1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义控制器</span></span><br><span class="line"><span class="comment">//注意点：不要导错包，实现Controller接口，重写方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Test1Controller&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/t1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.controller.ControllerTest1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Kuangshen<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
</li>
</ol>
<p><strong>说明：</strong></p>
<ul>
<li><p>实现接口Controller定义控制器是较老的办法</p>
</li>
<li><p>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</p>
</li>
</ul>
<h3 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a>使用注解@Controller</h3><ul>
<li><p>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p>
</li>
<li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个ControllerTest2类，使用注解实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Controller注解的类会自动添加到Spring上下文中</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;ControllerTest2&quot;</span>);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行tomcat测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JOmNdhqNbrRK9XaseXIDsuOfarw6u03VH0lJg4tnml6mspCRTKGuwzQQy7rx7NMia7t5Xu1DYOQiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ul>
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p>
<p><strong>注解方式是平时使用的最多的方式！</strong></p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><ul>
<li><p><strong>@RequestMapping</strong></p>
<ul>
<li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p>
</li>
<li><p>只注解在方法上面</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/h1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问路径：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==">http://localhost:8080<i class="fa fa-external-link-alt"></i></span> / 项目名 / h1</p>
</li>
<li><p>同时注解类与方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/h1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问路径：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==">http://localhost:8080<i class="fa fa-external-link-alt"></i></span> / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径；</p>
</li>
</ul>
<h3 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h3><ul>
<li><strong>概念</strong></li>
</ul>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<ul>
<li><strong>功能</strong></li>
</ul>
<p>资源：互联网所有的事物都可以被抽象为资源</p>
<p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
<p>分别对应 添加、 删除、修改、查询。</p>
<ul>
<li><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtL3F1ZXJ5SXRlbS5hY3Rpb24/aWQ9MQ==">http://127.0.0.1/item/queryItem.action?id=1<i class="fa fa-external-link-alt"></i></span> 查询,GET</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtL3NhdmVJdGVtLmFjdGlvbg==">http://127.0.0.1/item/saveItem.action<i class="fa fa-external-link-alt"></i></span> 新增,POST</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtL3VwZGF0ZUl0ZW0uYWN0aW9u">http://127.0.0.1/item/updateItem.action<i class="fa fa-external-link-alt"></i></span> 更新,POST</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtL2RlbGV0ZUl0ZW0uYWN0aW9uP2lkPTE=">http://127.0.0.1/item/deleteItem.action?id=1<i class="fa fa-external-link-alt"></i></span> 删除,GET或POST</p>
<ul>
<li><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtLzE=">http://127.0.0.1/item/1<i class="fa fa-external-link-alt"></i></span> 查询,GET</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVt">http://127.0.0.1/item<i class="fa fa-external-link-alt"></i></span> 新增,POST</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVt">http://127.0.0.1/item<i class="fa fa-external-link-alt"></i></span> 更新,PUT</p>
<p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMS9pdGVtLzE=">http://127.0.0.1/item/1<i class="fa fa-external-link-alt"></i></span> 删除,DELETE</p>
<ul>
<li><p><strong>学习测试</strong></p>
<ol>
<li><p>在新建一个类 RestFulController</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> <span class="keyword">int</span> p2, Model model)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = p1+p2;</span><br><span class="line">        <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">        <span class="comment">//返回视图位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们来测试请求查看下</p>
<p> <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
</li>
<li><p>思考：使用路径变量的好处？</p>
</li>
<li><p>使路径变得更加简洁；</p>
<ul>
<li><p>获得参数更加方便，框架会自动进行类型转换。</p>
</li>
<li><p>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。<br>  <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
</li>
</ul>
</li>
<li><p>我们来修改下对应的参数类型，再次测试</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射访问路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> String p2, Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String result = p1+p2;</span><br><span class="line">    <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">    <span class="comment">//返回视图位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JOmNdhqNbrRK9XaseXIDsuJXyVjg5EaXZiaO78ibGzhUXnEz5UlbRTRDKzGNh0t5WspXrpvSLe9y9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ol>
</li>
<li><p><strong>使用method属性指定请求类型</strong></p>
</li>
</ul>
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p>
<p>我们来测试一下：</p>
<ul>
<li>增加一个方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<ul>
<li>如果将POST修改为GET则正常了；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是Get请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>小结：</strong></p>
<p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p>
<p>方法级别的注解变体有如下几个：组合注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@PatchMapping</span></span><br></pre></td></tr></table></figure>

<p>@GetMapping 是一个组合注解，平时使用的会比较多！</p>
<p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p>
<h3 id="扩展：小黄鸭调试法"><a href="#扩展：小黄鸭调试法" class="headerlink" title="扩展：小黄鸭调试法"></a>扩展：小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p>
<p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p>
<p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p>
<p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p>
<h2 id="结果跳转方式"><a href="#结果跳转方式" class="headerlink" title="结果跳转方式"></a>结果跳转方式</h2><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p>
<p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的controller类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p>
<p>1、通过HttpServletResponse进行输出</p>
<p>2、通过HttpServletResponse实现重定向</p>
<p>3、通过HttpServletResponse实现转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.getWriter().println(<span class="string">&quot;Hello,Spring BY servlet API&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.sendRedirect(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t3&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       req.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;/result/t3&quot;</span>);</span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,rsp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring-MVC"></a>Spring-MVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p>
<p>测试前，需要将视图解析器注释掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发二</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t3&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p>
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p>
<p>可以重定向到另外一个请求实现 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC2</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm2/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm2/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">       <span class="comment">//return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h3><ol>
<li><p><strong>提交的域名称和处理方法的参数名一致</strong></p>
<p> 提交数据 : <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2hlbGxvP25hbWU9a3VhbmdzaGVu">http://localhost:8080/hello?name=kuangshen<i class="fa fa-external-link-alt"></i></span></p>
<p> 处理方法 :</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 后台输出 : kuangshen</p>
</li>
<li><p><strong>提交的域名称和处理方法的参数名不一致</strong></p>
<p> 提交数据 : <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2hlbGxvP3VzZXJuYW1lPWt1YW5nc2hlbg==">http://localhost:8080/hello?username=kuangshen<i class="fa fa-external-link-alt"></i></span></p>
<p> 处理方法 :</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 后台输出 : kuangshen</p>
</li>
<li><p><strong>提交的是一个对象</strong></p>
<p> 要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p>
<p> 1、实体类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="comment">//get/set</span></span><br><span class="line"><span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2、提交数据 : <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL212YzA0L3VzZXI/bmFtZT1rdWFuZ3NoZW4mYW1wO2lkPTEmYW1wO2FnZT0xNQ==">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15<i class="fa fa-external-link-alt"></i></span></p>
<p> 3、处理方法 :</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 后台输出 : User { id=1, name=’kuangshen’, age=15 }</p>
<p> 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p>
</li>
</ol>
<h3 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h3><ul>
<li><strong>第一种 : 通过ModelAndView</strong></li>
</ul>
<p>我们前面一直都是如此 . 就不过多解释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二种 : 通过ModelMap</strong></li>
</ul>
<p>ModelMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第三种 : 通过Model</strong></li>
</ul>
<p>Model</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>就对于新手而言简单来说使用区别就是：</p>
<ul>
<li><p>Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；</p>
</li>
<li><p>ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</p>
</li>
<li><p>ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p>
</li>
</ul>
<p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p>
<p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>测试步骤：</p>
<p>1、我们可以在首页编写一个提交的表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/e/t&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、后台编写对应的处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Encoding</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/e/t&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model,String name)</span></span>&#123;</span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>,name); <span class="comment">//获取表单提交的值</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>; <span class="comment">//跳转到test页面显示输入的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、输入中文测试，发现乱码</p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\SpringMVC\640" alt="图片"></p>
<p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p>
<p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p>
<p>修改了xml文件需要重启服务器！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p>
<p>处理方法 :</p>
<p>1、修改tomcat配置文件 ：设置编码！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、自定义过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       <span class="comment">//处理response的字符编码</span></span><br><span class="line">       HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">       myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">       HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">       <span class="comment">// 对request包装增强</span></span><br><span class="line">       HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">       chain.doFilter(myrequest, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">   <span class="comment">//是否编码的标记</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">   <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">       <span class="keyword">this</span>.request = request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先获得请求方式</span></span><br><span class="line">       String method = request.getMethod();</span><br><span class="line">       <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">           <span class="comment">// post请求</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 处理post乱码</span></span><br><span class="line">               request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">           <span class="comment">// get请求</span></span><br><span class="line">           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">           <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">               <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                   String[] values = parameterMap.get(parameterName);</span><br><span class="line">                   <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="comment">// 处理get乱码</span></span><br><span class="line">                               values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                      .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                               e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">               hasEncode = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="keyword">return</span> parameterMap;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//取一个值</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">       String[] values = parameterMap.get(name);</span><br><span class="line">       <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//取所有值</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">       Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">       String[] values = parameterMap.get(name);</span><br><span class="line">       <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p>
<p><strong>然后在web.xml中配置这个过滤器即可！</strong></p>
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>
<h3 id="统一环境编码为utf-8"><a href="#统一环境编码为utf-8" class="headerlink" title="统一环境编码为utf-8"></a>统一环境编码为utf-8</h3><p>环境为 win10、idea、tomcat9  </p>
<ul>
<li><p>win10</p>
<ul>
<li><p>方式一：设置系统全局默认编码为utf-8 (原bat文件等文件会乱码)<br>好处是以后创建文件编码默认都为utf-8</p>
<img src="/2021-03-SpringMVC/image-20210316081323129.png" class="">
</li>
<li><p>方式二：针对cmd命令设置默认编码为utf-8（需要使用cmd运行jar，war包）<br>使用方式一 后cmd窗口默认编码也变为了utf-8，原本是gbk</p>
<ul>
<li>一次性：cmd执行chcp 65001（65001代表utf-8编码），当前窗口编码为utf-8.</li>
<li>永久:win+R,输入regedit,路径：<br><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor</code>,<br>空白处右键新建字符串值,名称autorun,值65001<img src="/2021-03-SpringMVC/image-20210316085717853.png" class="">
</li>
</ul>
</li>
</ul>
</li>
<li><p>idea</p>
<ul>
<li><p>idea虚拟机配置  加上-Dfile.encoding=UTF-8</p>
<p>菜单栏 Help-Edit custon VM options</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># custom IntelliJ IDEA VM options</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=240m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>idea-tomcat虚拟机配置 加上-Dfile.encoding=UTF-8      （貌似没啥用）</p>
<img src="/2021-03-SpringMVC/image-20210316091320237.png" class="">
</li>
<li><p>java文件编码  全设置为utf-8</p>
<img src="/2021-03-SpringMVC/image-20210316091010393.png" class="">
</li>
</ul>
</li>
<li><p>tomcat</p>
<ul>
<li><p>server.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>logging.properties  5个编码为utf-8</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1catalina.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2localhost.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3manager.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4host-manager.org.apache.juli.AsyncFileHandler.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>starup.bat</li>
</ul>
<p>将 <code>call &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%</code> 修改为 <code>call &quot;%EXECUTABLE%&quot; run %CMD_LINE_ARGS%</code></p>
<ul>
<li>catalina.bat</li>
</ul>
<p>将 <code>set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;</code> 修改为 <code>set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS% -Dfile.encoding=UTF-8&quot;</code></p>
</li>
</ul>
</li>
<li><p>SpringMVC</p>
<ul>
<li><p>web.xml  添加字节过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>json  springmvc-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="整合SSM"><a href="#整合SSM" class="headerlink" title="整合SSM"></a>整合SSM</h2><blockquote>
<p>环境要求</p>
</blockquote>
<p>环境：</p>
<ul>
<li><p>IDEA</p>
</li>
<li><p>MySQL 5.7.19</p>
</li>
<li><p>Tomcat 9</p>
</li>
<li><p>Maven 3.6</p>
<p>要求：</p>
</li>
<li><p>需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；</p>
</li>
</ul>
<h3 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h3><p>创建一个存放书籍数据的数据库表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &#96;ssmbuild&#96;;</span><br><span class="line"></span><br><span class="line">USE &#96;ssmbuild&#96;;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS &#96;books&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;books&#96; (</span><br><span class="line">&#96;bookID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,</span><br><span class="line">&#96;bookName&#96; VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,</span><br><span class="line">&#96;bookCounts&#96; INT(11) NOT NULL COMMENT &#39;数量&#39;,</span><br><span class="line">&#96;detail&#96; VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,</span><br><span class="line">KEY &#96;bookID&#96; (&#96;bookID&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line"></span><br><span class="line">INSERT  INTO &#96;books&#96;(&#96;bookID&#96;,&#96;bookName&#96;,&#96;bookCounts&#96;,&#96;detail&#96;)VALUES</span><br><span class="line">(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),</span><br><span class="line">(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),</span><br><span class="line">(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);</span><br></pre></td></tr></table></figure>



<h3 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h3><p>1、新建一Maven项目！ssmbuild ， 添加web的支持</p>
<p>2、导入相关的pom依赖！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;!--Junit--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;!--数据库驱动--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--Servlet - JSP --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--Mybatis--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.5.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--Spring--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>3、Maven资源过滤设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>4、建立基本结构和配置框架！</p>
<ul>
<li><p>com.kuang.pojo</p>
</li>
<li><p>com.kuang.dao</p>
</li>
<li><p>com.kuang.service</p>
</li>
<li><p>com.kuang.controller</p>
</li>
<li><p>mybatis-config.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h3><p>1、数据库配置文件 <strong>database.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;123456</span><br></pre></td></tr></table></figure>

<p>2、IDEA关联数据库</p>
<p>3、编写MyBatis的核心配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h3><p>编写数据库对应的实体类 com.kuang.pojo.Books</p>
<p>使用lombok插件！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Books &#123;</span><br><span class="line">   </span><br><span class="line">   private int bookID;</span><br><span class="line">   private String bookName;</span><br><span class="line">   private int bookCounts;</span><br><span class="line">   private String detail;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>编写Dao层的 Mapper接口！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.dao;</span><br><span class="line"></span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;增加一个Book</span><br><span class="line">   int addBook(Books book);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;根据id删除一个Book</span><br><span class="line">   int deleteBookById(int id);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;更新Book</span><br><span class="line">   int updateBook(Books books);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;根据id查询,返回一个Book</span><br><span class="line">   Books queryBookById(int id);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;查询全部Book,返回list集合</span><br><span class="line">   List&lt;Books&gt; queryAllBook();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.kuang.dao.BookMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--增加一个Book--&gt;</span><br><span class="line">   &lt;insert id&#x3D;&quot;addBook&quot; parameterType&#x3D;&quot;Books&quot;&gt;</span><br><span class="line">      insert into ssmbuild.books(bookName,bookCounts,detail)</span><br><span class="line">      values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)</span><br><span class="line">   &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--根据id删除一个Book--&gt;</span><br><span class="line">   &lt;delete id&#x3D;&quot;deleteBookById&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">      delete from ssmbuild.books where bookID&#x3D;#&#123;bookID&#125;</span><br><span class="line">   &lt;&#x2F;delete&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--更新Book--&gt;</span><br><span class="line">   &lt;update id&#x3D;&quot;updateBook&quot; parameterType&#x3D;&quot;Books&quot;&gt;</span><br><span class="line">      update ssmbuild.books</span><br><span class="line">      set bookName &#x3D; #&#123;bookName&#125;,bookCounts &#x3D; #&#123;bookCounts&#125;,detail &#x3D; #&#123;detail&#125;</span><br><span class="line">      where bookID &#x3D; #&#123;bookID&#125;</span><br><span class="line">   &lt;&#x2F;update&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--根据id查询,返回一个Book--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;queryBookById&quot; resultType&#x3D;&quot;Books&quot;&gt;</span><br><span class="line">      select * from ssmbuild.books</span><br><span class="line">      where bookID &#x3D; #&#123;bookID&#125;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--查询全部Book--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;queryAllBook&quot; resultType&#x3D;&quot;Books&quot;&gt;</span><br><span class="line">      SELECT * from ssmbuild.books</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><p>编写Service层的接口和实现类</p>
<p>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.service;</span><br><span class="line"></span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BookService:底下需要去实现,调用dao层</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">   &#x2F;&#x2F;增加一个Book</span><br><span class="line">   int addBook(Books book);</span><br><span class="line">   &#x2F;&#x2F;根据id删除一个Book</span><br><span class="line">   int deleteBookById(int id);</span><br><span class="line">   &#x2F;&#x2F;更新Book</span><br><span class="line">   int updateBook(Books books);</span><br><span class="line">   &#x2F;&#x2F;根据id查询,返回一个Book</span><br><span class="line">   Books queryBookById(int id);</span><br><span class="line">   &#x2F;&#x2F;查询全部Book,返回list集合</span><br><span class="line">   List&lt;Books&gt; queryAllBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.service;</span><br><span class="line"></span><br><span class="line">import com.kuang.dao.BookMapper;</span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;调用dao层的操作，设置一个set接口，方便Spring管理</span><br><span class="line">   private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">   public void setBookMapper(BookMapper bookMapper) &#123;</span><br><span class="line">       this.bookMapper &#x3D; bookMapper;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public int addBook(Books book) &#123;</span><br><span class="line">       return bookMapper.addBook(book);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public int deleteBookById(int id) &#123;</span><br><span class="line">       return bookMapper.deleteBookById(id);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public int updateBook(Books books) &#123;</span><br><span class="line">       return bookMapper.updateBook(books);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public Books queryBookById(int id) &#123;</span><br><span class="line">       return bookMapper.queryBookById(id);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public List&lt;Books&gt; queryAllBook() &#123;</span><br><span class="line">       return bookMapper.queryAllBook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OK，到此，底层需求操作编写完毕！</strong></p>
<h3 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h3><h4 id="Spring整合Mybatis层"><a href="#Spring整合Mybatis层" class="headerlink" title="Spring整合Mybatis层"></a>Spring整合Mybatis层</h4><p>1、这里数据源使用c3p0连接池；</p>
<p>2、编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置整合mybatis --&gt;</span><br><span class="line">   &lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="line">   &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">   &lt;!--数据库连接池</span><br><span class="line">       dbcp 半自动化操作 不能自动连接</span><br><span class="line">       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">       &lt;!-- 配置连接池属性 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">       &lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="line">   &lt;!--解释 ：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jpfss&#x2F;p&#x2F;7799806.html--&gt;</span><br><span class="line">   &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">       &lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.kuang.dao&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Spring整合service层"><a href="#Spring整合service层" class="headerlink" title="Spring整合service层"></a><strong>Spring整合service层</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 扫描service相关的bean --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.service&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--BookServiceImpl注入到IOC容器中--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;BookServiceImpl&quot; class&#x3D;&quot;com.kuang.service.BookServiceImpl&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;bookMapper&quot; ref&#x3D;&quot;bookMapper&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">       &lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！</p>
<h3 id="SpringMVC层"><a href="#SpringMVC层" class="headerlink" title="SpringMVC层"></a>SpringMVC层</h3><p>1、<strong>web.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;</span><br><span class="line">        version&#x3D;&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--DispatcherServlet--&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;  </span><br><span class="line">           &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">       &lt;&#x2F;init-param&gt;</span><br><span class="line">       &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">   &lt;&#x2F;servlet&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">   &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--encodingFilter--&gt;</span><br><span class="line">   &lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;</span><br><span class="line">          org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">       &lt;&#x2F;filter-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">           &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;</span><br><span class="line">       &lt;&#x2F;init-param&gt;</span><br><span class="line">   &lt;&#x2F;filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">   &lt;&#x2F;filter-mapping&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;!--Session过期时间--&gt;</span><br><span class="line">   &lt;session-config&gt;</span><br><span class="line">       &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;</span><br><span class="line">   &lt;&#x2F;session-config&gt;</span><br><span class="line">   </span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>

<p>2、<strong>spring-mvc.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">   https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置SpringMVC --&gt;</span><br><span class="line">   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span><br><span class="line">   &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line">   &lt;!-- 2.静态资源默认servlet配置--&gt;</span><br><span class="line">   &lt;mvc:default-servlet-handler&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;</span><br><span class="line">   &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot; &#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Spring配置整合文件，applicationContext-xml"><a href="#Spring配置整合文件，applicationContext-xml" class="headerlink" title="Spring配置整合文件，applicationContext.xml"></a><strong>Spring配置整合文件，applicationContext.xml</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;import resource&#x3D;&quot;spring-dao.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;import resource&#x3D;&quot;spring-service.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;import resource&#x3D;&quot;spring-mvc.xml&quot;&#x2F;&gt;</span><br><span class="line">   </span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Controller层-和-视图层"><a href="#Controller层-和-视图层" class="headerlink" title="Controller层 和 视图层"></a>Controller层 和 视图层</h3><p>1、BookController 类编写 ， 方法一：查询全部书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;book&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   @Qualifier(&quot;BookServiceImpl&quot;)</span><br><span class="line">   private BookService bookService;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;&#x2F;allBook&quot;)</span><br><span class="line">   public String list(Model model) &#123;</span><br><span class="line">       List&lt;Books&gt; list &#x3D; bookService.queryAllBook();</span><br><span class="line">       model.addAttribute(&quot;list&quot;, list);</span><br><span class="line">       return &quot;allBook&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、编写首页 <strong>index.jsp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;首页&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">       a &#123;</span><br><span class="line">           text-decoration: none;</span><br><span class="line">           color: black;</span><br><span class="line">           font-size: 18px;</span><br><span class="line">      &#125;</span><br><span class="line">       h3 &#123;</span><br><span class="line">           width: 180px;</span><br><span class="line">           height: 38px;</span><br><span class="line">           margin: 100px auto;</span><br><span class="line">           text-align: center;</span><br><span class="line">           line-height: 38px;</span><br><span class="line">           background: deepskyblue;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;</span><br><span class="line">   &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;allBook&quot;&gt;点击进入列表页&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>3、书籍列表页面 <strong>allbook.jsp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;书籍列表&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;&#x2F;small&gt;</span><br><span class="line">               &lt;&#x2F;h1&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt;</span><br><span class="line">           &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toAddBook&quot;&gt;新增&lt;&#x2F;a&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;</span><br><span class="line">           &lt;table class&#x3D;&quot;table table-hover table-striped&quot;&gt;</span><br><span class="line">               &lt;thead&gt;</span><br><span class="line">               &lt;tr&gt;</span><br><span class="line">                   &lt;th&gt;书籍编号&lt;&#x2F;th&gt;</span><br><span class="line">                   &lt;th&gt;书籍名字&lt;&#x2F;th&gt;</span><br><span class="line">                   &lt;th&gt;书籍数量&lt;&#x2F;th&gt;</span><br><span class="line">                   &lt;th&gt;书籍详情&lt;&#x2F;th&gt;</span><br><span class="line">                   &lt;th&gt;操作&lt;&#x2F;th&gt;</span><br><span class="line">               &lt;&#x2F;tr&gt;</span><br><span class="line">               &lt;&#x2F;thead&gt;</span><br><span class="line"></span><br><span class="line">               &lt;tbody&gt;</span><br><span class="line">               &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt;</span><br><span class="line">                   &lt;tr&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookID()&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookName()&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getDetail()&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                       &lt;td&gt;</span><br><span class="line">                           &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toUpdateBook?id&#x3D;$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;&#x2F;a&gt; |</span><br><span class="line">                           &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;del&#x2F;$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class="line">                       &lt;&#x2F;td&gt;</span><br><span class="line">                   &lt;&#x2F;tr&gt;</span><br><span class="line">               &lt;&#x2F;c:forEach&gt;</span><br><span class="line">               &lt;&#x2F;tbody&gt;</span><br><span class="line">           &lt;&#x2F;table&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>4、BookController 类编写 ， 方法二：添加书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;toAddBook&quot;)</span><br><span class="line">public String toAddPaper() &#123;</span><br><span class="line">   return &quot;addBook&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;addBook&quot;)</span><br><span class="line">public String addPaper(Books books) &#123;</span><br><span class="line">   System.out.println(books);</span><br><span class="line">   bookService.addBook(books);</span><br><span class="line">   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、添加书籍页面：<strong>addBook.jsp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;新增书籍&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;新增书籍&lt;&#x2F;small&gt;</span><br><span class="line">               &lt;&#x2F;h1&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">      书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">      书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">      书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;添加&quot;&gt;</span><br><span class="line">   &lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>6、BookController 类编写 ， 方法三：修改书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;toUpdateBook&quot;)</span><br><span class="line">public String toUpdateBook(Model model, int id) &#123;</span><br><span class="line">   Books books &#x3D; bookService.queryBookById(id);</span><br><span class="line">   System.out.println(books);</span><br><span class="line">   model.addAttribute(&quot;book&quot;,books );</span><br><span class="line">   return &quot;updateBook&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;updateBook&quot;)</span><br><span class="line">public String updateBook(Model model, Books book) &#123;</span><br><span class="line">   System.out.println(book);</span><br><span class="line">   bookService.updateBook(book);</span><br><span class="line">   Books books &#x3D; bookService.queryBookById(book.getBookID());</span><br><span class="line">   model.addAttribute(&quot;books&quot;, books);</span><br><span class="line">   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、修改书籍页面  <strong>updateBook.jsp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;修改信息&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;修改信息&lt;&#x2F;small&gt;</span><br><span class="line">               &lt;&#x2F;h1&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;book.getBookID()&#125;&quot;&#x2F;&gt;</span><br><span class="line">      书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot; value&#x3D;&quot;$&#123;book.getBookName()&#125;&quot;&#x2F;&gt;</span><br><span class="line">      书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot; value&#x3D;&quot;$&#123;book.getBookCounts()&#125;&quot;&#x2F;&gt;</span><br><span class="line">      书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot; value&#x3D;&quot;$&#123;book.getDetail() &#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>8、BookController 类编写 ， 方法四：删除书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;del&#x2F;&#123;bookId&#125;&quot;)</span><br><span class="line">public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123;</span><br><span class="line">   bookService.deleteBookById(id);</span><br><span class="line">   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置Tomcat，进行运行！</strong></p>
<p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！</p>
<p><strong>项目结构图</strong> </p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\SpringMVC\640" alt="图片"></p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\SpringMVC\640" alt="图片"></p>
<blockquote>
<p>小结及展望</p>
</blockquote>
<p>这个是同学们的第一个SSM整合案例，一定要烂熟于心！</p>
<p>SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的底线。</p>
<p>或许很多人，工作就做这些事情，但是对于个人的提高来说，还远远不够！</p>
<p>我们后面还要学习一些 SpringMVC 的知识！</p>
<ul>
<li>Ajax  和  Json</li>
<li>文件上传和下载</li>
<li>拦截器</li>
</ul>
<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><blockquote>
<p>什么是JSON？</p>
</blockquote>
<ul>
<li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;</span><br><span class="line">&#123;&quot;age&quot;: &quot;3&quot;&#125;</span><br><span class="line">&#123;&quot;sex&quot;: &quot;男&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;; &#x2F;&#x2F;这是一个对象，注意键名也是可以使用引号包裹的</span><br><span class="line">var json &#x3D; &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;; &#x2F;&#x2F;这是一个 JSON 字符串，本质是一个字符串</span><br></pre></td></tr></table></figure>



<p><strong>JSON 和 JavaScript 对象互转</strong></p>
<p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);</span><br><span class="line">&#x2F;&#x2F;结果是 &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var json &#x3D; JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);</span><br><span class="line">&#x2F;&#x2F;结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>



<p><strong>代码测试</strong></p>
<p>1、新建一个module ，springmvc-05-json ， 添加web的支持</p>
<p>2、在web目录下新建一个 json-1.html ， 编写测试内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;JSON_秦疆&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">   &#x2F;&#x2F;编写一个js的对象</span><br><span class="line">   var user &#x3D; &#123;</span><br><span class="line">       name:&quot;秦疆&quot;,</span><br><span class="line">       age:3,</span><br><span class="line">       sex:&quot;男&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">   &#x2F;&#x2F;将js对象转换成json字符串</span><br><span class="line">   var str &#x3D; JSON.stringify(user);</span><br><span class="line">   console.log(str);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;将json字符串转换为js对象</span><br><span class="line">   var user2 &#x3D; JSON.parse(str);</span><br><span class="line">   console.log(user2.age,user2.name,user2.sex);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>3、在IDEA中使用浏览器打开，查看控制台输出！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<blockquote>
<p>Controller返回JSON数据</p>
</blockquote>
<p>Jackson应该是目前比较好的json解析工具了</p>
<p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p>
<p>我们这里使用Jackson，使用它需要导入它的jar包；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.fasterxml.jackson.core&#x2F;jackson-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置SpringMVC需要的配置</p>
<p>web.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;</span><br><span class="line">        version&#x3D;&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--1.注册servlet--&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">           &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">       &lt;&#x2F;init-param&gt;</span><br><span class="line">       &lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span><br><span class="line">       &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">   &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--所有请求都会被springmvc拦截 --&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">   &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">           &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;</span><br><span class="line">       &lt;&#x2F;init-param&gt;</span><br><span class="line">   &lt;&#x2F;filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">   &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>

<p>springmvc-servlet.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 视图解析器 --&gt;</span><br><span class="line">   &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">         id&#x3D;&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">       &lt;!-- 前缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">       &lt;!-- 后缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要导入lombok</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   private String sex;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法</p>
<p>编写一个Controller；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;&#x2F;json1&quot;)</span><br><span class="line">   @ResponseBody</span><br><span class="line">   public String json1() throws JsonProcessingException &#123;</span><br><span class="line">       &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">       ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">       &#x2F;&#x2F;创建一个对象</span><br><span class="line">       User user &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       &#x2F;&#x2F;将我们的对象解析成为json格式</span><br><span class="line">       String str &#x3D; mapper.writeValueAsString(user);</span><br><span class="line">       &#x2F;&#x2F;由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span><br><span class="line">       return str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置Tomcat ， 启动测试一下！</p>
<p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2pzb24x">http://localhost:8080/json1<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p>
<p>通过@RequestMaping的produces属性来实现，修改下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;produces:指定响应体返回类型和编码</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;json1&quot;,produces &#x3D; &quot;application&#x2F;json;charset&#x3D;utf-8&quot;)</span><br></pre></td></tr></table></figure>

<p>再次测试， <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2pzb24x">http://localhost:8080/json1<i class="fa fa-external-link-alt"></i></span> ， 乱码问题OK！</p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\SpringMVC\640" alt="图片"></p>
<p>【注意：使用json记得处理乱码问题】</p>
<blockquote>
<p>代码优化</p>
</blockquote>
<p><strong>乱码统一解决</strong></p>
<p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p>
<p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">   &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class="line">           &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;bean&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class="line">           &lt;property name&#x3D;&quot;objectMapper&quot;&gt;</span><br><span class="line">               &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;</span><br><span class="line">                   &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">               &lt;&#x2F;bean&gt;</span><br><span class="line">           &lt;&#x2F;property&gt;</span><br><span class="line">       &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;&#x2F;mvc:message-converters&gt;</span><br><span class="line">&lt;&#x2F;mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>



<p><strong>返回json字符串统一解决</strong></p>
<p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;produces:指定响应体返回类型和编码</span><br><span class="line">   @RequestMapping(value &#x3D; &quot;&#x2F;json1&quot;)</span><br><span class="line">   public String json1() throws JsonProcessingException &#123;</span><br><span class="line">       &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">       ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">       &#x2F;&#x2F;创建一个对象</span><br><span class="line">       User user &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       &#x2F;&#x2F;将我们的对象解析成为json格式</span><br><span class="line">       String str &#x3D; mapper.writeValueAsString(user);</span><br><span class="line">       &#x2F;&#x2F;由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span><br><span class="line">       return str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动tomcat测试，结果都正常输出！</p>
<blockquote>
<p>测试集合输出</p>
</blockquote>
<p>增加一个新的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;json2&quot;)</span><br><span class="line">public String json2() throws JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">   ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">   &#x2F;&#x2F;创建一个对象</span><br><span class="line">   User user1 &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">   User user2 &#x3D; new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);</span><br><span class="line">   User user3 &#x3D; new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);</span><br><span class="line">   User user4 &#x3D; new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);</span><br><span class="line">   List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();</span><br><span class="line">   list.add(user1);</span><br><span class="line">   list.add(user2);</span><br><span class="line">   list.add(user3);</span><br><span class="line">   list.add(user4);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;将我们的对象解析成为json格式</span><br><span class="line">   String str &#x3D; mapper.writeValueAsString(list);</span><br><span class="line">   return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果 : 十分完美，没有任何问题！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<blockquote>
<p>输出时间对象</p>
</blockquote>
<p>增加一个新的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;json3&quot;)</span><br><span class="line">public String json3() throws JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">   ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;创建时间一个对象，java.util.Date</span><br><span class="line">   Date date &#x3D; new Date();</span><br><span class="line">   &#x2F;&#x2F;将我们的对象解析成为json格式</span><br><span class="line">   String str &#x3D; mapper.writeValueAsString(date);</span><br><span class="line">   return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果 :</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<ul>
<li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li>
<li>Jackson 默认是会把时间转成timestamps形式</li>
</ul>
<p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;json4&quot;)</span><br><span class="line">public String json4() throws JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">   ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;不使用时间戳的方式</span><br><span class="line">   mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line">   &#x2F;&#x2F;自定义日期格式对象</span><br><span class="line">   SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">   &#x2F;&#x2F;指定日期格式</span><br><span class="line">   mapper.setDateFormat(sdf);</span><br><span class="line"></span><br><span class="line">   Date date &#x3D; new Date();</span><br><span class="line">   String str &#x3D; mapper.writeValueAsString(date);</span><br><span class="line"></span><br><span class="line">   return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果 : 成功的输出了时间！</p>
<p><img src="D:\project\Mw-Blog\source_posts\2021\02\SpringMVC\640" alt="图片"></p>
<blockquote>
<p>抽取为工具类</p>
</blockquote>
<p><strong>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.utils;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line">public class JsonUtils &#123;</span><br><span class="line">   </span><br><span class="line">   public static String getJson(Object object) &#123;</span><br><span class="line">       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public static String getJson(Object object,String dateFormat) &#123;</span><br><span class="line">       ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">       &#x2F;&#x2F;不使用时间差的方式</span><br><span class="line">       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line">       &#x2F;&#x2F;自定义日期格式对象</span><br><span class="line">       SimpleDateFormat sdf &#x3D; new SimpleDateFormat(dateFormat);</span><br><span class="line">       &#x2F;&#x2F;指定日期格式</span><br><span class="line">       mapper.setDateFormat(sdf);</span><br><span class="line">       try &#123;</span><br><span class="line">           return mapper.writeValueAsString(object);</span><br><span class="line">      &#125; catch (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">       return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用工具类，代码就更加简洁了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;json5&quot;)</span><br><span class="line">public String json5() throws JsonProcessingException &#123;</span><br><span class="line">   Date date &#x3D; new Date();</span><br><span class="line">   String json &#x3D; JsonUtils.getJson(date);</span><br><span class="line">   return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成！完美！</p>
<blockquote>
<p>FastJson</p>
</blockquote>
<p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p>
<p>fastjson 的 pom依赖！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.60&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>fastjson 三个主要的类：</p>
<p><strong>JSONObject  代表 json 对象</strong> </p>
<ul>
<li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li>
<li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
<p><strong>JSONArray  代表 json 对象数组</strong></p>
<ul>
<li>内部是有List接口中的方法来完成操作的。</li>
</ul>
<p><strong>JSON代表 JSONObject和JSONArray的转化</strong></p>
<ul>
<li>JSON类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li>
</ul>
<p><strong>代码测试，我们新建一个FastJsonDemo 类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.kuang.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FastJsonDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;创建一个对象</span><br><span class="line">       User user1 &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       User user2 &#x3D; new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       User user3 &#x3D; new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       User user4 &#x3D; new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);</span><br><span class="line">       List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();</span><br><span class="line">       list.add(user1);</span><br><span class="line">       list.add(user2);</span><br><span class="line">       list.add(user3);</span><br><span class="line">       list.add(user4);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);</span><br><span class="line">       String str1 &#x3D; JSON.toJSONString(list);</span><br><span class="line">       System.out.println(&quot;JSON.toJSONString(list)&#x3D;&#x3D;&gt;&quot;+str1);</span><br><span class="line">       String str2 &#x3D; JSON.toJSONString(user1);</span><br><span class="line">       System.out.println(&quot;JSON.toJSONString(user1)&#x3D;&#x3D;&gt;&quot;+str2);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);</span><br><span class="line">       User jp_user1&#x3D;JSON.parseObject(str2,User.class);</span><br><span class="line">       System.out.println(&quot;JSON.parseObject(str2,User.class)&#x3D;&#x3D;&gt;&quot;+jp_user1);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);</span><br><span class="line">       JSONObject jsonObject1 &#x3D; (JSONObject) JSON.toJSON(user2);</span><br><span class="line">       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)&#x3D;&#x3D;&gt;&quot;+jsonObject1.getString(&quot;name&quot;));</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);</span><br><span class="line">       User to_java_user &#x3D; JSON.toJavaObject(jsonObject1, User.class);</span><br><span class="line">       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)&#x3D;&#x3D;&gt;&quot;+to_java_user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！</p>
<p>Json在我们数据传输中十分重要，一定要学会使用！</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><blockquote>
<p>简介</p>
</blockquote>
<ul>
<li><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></p>
</li>
<li><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
</li>
<li><p><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></p>
</li>
<li><p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</p>
</li>
<li><p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p>
</li>
<li><p>就和国内百度的搜索框一样!</p>
</li>
<li><p>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</p>
</li>
<li><p>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</p>
</li>
<li><p>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</p>
</li>
</ul>
<blockquote>
<p>伪造Ajax</p>
</blockquote>
<p>我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签</p>
<p>1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！</p>
<p>2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;kuangshen&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">   window.onload &#x3D; function()&#123;</span><br><span class="line">       var myDate &#x3D; new Date();</span><br><span class="line">       document.getElementById(&#39;currentTime&#39;).innerText &#x3D; myDate.getTime();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   function LoadPage()&#123;</span><br><span class="line">       var targetUrl &#x3D;  document.getElementById(&#39;url&#39;).value;</span><br><span class="line">       console.log(targetUrl);</span><br><span class="line">       document.getElementById(&quot;iframePosition&quot;).src &#x3D; targetUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;p&gt;请输入要加载的地址：&lt;span id&#x3D;&quot;currentTime&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">   &lt;p&gt;</span><br><span class="line">       &lt;input id&#x3D;&quot;url&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;LoadPage()&quot;&gt;</span><br><span class="line">   &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;h3&gt;加载页面位置：&lt;&#x2F;h3&gt;</span><br><span class="line">   &lt;iframe id&#x3D;&quot;iframePosition&quot; style&#x3D;&quot;width: 100%;height: 500px;&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>3、使用IDEA开浏览器测试一下！</p>
<p><strong>利用AJAX可以做：</strong></p>
<ul>
<li>注册时，输入用户名自动检测用户是否已经存在。</li>
<li>登陆时，提示用户名密码错误</li>
<li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li>
<li>….等等</li>
</ul>
<blockquote>
<p>jQuery.ajax</p>
</blockquote>
<p>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</p>
<p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p>
<p>jQuery 提供多个与 AJAX 有关的方法。</p>
<p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p>
<p>jQuery 不是生产者，而是大自然搬运工。</p>
<p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.ajax(...)</span><br><span class="line">      部分参数：</span><br><span class="line">            url：请求地址</span><br><span class="line">            type：请求方式，GET、POST（1.9.0之后用method）</span><br><span class="line">        headers：请求头</span><br><span class="line">            data：要发送的数据</span><br><span class="line">    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)</span><br><span class="line">          async：是否异步</span><br><span class="line">        timeout：设置请求超时时间（毫秒）</span><br><span class="line">      beforeSend：发送请求前执行的函数(全局)</span><br><span class="line">        complete：完成之后执行的回调函数(全局)</span><br><span class="line">        success：成功之后执行的回调函数(全局)</span><br><span class="line">          error：失败之后执行的回调函数(全局)</span><br><span class="line">        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型</span><br><span class="line">        dataType：将服务器端返回的数据转换成指定类型</span><br><span class="line">          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式</span><br><span class="line">          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式</span><br><span class="line">          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。</span><br><span class="line">        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式</span><br><span class="line">          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class="line">        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</span><br></pre></td></tr></table></figure>

<p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p>
<p>1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;</span><br><span class="line">   &lt;mvc:default-servlet-handler &#x2F;&gt;</span><br><span class="line">   &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 视图解析器 --&gt;</span><br><span class="line">   &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">         id&#x3D;&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">       &lt;!-- 前缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">       &lt;!-- 后缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>2、编写一个AjaxController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class AjaxController &#123;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;&#x2F;a1&quot;)</span><br><span class="line">   public void ajax1(String name , HttpServletResponse response) throws IOException &#123;</span><br><span class="line">       if (&quot;admin&quot;.equals(name))&#123;</span><br><span class="line">           response.getWriter().print(&quot;true&quot;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">           response.getWriter().print(&quot;false&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>4、编写index.jsp测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">   &lt;title&gt;$Title$&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;%--&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;--%&gt;</span><br><span class="line">   &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       function a1()&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a1&quot;,</span><br><span class="line">               data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,</span><br><span class="line">               success:function (data,status) &#123;</span><br><span class="line">                   alert(data);</span><br><span class="line">                   alert(status);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line"> &lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--onblur：失去焦点触发事件--%&gt;</span><br><span class="line">用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txtName&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p>
<p><strong>Springmvc实现</strong></p>
<p>实体类user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   private String sex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来获取一个集合对象，展示到前端页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;a2&quot;)</span><br><span class="line">public List&lt;User&gt; ajax2()&#123;</span><br><span class="line">   List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();</span><br><span class="line">   list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));</span><br><span class="line">   list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));</span><br><span class="line">   list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));</span><br><span class="line">   return list; &#x2F;&#x2F;由于@RestController注解，将list转成json格式返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;获取数据&quot;&#x2F;&gt;</span><br><span class="line">&lt;table width&#x3D;&quot;80%&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">       &lt;td&gt;姓名&lt;&#x2F;td&gt;</span><br><span class="line">       &lt;td&gt;年龄&lt;&#x2F;td&gt;</span><br><span class="line">       &lt;td&gt;性别&lt;&#x2F;td&gt;</span><br><span class="line">   &lt;&#x2F;tr&gt;</span><br><span class="line">   &lt;tbody id&#x3D;&quot;content&quot;&gt;</span><br><span class="line">   &lt;&#x2F;tbody&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   $(function () &#123;</span><br><span class="line">       $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">           $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123;</span><br><span class="line">               console.log(data)</span><br><span class="line">               var html&#x3D;&quot;&quot;;</span><br><span class="line">               for (var i &#x3D; 0; i &lt;data.length ; i++) &#123;</span><br><span class="line">                   html+&#x3D; &quot;&lt;tr&gt;&quot; +</span><br><span class="line">                       &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;&#x2F;td&gt;&quot; +</span><br><span class="line">                       &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;&#x2F;td&gt;&quot; +</span><br><span class="line">                       &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;&#x2F;td&gt;&quot; +</span><br><span class="line">                       &quot;&lt;&#x2F;tr&gt;&quot;</span><br><span class="line">              &#125;</span><br><span class="line">               $(&quot;#content&quot;).html(html);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p>
<blockquote>
<p>注册提示效果</p>
</blockquote>
<p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p>
<p>我们写一个Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;a3&quot;)</span><br><span class="line">public String ajax3(String name,String pwd)&#123;</span><br><span class="line">   String msg &#x3D; &quot;&quot;;</span><br><span class="line">   &#x2F;&#x2F;模拟数据库中存在数据</span><br><span class="line">   if (name!&#x3D;null)&#123;</span><br><span class="line">       if (&quot;admin&quot;.equals(name))&#123;</span><br><span class="line">           msg &#x3D; &quot;OK&quot;;</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">           msg &#x3D; &quot;用户名输入错误&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   if (pwd!&#x3D;null)&#123;</span><br><span class="line">       if (&quot;123456&quot;.equals(pwd))&#123;</span><br><span class="line">           msg &#x3D; &quot;OK&quot;;</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">           msg &#x3D; &quot;密码输入有误&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   return msg; &#x2F;&#x2F;由于@RestController注解，将msg转成json格式返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端页面 login.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;ajax&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line"></span><br><span class="line">       function a1()&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,</span><br><span class="line">               data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;,</span><br><span class="line">               success:function (data) &#123;</span><br><span class="line">                   if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123;</span><br><span class="line">                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);</span><br><span class="line">                  &#125;else &#123;</span><br><span class="line">                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                   $(&quot;#userInfo&quot;).html(data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">       function a2()&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,</span><br><span class="line">               data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;,</span><br><span class="line">               success:function (data) &#123;</span><br><span class="line">                   if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123;</span><br><span class="line">                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);</span><br><span class="line">                  &#125;else &#123;</span><br><span class="line">                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                   $(&quot;#pwdInfo&quot;).html(data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt;</span><br><span class="line">   &lt;span id&#x3D;&quot;userInfo&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  密码:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&#x2F;&gt;</span><br><span class="line">   &lt;span id&#x3D;&quot;pwdInfo&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>【记得处理json乱码问题】</p>
<p>测试一下效果，动态请求响应，局部刷新，就是如此！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<blockquote>
<p>获取baidu接口Demo</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;JSONP百度搜索&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">       #q&#123;</span><br><span class="line">           width: 500px;</span><br><span class="line">           height: 30px;</span><br><span class="line">           border:1px solid #ddd;</span><br><span class="line">           line-height: 30px;</span><br><span class="line">           display: block;</span><br><span class="line">           margin: 0 auto;</span><br><span class="line">           padding: 0 10px;</span><br><span class="line">           font-size: 14px;</span><br><span class="line">      &#125;</span><br><span class="line">       #ul&#123;</span><br><span class="line">           width: 520px;</span><br><span class="line">           list-style: none;</span><br><span class="line">           margin: 0 auto;</span><br><span class="line">           padding: 0;</span><br><span class="line">           border:1px solid #ddd;</span><br><span class="line">           margin-top: -1px;</span><br><span class="line">           display: none;</span><br><span class="line">      &#125;</span><br><span class="line">       #ul li&#123;</span><br><span class="line">           line-height: 30px;</span><br><span class="line">           padding: 0 10px;</span><br><span class="line">      &#125;</span><br><span class="line">       #ul li:hover&#123;</span><br><span class="line">           background-color: #f60;</span><br><span class="line">           color: #fff;</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 2.步骤二</span><br><span class="line">       &#x2F;&#x2F; 定义demo函数 (分析接口、数据)</span><br><span class="line">       function demo(data)&#123;</span><br><span class="line">           var Ul &#x3D; document.getElementById(&#39;ul&#39;);</span><br><span class="line">           var html &#x3D; &#39;&#39;;</span><br><span class="line">           &#x2F;&#x2F; 如果搜索数据存在 把内容添加进去</span><br><span class="line">           if (data.s.length) &#123;</span><br><span class="line">               &#x2F;&#x2F; 隐藏掉的ul显示出来</span><br><span class="line">               Ul.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">               &#x2F;&#x2F; 搜索到的数据循环追加到li里</span><br><span class="line">               for(var i &#x3D; 0;i&lt;data.s.length;i++)&#123;</span><br><span class="line">                   html +&#x3D; &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;&#x2F;li&gt;&#39;;</span><br><span class="line">              &#125;</span><br><span class="line">               &#x2F;&#x2F; 循环的li写入ul</span><br><span class="line">               Ul.innerHTML &#x3D; html;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 1.步骤一</span><br><span class="line">       window.onload &#x3D; function()&#123;</span><br><span class="line">           &#x2F;&#x2F; 获取输入框和ul</span><br><span class="line">           var Q &#x3D; document.getElementById(&#39;q&#39;);</span><br><span class="line">           var Ul &#x3D; document.getElementById(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 事件鼠标抬起时候</span><br><span class="line">           Q.onkeyup &#x3D; function()&#123;</span><br><span class="line">               &#x2F;&#x2F; 如果输入框不等于空</span><br><span class="line">               if (this.value !&#x3D; &#39;&#39;) &#123;</span><br><span class="line">                   &#x2F;&#x2F; ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line">                   &#x2F;&#x2F; 创建标签</span><br><span class="line">                   var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">                   &#x2F;&#x2F;给定要跨域的地址 赋值给src</span><br><span class="line">                   &#x2F;&#x2F;这里是要请求的跨域的地址 我写的是百度搜索的跨域地址</span><br><span class="line">                   script.src &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;&#39;+this.value+&#39;&amp;cb&#x3D;demo&#39;;</span><br><span class="line">                   &#x2F;&#x2F; 将组合好的带src的script标签追加到body里</span><br><span class="line">                   document.body.appendChild(script);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;q&quot; &#x2F;&gt;</span><br><span class="line">&lt;ul id&#x3D;&quot;ul&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<p>Ajax在我们开发中十分重要，一定要学会使用！</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><blockquote>
<p>概述</p>
</blockquote>
<p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<p><strong>过滤器</strong></p>
<ul>
<li>servlet规范中的一部分，任何java web工程都可以使用</li>
<li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
<p><strong>拦截器</strong> </p>
<ul>
<li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li>
</ul>
<blockquote>
<p>自定义拦截器</p>
</blockquote>
<p>那如何实现拦截器呢？</p>
<p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<p>1、新建一个Moudule ， springmvc-07-Interceptor  ， 添加web支持</p>
<p>2、配置web.xml 和 springmvc-servlet.xml 文件</p>
<p>3、编写一个拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.interceptor;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;在请求处理的方法之前执行</span><br><span class="line">   &#x2F;&#x2F;如果返回true执行下一个拦截器</span><br><span class="line">   &#x2F;&#x2F;如果返回false就不执行下一个拦截器</span><br><span class="line">   public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;------------处理前------------&quot;);</span><br><span class="line">       return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;在请求处理方法执行之后执行</span><br><span class="line">   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;------------处理后------------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;在dispatcherServlet处理后执行,做清理工作.</span><br><span class="line">   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;------------清理------------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在springmvc的配置文件中配置拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--关于拦截器的配置--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;!--&#x2F;** 包括路径及其子路径--&gt;</span><br><span class="line">       &lt;!--&#x2F;admin&#x2F;* 拦截的是&#x2F;admin&#x2F;add等等这种 , &#x2F;admin&#x2F;add&#x2F;user不会被拦截--&gt;</span><br><span class="line">       &lt;!--&#x2F;admin&#x2F;** 拦截的是&#x2F;admin&#x2F;下的所有--&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!--bean配置的就是拦截器--&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;com.kuang.interceptor.MyInterceptor&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<p>5、编写一个Controller，接收请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试拦截器的控制器</span><br><span class="line">@Controller</span><br><span class="line">public class InterceptorController &#123;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;&#x2F;interceptor&quot;)</span><br><span class="line">   @ResponseBody</span><br><span class="line">   public String testFunction() &#123;</span><br><span class="line">       System.out.println(&quot;控制器中的方法执行了&quot;);</span><br><span class="line">       return &quot;hello&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、前端 index.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;interceptor&quot;&gt;拦截器测试&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>7、启动tomcat 测试一下！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<blockquote>
<p>验证用户是否登录 (认证用户)</p>
</blockquote>
<p><strong>实现思路</strong></p>
<p>1、有一个登陆页面，需要写一个controller访问页面。</p>
<p>2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></p>
<p>3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p>
<p><strong>测试：</strong></p>
<p>1、编写一个登陆页面  login.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;登录页面&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;login&quot;&gt;</span><br><span class="line">  用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;br&gt;</span><br><span class="line">  密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pwd&quot;&gt; &lt;br&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>2、编写一个Controller处理请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;跳转到登陆页面</span><br><span class="line">   @RequestMapping(&quot;&#x2F;jumplogin&quot;)</span><br><span class="line">   public String jumpLogin() throws Exception &#123;</span><br><span class="line">       return &quot;login&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;跳转到成功页面</span><br><span class="line">   @RequestMapping(&quot;&#x2F;jumpSuccess&quot;)</span><br><span class="line">   public String jumpSuccess() throws Exception &#123;</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;登陆提交</span><br><span class="line">   @RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">   public String login(HttpSession session, String username, String pwd) throws Exception &#123;</span><br><span class="line">       &#x2F;&#x2F; 向session记录用户身份信息</span><br><span class="line">       System.out.println(&quot;接收前端&#x3D;&#x3D;&#x3D;&quot;+username);</span><br><span class="line">       session.setAttribute(&quot;user&quot;, username);</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;退出登陆</span><br><span class="line">   @RequestMapping(&quot;logout&quot;)</span><br><span class="line">   public String logout(HttpSession session) throws Exception &#123;</span><br><span class="line">       &#x2F;&#x2F; session 过期</span><br><span class="line">       session.invalidate();</span><br><span class="line">       return &quot;login&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写一个登陆成功的页面 success.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;登录成功页面&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">$&#123;user&#125;</span><br><span class="line">&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;logout&quot;&gt;注销&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">   &lt;title&gt;$Title$&lt;&#x2F;title&gt;</span><br><span class="line"> &lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;h1&gt;首页&lt;&#x2F;h1&gt;</span><br><span class="line"> &lt;hr&gt;</span><br><span class="line">&lt;%--登录--%&gt;</span><br><span class="line"> &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;jumplogin&quot;&gt;登录&lt;&#x2F;a&gt;</span><br><span class="line"> &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;jumpSuccess&quot;&gt;成功页面&lt;&#x2F;a&gt;</span><br><span class="line"> &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>5、编写用户登录拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.interceptor;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;</span><br><span class="line">       &#x2F;&#x2F; 如果是登陆页面则放行</span><br><span class="line">       System.out.println(&quot;uri: &quot; + request.getRequestURI());</span><br><span class="line">       if (request.getRequestURI().contains(&quot;login&quot;)) &#123;</span><br><span class="line">           return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       HttpSession session &#x3D; request.getSession();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果用户已登陆也放行</span><br><span class="line">       if(session.getAttribute(&quot;user&quot;) !&#x3D; null) &#123;</span><br><span class="line">           return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 用户没有登陆跳转到登陆页面</span><br><span class="line">       request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;login.jsp&quot;).forward(request, response);</span><br><span class="line">       return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、在Springmvc的配置文件中注册拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--关于拦截器的配置--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;</span><br><span class="line">       &lt;bean id&#x3D;&quot;loginInterceptor&quot; class&#x3D;&quot;com.kuang.interceptor.LoginInterceptor&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<p>7、再次重启Tomcat测试！</p>
<p><strong>OK，测试登录拦截功能无误.</strong></p>
<p>文件上传和下载</p>
<blockquote>
<p>准备工作</p>
</blockquote>
<p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p>
<p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li>
<li>而Spring MVC则提供了更简单的封装。</li>
<li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li>
<li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</li>
<li>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</li>
</ul>
<blockquote>
<p>文件上传</p>
</blockquote>
<p>1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.3.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--servlet-api导入高版本的--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.0.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置bean：multipartResolver</p>
<p>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传配置--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot;  class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">   &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;utf-8&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!-- 上传文件大小上限，单位为字节（10485760&#x3D;10M） --&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;10485760&quot;&#x2F;&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;40960&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>CommonsMultipartFile 的 常用方法：</p>
<ul>
<li><p><strong>String getOriginalFilename()：获取上传文件的原名</strong></p>
</li>
<li><p><strong>InputStream getInputStream()：获取文件流</strong></p>
</li>
<li><p><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></p>
<p>我们去实际测试一下</p>
</li>
</ul>
<p>3、编写前端页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line"> &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;</span><br><span class="line"> &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>4、<strong>Controller</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.multipart.commons.CommonsMultipartFile;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class FileController &#123;</span><br><span class="line">   &#x2F;&#x2F;@RequestParam(&quot;file&quot;) 将name&#x3D;file控件得到的文件封装成CommonsMultipartFile 对象</span><br><span class="line">   &#x2F;&#x2F;批量上传CommonsMultipartFile则为数组即可</span><br><span class="line">   @RequestMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">   public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;获取文件名 : file.getOriginalFilename();</span><br><span class="line">       String uploadFileName &#x3D; file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;如果文件名为空，直接回到首页！</span><br><span class="line">       if (&quot;&quot;.equals(uploadFileName))&#123;</span><br><span class="line">           return &quot;redirect:&#x2F;index.jsp&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(&quot;上传文件名 : &quot;+uploadFileName);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;上传路径保存设置</span><br><span class="line">       String path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);</span><br><span class="line">       &#x2F;&#x2F;如果路径不存在，创建一个</span><br><span class="line">       File realPath &#x3D; new File(path);</span><br><span class="line">       if (!realPath.exists())&#123;</span><br><span class="line">           realPath.mkdir();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(&quot;上传文件保存地址：&quot;+realPath);</span><br><span class="line"></span><br><span class="line">       InputStream is &#x3D; file.getInputStream(); &#x2F;&#x2F;文件输入流</span><br><span class="line">       OutputStream os &#x3D; new FileOutputStream(new File(realPath,uploadFileName)); &#x2F;&#x2F;文件输出流</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;读取写出</span><br><span class="line">       int len&#x3D;0;</span><br><span class="line">       byte[] buffer &#x3D; new byte[1024];</span><br><span class="line">       while ((len&#x3D;is.read(buffer))!&#x3D;-1)&#123;</span><br><span class="line">           os.write(buffer,0,len);</span><br><span class="line">           os.flush();</span><br><span class="line">      &#125;</span><br><span class="line">       os.close();</span><br><span class="line">       is.close();</span><br><span class="line">       return &quot;redirect:&#x2F;index.jsp&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试上传文件，OK！</p>
<p><strong>采用file.Transto 来保存上传的文件</strong></p>
<p>1、编写Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 采用file.Transto 来保存上传的文件</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;upload2&quot;)</span><br><span class="line">public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;上传路径保存设置</span><br><span class="line">   String path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);</span><br><span class="line">   File realPath &#x3D; new File(path);</span><br><span class="line">   if (!realPath.exists())&#123;</span><br><span class="line">       realPath.mkdir();</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;上传文件地址</span><br><span class="line">   System.out.println(&quot;上传文件保存地址：&quot;+realPath);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span><br><span class="line">   file.transferTo(new File(realPath +&quot;&#x2F;&quot;+ file.getOriginalFilename()));</span><br><span class="line"></span><br><span class="line">   return &quot;redirect:&#x2F;index.jsp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、前端表单提交地址修改</p>
<p>3、访问提交测试，OK！</p>
<blockquote>
<p>文件下载</p>
</blockquote>
<p><strong>文件下载步骤：</strong></p>
<p>1、设置 response 响应头</p>
<p>2、读取文件 – InputStream</p>
<p>3、写出文件 – OutputStream</p>
<p>4、执行操作</p>
<p>5、关闭流 （先开后关）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;download&quot;)</span><br><span class="line">public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123;</span><br><span class="line">   &#x2F;&#x2F;要下载的图片地址</span><br><span class="line">   String  path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);</span><br><span class="line">   String  fileName &#x3D; &quot;基础语法.jpg&quot;;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;1、设置response 响应头</span><br><span class="line">   response.reset(); &#x2F;&#x2F;设置页面不缓存,清空buffer</span><br><span class="line">   response.setCharacterEncoding(&quot;UTF-8&quot;); &#x2F;&#x2F;字符编码</span><br><span class="line">   response.setContentType(&quot;multipart&#x2F;form-data&quot;); &#x2F;&#x2F;二进制传输数据</span><br><span class="line">   &#x2F;&#x2F;设置响应头</span><br><span class="line">   response.setHeader(&quot;Content-Disposition&quot;,</span><br><span class="line">           &quot;attachment;fileName&#x3D;&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">   File file &#x3D; new File(path,fileName);</span><br><span class="line">   &#x2F;&#x2F;2、 读取文件--输入流</span><br><span class="line">   InputStream input&#x3D;new FileInputStream(file);</span><br><span class="line">   &#x2F;&#x2F;3、 写出文件--输出流</span><br><span class="line">   OutputStream out &#x3D; response.getOutputStream();</span><br><span class="line"></span><br><span class="line">   byte[] buff &#x3D;new byte[1024];</span><br><span class="line">   int index&#x3D;0;</span><br><span class="line">   &#x2F;&#x2F;4、执行 写出操作</span><br><span class="line">   while((index&#x3D; input.read(buff))!&#x3D; -1)&#123;</span><br><span class="line">       out.write(buff, 0, index);</span><br><span class="line">       out.flush();</span><br><span class="line">  &#125;</span><br><span class="line">   out.close();</span><br><span class="line">   input.close();</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;download&quot;&gt;点击下载&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</p>
<p>拦截器及文件操作在我们开发中十分重要，一定要学会使用！</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
</search>
