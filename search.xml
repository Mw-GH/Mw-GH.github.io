<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux 常用命令</title>
    <url>/2020-10-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h1><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><p>uname -an</p>
<h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>vi /etc/hostname</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网卡地址<br>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><p>正在运行程序<br>netstat -ntlp</p>
<p>防火墙允许通过的进程<br>firewall-cmd –list-ports</p>
<span id="more"></span>
<h2 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h2><p>先在Vmware虚拟机设置中扩展虚拟机磁盘容量</p>
<p>查看以有分区<br><code>fdisk -l</code></p>
<p>进入菜单,m列出菜单,p列出分区列表,n增加分区,w保存<br><code>fdisk /dev/sda</code></p>
<p>重启<br><code>reboot</code></p>
<p>查看分区情况<br><code>df -h</code></p>
<p>格式化<br><code>mkfs -t ext4 /dev/sda4</code></p>
<p>不挂载直接给根目录扩容</p>
<p>进入lvm管理<br><code>lvm</code></p>
<p>初始化分区<br><code>pvcreate /dev/sda3</code></p>
<p>将初始化过的分区加入到虚拟卷组vg_dc01<br><code>vgextend centos /dev/sda3</code></p>
<p>扩展已有的卷的容量<br><code>lvextend -L +50G /dev/mapper/centos-root</code></p>
<p>查看卷容量<br><code>pvdisplay</code></p>
<h2 id="设置开机启动之nexus3"><a href="#设置开机启动之nexus3" class="headerlink" title="设置开机启动之nexus3"></a>设置开机启动之nexus3</h2><p>创建软连接<br><code>ln -s /opt/nexus-3.21.1-01/bin/nexus /etc/init.d/nexus</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d</span><br><span class="line">sudo chkconfig --add nexus</span><br><span class="line">sudo chkconfig --levels 345 nexus on</span><br><span class="line">sudo service nexus start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/2020-10-Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p><code>git clone https://github.com/Mw-GH/GitLearning.git</code>     从远程仓库上克隆项目</p>
</li>
<li><p><code>git push -u orgin master</code><br>  将本地的最新数据推送到远程仓库<br>  第一加 <code>-u</code>后  后面可直接使用 <code>git push</code><br>  <code>pull</code>同理</p>
</li>
<li><p><code>git pull orgin master</code><br>  将远程仓库的最新数据同步到本地</p>
<span id="more"></span>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2></li>
<li><p><code>git config user.name</code><br>  查看配置用户</p>
</li>
<li><p><code>git config user.email</code><br>  查看配置邮箱</p>
</li>
<li><p><code>git config --global user.name &quot;Mw-GH&quot;</code><br>  配置更改git用户</p>
</li>
<li><p><code>git config --global user.email &quot;Mw-MS@outlook.com&quot;</code><br>  配置或更改git邮箱</p>
</li>
<li><p><code>ssh-keygen -t rsa -C &quot;Mw-MS@outlook.com&quot;</code><br>  在C:\Users\Administrator目录下生成.ssh</p>
</li>
</ul>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li><p><code>git init</code><br>初始化仓库</p>
</li>
<li><p><code>git add &lt;file&gt;</code><br>更新文件 工作区&gt;&gt;&gt;暂存区  </p>
</li>
<li><p><code>git commit -m &lt;&quot;describe&quot;&gt;</code><br>更新版本 暂存区&gt;&gt;&gt;仓库（版本库）</p>
<p>  <strong>注意<br>  一次commit能够提交上一次commit后所有的修改添加</strong></p>
</li>
<li><p><code>git checkout &lt;file&gt;</code><br><code>git checkout .</code>  恢复全部文件的修改<br>恢复修改  撤销<br>未git add的文件</p>
</li>
<li><p><code>git reset HEAD</code><br>撤销文件更新 工作区&lt;&lt;&lt;暂存区<br>已经git add的文件，再用上一条命令恢复文件<br>同commit 全部恢复为未提交状态</p>
</li>
<li><p><code>git reset --hard HEAD^</code><br>  <code>git rest --hard &lt;版本号&gt;</code><br>版本回退 暂存区&lt;&lt;&lt;仓库（仓库）<br>回退到上一个版本 上上一个版本为HEAD^^ 上一百个版本HEAD~100<br>已经commit后 恢复所有文件为上一个版本</p>
</li>
<li><p><code>git rm test.txt</code><br>删除test.txt文件</p>
</li>
<li><p><code>git status</code><br>查看commit前仓库的状态 是否有需要提交的文件</p>
</li>
<li><p><code>git diff [file]</code><br>查看commit前的差异   difference差异</p>
</li>
<li><p><code>git log</code><br>查看最近到最远的提交日志<br>  <code>git log --pretty=oneline</code><br>简略版日志</p>
</li>
<li><p><code>git reflog</code><br>查看你的每一次命令</p>
</li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><ul>
<li><p><code>git checkout -b dev</code><br>创建并切换到新的分支dev<br>等同于<br><code>git branch dev</code><br><code>git checkout dev</code></p>
</li>
<li><p><code>git branch</code><br>查看当前所有分支</p>
</li>
<li><p><code>git merge dev</code><br>当前分支master合并dev分支  </p>
</li>
</ul>
<p><strong>合并方式：<br><code>Fast-forward</code>:快进模式<code>git merge dev</code>，直接把master指向dev的提交，缺点：看不出合并记录还会搅乱master分支提交记录<br>禁用<code>Fast-forward</code>:普通模式<code>git merge --no-ff -m &quot;merge --no-ff&quot;</code>,合并后的历史有分支，能看出来曾经做过合并</strong></p>
<p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>禁用<code>Fast forward</code>模式 合并分支并生成一个commit  </p>
<p><strong>建议使用<br><code>--no-ff</code>参数 就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</strong></p>
<ul>
<li><code>git branch -d dev</code><br>删除dev分支</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul>
<li><p><code>git switch -c dev</code><br>创建并切换到新的分支dev</p>
</li>
<li><p><code>git switch master</code><br>直接切换到已有分支master  </p>
</li>
</ul>
<p><strong>注意<br> 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</strong></p>
<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code><br>用带参的<code>git log</code>查看分支的合并情况</li>
</ul>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul>
<li><p><code>git stash</code><br><code>git stash save &quot;sta1&quot;</code><br>储藏现在的工作区</p>
</li>
<li><p><code>git stash list</code><br>查看所有储藏的内容</p>
</li>
<li><p><code>git stash pop</code><br>恢复内容同时删除stash</p>
</li>
<li><p><code>git stash apply</code><br><code>git stash apply stash@&#123;0&#125;</code><br>恢复最近一个stash</p>
</li>
<li><p><code>git stash drop stash@&#123;0&#125;</code><br>删除指定stash</p>
</li>
<li><p><code>git stash branch</code><br>从最新的stash创建分支</p>
</li>
<li><p><code>git cherry-pick</code><br>复制一个特定的提交到当前分支</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux部署JavaWeb项目</title>
    <url>/2020-10-Linux%E9%83%A8%E7%BD%B2Javaweb%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="linux部署javaWeb项目"><a href="#linux部署javaWeb项目" class="headerlink" title="linux部署javaWeb项目"></a>linux部署javaWeb项目</h1><h2 id="1-查看是否有java环境"><a href="#1-查看是否有java环境" class="headerlink" title="1.查看是否有java环境"></a>1.查看是否有java环境</h2><pre><code>java -version
</code></pre>
<h2 id="2-部署tomcat"><a href="#2-部署tomcat" class="headerlink" title="2.部署tomcat"></a>2.部署tomcat</h2><p>解压tomcat</p>
<pre><code>tar -zxvf apache-tomcat-8.5.43.tar.gz 
</code></pre>
<p>进入bin目录运行<code>start.sh</code></p>
<pre><code>./start.sh
</code></pre>
<span id="more"></span>

<p>开放8080端口</p>
<p>先关闭防火墙–&gt;安装或更新防火墙–&gt;启动防火墙–&gt;查看防火墙状态</p>
<pre><code>systemctl stop firewalld
yum install iptables-services
systemctl enable iptables
systemctl start iptables
</code></pre>
<p>查看正在运行的程序信息(端口)</p>
<pre><code>netstat -tunlp
</code></pre>
<h2 id="3-部署mysql"><a href="#3-部署mysql" class="headerlink" title="3.部署mysql"></a>3.部署mysql</h2><p>解压mysql</p>
<pre><code>tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<p>移动并修改文件名</p>
<pre><code>mv mysql-5.7.17-linux-glibc2.5-x86_64 /usr/saplc-gc/mysql
</code></pre>
<p>添加mysql 用户</p>
<pre><code>groupadd mysql
useradd -r -g mysql mysql
</code></pre>
<p>切换到/usr/saplc-gc/mysql 改变目录拥有者为 mysql</p>
<pre><code>chown -R mysql.mysql /usr/saplc-gc/mysql
</code></pre>
<p>安装mysql</p>
<pre><code>bin/mysqld --initialize --user=mysql --basedir=/usr/saplc-gc/mysql --datadir=/usr/saplc-gc/mysql/data
</code></pre>
<p><strong>填坑</strong><br>在linux系统，默认设置下：</p>
<ul>
<li>数据库名与表名是严格区分大小写的；</li>
<li>列名与列的别名在所有的情况下均是忽略大小写的；</li>
<li>变量名也是严格区分大小写的；</li>
</ul>
<p>在windows系统，默认设置下：</p>
<ul>
<li>都不区分大小写</li>
</ul>
<p><strong>解决方法</strong><br>以root用户登录数据库服务器,修改<code>/etc/my.cnf</code>文件:</p>
<ol>
<li><p>在[mysqld]下加入代码:</p>
<pre><code> lower_case_table_names=1
</code></pre>
</li>
<li><p>重启数据库</p>
<pre><code> service mysqld restart
</code></pre>
</li>
<li><p>验证lower_case_table_names的值,0代表区分大小写,1代表不区分大小写</p>
</li>
</ol>
<p><strong>建议</strong><br>为了避免大小写引发的问题，一种推荐的命名规则是：在定义数据库、表、列的时候全部采用小写字母加下划线的方式，不使用任何大写字母。</p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea 2019.1激活</title>
    <url>/2020-10-Idea-2019-1%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>原理应该是让idea拉回激活信息失败</p>
<p>hosts 文件添加</p>
<p>0.0.0.0 account.jetbrains.com<br>0.0.0.0 <span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tLw==">www.jetbrains.com<i class="fa fa-external-link-alt"></i></span></p>
<p>激活码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MNQ043JMTU-eyJsaWNlbnNlSWQiOiJNTlEwNDNKTVRVIiwibGljZW5zZWVOYW1lIjoiR1VPIEJJTiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNC0wNCJ9XSwiaGFzaCI6IjEyNjIxNDIwLzBwIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOnRydWUsImlzQXV0b1Byb2xvbmdhdGVkIjp0cnVlfQ&#x3D;&#x3D;-Zmbxcn7NPlqBNqAURX0uiLzybnruyx6PG+6KYZrpzm&#x2F;IJJs5nnIogGgdfIJoifO6fbaaJYc5pjds7CHdrt&#x2F;neIpvF2o&#x2F;HvIjMEF4&#x2F;AhNV7HUGsAa9zpMszc6YBIkMmVFh4Y7GPKOStA14&#x2F;Ld83AC7kGnwL1Fq7eAXKJFljc00GMejPpfE0zDqTN634bC+0ojfklhWXaLqhUt230SiE8onnd3quvEaH5NsW7sIQm2spyONZI+iHvHFtl4EvG7tlRlD1StsfhrbgNNxz61FOEEQ+GtZIzMx+T4sbpfoRyms7lbWQecrbAtE0c2sR98esm4PcDUhrFVBxGorPC1ppOLSQ&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 中文乱码解决</title>
    <url>/2020-10-Tomcat-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在开发过程或者更换开发环境中经常遇到tomcat中文乱码问题，在此记录已方便查看.</p>
<span id="more"></span>

<h2 id="控制台中文乱码"><a href="#控制台中文乱码" class="headerlink" title="控制台中文乱码"></a>控制台中文乱码</h2><p>注释掉<code>tomcat/conf/logging.properties</code>中</p>
<pre><code>java.util.logging.ConsoleHandler.encoding = UTF-8
</code></pre>
<h2 id="前端传递参数到后端（JSP接受）"><a href="#前端传递参数到后端（JSP接受）" class="headerlink" title="前端传递参数到后端（JSP接受）"></a>前端传递参数到后端（JSP接受）</h2><p>修改<code>tomcat/conf/server.xml</code>文件中</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
connectionTimeout=&quot;20000&quot;
redirectPort=&quot;8443&quot; disableUploadTimeout=&quot;true&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;
</code></pre>
]]></content>
      <categories>
        <category>技术储备</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware与Docker不兼容解决办法</title>
    <url>/2020-10-VMware%E4%B8%8EDocker%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="熊掌和鱼不可兼得，只能使用其一"><a href="#熊掌和鱼不可兼得，只能使用其一" class="headerlink" title="熊掌和鱼不可兼得，只能使用其一"></a>熊掌和鱼不可兼得，只能使用其一</h2><span id="more"></span>
<h2 id="1-使用用docker"><a href="#1-使用用docker" class="headerlink" title="1.使用用docker"></a>1.使用用docker</h2><p>第一步：在控制面板中勾选Hyper -v<br>第二步：在cmd，以管理员身份运行：<br>bcdedit /set hypervisorlaunchtype auto<br>第三步:重启</p>
<h2 id="2-使用虚拟机"><a href="#2-使用虚拟机" class="headerlink" title="2.使用虚拟机"></a>2.使用虚拟机</h2><p>第一步：在控制面板中取消勾选Hyper -v<br>第二步：在cmd中，以管理员身份运行：<br>bcdedit /set hypervisorlaunchtype off<br>第三步:重启</p>
]]></content>
      <categories>
        <category>技术储备</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-多态</title>
    <url>/2020-10-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。</p>
<span id="more"></span>

<h2 id="多态的存在有三个必要的条件"><a href="#多态的存在有三个必要的条件" class="headerlink" title="多态的存在有三个必要的条件"></a>多态的存在有三个必要的条件</h2><ol>
<li>要有继承（两个类之间存在继承关系，子类继承父类)</li>
<li>要有重写（在子类里面重写从父类继承下来的方法）</li>
<li>父类引用指向子类对象  </li>
</ol>
<p>这三个条件一旦满足，当你调用父类里面被重写的方法的时候，实际当中new的是哪个子类对象，就调用子类对象的方法（这个方法是从父类继承下来后重写后的方法）。</p>
<p>　　面向对象比较强调类和类之间，对象和对象之间的一种组织关系，如果能把这种组织关系组织得比较好的话，你的程序想扩展性比较好，比较健壮，维护性比较好这些都可以达到，关键看你的设计到底好还是不好。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-异常</title>
    <url>/2020-10-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理，让程序继续执行下去,而不是遇到异常中断程序运行</li>
<li>在多重catch块后面，可以加一个catch(Exception)来处理可能被遗漏的异常  </li>
<li>对于不确定的代码，也可以加上try-catch来处理潜在的异常</li>
<li>尽力去处理异常，切忌不要只是简单的调用printStackTrace()去打印输出  </li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加finally语句块去释放占用的资源</li>
<li>不要在循环语句内使用try-catch，会占用大量资源<span id="more"></span>

</li>
</ul>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常是不需要捕获的，程序员可以去处理，避免，比如0作除数异常，只需要加一个判断 被除数不能等于0即可避免，当异常出现时，虚拟机会处理。常见的运行时异常有空指针异常。</p>
<p>常见的5中运行时异常：</p>
<p>ClassCastException(类转换异常)<br>IndexOutOfBoundsException(数组越界)<br>NullPointerException(空指针)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>还有IO操作的BufferOverflowException异常</p>
<h3 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h3><p>非运行时异常就必须得捕获了，强制处理异常，否则编译不过去，java编译器要求程序员必须对这种异常进行捕获或抛出,Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。</p>
<p>常见的非运行异常有io异常和sql异常。</p>
<p>IOException<br>FileNotFoundExcetion<br>SQLException</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>错误 无法解决</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h2><p>捕获异常 范围由小到大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        demo2.d2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h2><p>1、throws出现在方法的声明中，表示该方法可能会抛出的异常，允许throws后面跟着多个异常类型<br>2、throw出现在方法体中，用于抛出异常。当方法在执行过程中遇到异常情况时，将异常信息封装为异常对象，然后throw。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>抛出异常和捕获异常：</p>
<p>抛出异常 为了让程序继续执行<br>让调用者捕获解决异常</p>
<p>什么时候用 try catch ，throws ，throw：</p>
<ol>
<li><p>throws:抛出异常</p>
<p> 写方法时可能会遇到异常，在方法名声明异常  可声明多个异常  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这里有可能会产生FileNotFoundException异常</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;MyFile.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw：手动抛出异常  </p>
<p> 常用于判断内 例如：用户输入不合法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;i不能等于0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 类似与sout打印到控制台，但是打印到控制台</p>
</li>
<li><p>try catch: 捕获异常，处理异常</p>
<p> 调用时try catch捕获异常 处理异常</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        demo2.d2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-数组</title>
    <url>/2020-10-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">int</span> [] a;  <span class="keyword">int</span> [][]b;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">int</span> a[]; <span class="comment">//不是首选</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h2 id="实列数组对象"><a href="#实列数组对象" class="headerlink" title="实列数组对象"></a>实列数组对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="声明创建实列三合一"><a href="#声明创建实列三合一" class="headerlink" title="声明创建实列三合一"></a>声明创建实列三合一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定大小</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//指定元素</span></span><br><span class="line"><span class="keyword">int</span> []a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dateType [] arrayName=&#123;arrayValue1,arrayValue2,arrayValue3&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    System.out.println(array[i]);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二： 增强for循环 foreach  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:array)&#123;  </span><br><span class="line">    System.out.println(a);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>AP配置文件</title>
    <url>/2020-10-%E8%B4%A6%E6%88%B7%E7%A7%98%E5%AF%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ebf7c5fec32fc441c0166d9eb469254d625d950164c281464804549641a11fc9">a4626797b59d51ca61698aa4c885a79dbaf4e24b070ecdbf062639dad5a2a232ae84e372eb2560f6d2baa8fedd9be3b73c9cf6bd7aeb290d0a95d232d530ba34f6256845b0d316e6d68091afa31924b6515af881d12b5202d0c165e03130cb2f8fb64160daf6fe9f22f5f34fc043230c210248507b92a662d53c33dd7219b6dd3fbc0007a943ef0a8b5a90e23868b5948694db2a30da5a4bfc2c33eb5e814721cff19a35b459cb1f9ff0012cc1d9ab5c86495a82e5d5b42712a90bbb893bd6c89fe89201b6f7a345a6f2252bd5b46470ecfecb30b3c107ef74dfda7fd44538b9ad660fe84d8febf9cb6bf0e5324c1913a0f9415ccfe95e2ef6b14b068c36c1c3bc47e638e934c5e6a0cd8082628995f6a6edc602414eed7bc66f16928c9b384cfd603db20e71a9a001f898cad03a7c23a7165f9e0d2e4c770abd63110cfd557e322af7b1189d357e1dee53727a54d1931ea4e3c1f2e0b01f8eaa8f0ce892ee18c58ecb66b0201890a1fbe38e146097f1d75eb441b7f78c9cf3d14d058d33bb8e7b89c4c5ca817b6013ba2c4aeb865c8e268f9a0eb08745cba9b7282926fc0ad4cc5c3b8ccdcd3c8aaf42f50e85ffed42a75e1adc92d41bdc539f55b7cc4f1b11b665336827a615242f26b2f93a6b2044bb024ee656646255143fc123b64e22c28960ecf448d2fce36dc47e17e23a711c051e56b83bee9915166fd9f7e11e40d2ba28e9dbdfd8fffd597f70058478be9f31cfc745ff6e84757df970b0d94741b3adf6da9a61adfdbb911e37bc1410a8b87cf711acdbfa6d39b059efd41a3f908df4bb36b77f50f200ada752a14e2a7cbbe2f60c46d85e39b50cffbefec666c1f788c55d4947217c1cee59cd7c6c5a9478e84eacfd3dea59c9f889a3fe9e922c9d8812e093e2528968d227b4da559d5d73c0690a6bb46c8f6affe8934ec12b3f3c89296121c57b0216e5d4757b7c0f76e0056149199765be06e0925f7d479045857a609907216ffb4b872367d103ddf914668a9a543445b70a46f55fc632d08ac40328075162b6341a10e076d1dee16fd7389da25a4b07ff010918f0dfd8d772cc92164a36ee775b41bcb5e846f85f9d952c34732a1591f8e9b3c5a72f8213caffc8d207e896ef47a454dc62331bd6870d3509cb3544e581508026365c262a3b5f14ead3ff48754e320c706c5c48493c23e7868dfbb31ea291c14062200d9d5491abae4b3dd4021d37fcb6a3b2ae83312b12424db8be3b55e84e7b207114c0948397575c175a601b183c2f309996152c09b4b6322f7a63cab53bebc5079d947ba3f81436ff4dc7a897b4b203a7c5ae8ec41d1ad93e1dbe9f7b9b81448b53ea9770a6e44aa74c2709535ad2975880d58840b771a1dae03245eb7613a20eaf1c4a6dfe980c9188f96c2563b8563c8e877626261c7be915819c1d42ba4af732b9533858f9e61a7f4a25c2e1faadf9aaeec5262705d8eef27bc36497e1f53c0ebf64628b4659dd3f0b864171d5147089c4429a27a652a6ddbef6022f54fcbd320b2cef9d11cc3607d7fd0ee4f2e83ef6bac05777f3cf0716052032660e8a8235bac1410f5cd36e6c7b49eaf401e912b68fe5f5b5c1f1ba2e0f0b83766672ef1cd2031659d5fad42bc61046b210c82001d31dc7f59a82c9d9dc785cf06eae394e111e2bb73126ac7843c9b0bba6ee35d7933c1d29b7edea40f7e1d1313d84956c6dec2f59ef6bafaa6f40c727fec4dc1a127461e679c270ae2ffc7a9384b3f05650b49b5117302a82d4927658d02280ac46c7f870ecc72b72cea8a7572f017f6fe46f60a077e47b6f6bf09717b008b392cc715257c9b66eafc26214c298abe019af968aaced853f906a1680edad88f86e31bd43cfee43693cae84147594137afb84f3fe7bb9b208ac47bb376166b2c1eefc9f49315448b39e20ddd7717fe15852e3787e066d71afa4ed5ba7203e39cdfcec1183dfe0d780d96074df775384c410d70cc4a4985c52ad4047c9e176bb91b60c7d69e04d5155b5ff79086aa763bd05c6f67810e1711f8ed65afa7341933ee67d22231d729b50cec6b7553fc9353b7cb20b7b340aa0e8a00ca4578859c933e2fbb2578aaabb9f6f5177f104cd98fe614922208b9f5a5ffc45b5902aae018841cad8a95f7321dfad6beabd1043909b55d0ae757876d5ebe12f34fe075c6d30aa83264a21c23e4ee6cd7b97b8fce755f188510cd9b25c14edecd7bdeff2a2f1be81db11756345eaa693cd3ca836152eb567189b6a17be72671b97981a00dbfe81127a6d6970d16f509e5ab332ccfe1ca43fcb06c30b4e6c6f7abbd1f0b18a4a057036a8dd435f17c7db98b3b506fe6fc63a896e2e79d0c3aa77ee13a8f92d04bb183f4df99749ef62e35eb84247c9b791e56f3386adc93545b08e4e02c736aad9dab1dbf8302e21760c18b8efdd5639c3a0e92a63335f17425aeb094cd258e0da933dd7213a5526fc5b66651dd5405932247540071ecfc7000d0f18052ac8ea8c52b2172cda298a8bcb989f146445866c466634e3f7bd6746ac758cc1e71d0076f3f4ce721f330898d8b73243db3fd3290fb0ca</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>个人文件</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-锁</title>
    <url>/2020-10-%E9%94%81/</url>
    <content><![CDATA[<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>大概率一个数据不会被多个线程同时修改，<br>通过Cas总会分配一个t1优先权限，t1中的E1（预期值）=V（主存的共享变量）说明预期值正确，执行N1=V1+1，然后将N1值覆盖主存的值，线程t2执行 拿到主存中的值V=21，然后与t2中的E2比较 E2！=V 重新更新主存的值到自己的副本，再次尝试，值到E2=V 说明没有别的线程对旧值进行更改，则继续执行，优化 加版本号 version</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">之前不能防止ABA的正常修改：</span><br><span class="line"></span><br><span class="line">update table set value = newValue where value = #&#123;oldValue&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>oldValue就是我们执行前查询出来的值 </span><br><span class="line">带版本号能防止ABA的修改：</span><br><span class="line"></span><br><span class="line">update table set value = newValue ，vision = vision + 1 where value = #&#123;oldValue&#125; and vision = #&#123;vision&#125; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号<span class="number">100</span><span class="operator">%</span>不一样</span><br></pre></td></tr></table></figure>

<p>适合于多读</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>大概率一个数据会被多个线程同时修改，<br>每次拿到数据就上锁，别的线程拿数据就会阻塞直到拿到锁， t1上锁， t2阻塞，t1执行完后，t2上锁以此类推<br>适合于多写</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-三大修饰符</title>
    <url>/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="抽象abstract"><a href="#抽象abstract" class="headerlink" title="抽象abstract"></a>抽象abstract</h2><h3 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h3><p>现实中不存在的对象；具备某类别对象的特征，但不具体，不完整，不能独立存在。</p>
<p>eg：（名词） 动物，鼠标，桌子，椅子</p>
<p>动物：没有动物本身，现实中全是动物的子类对象（猫，狗）</p>
<p>鼠标：具有属性(大小，颜色，价格)，方法（移动，点击）特征，却没有鼠标本身，现实中全是各个厂家的实现</p>
<span id="more"></span>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>不该被创建的对象</p>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309194342645.png" class="">

<ul>
<li>应用：abstract修饰词，限制类不能被创建成为对象</li>
</ul>
<h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol>
<li><p>可被子类<mark>继承</mark>，提供共性属性和方法。</p>
</li>
<li><p>可声明为引用，更自然的使用<mark>多态</mark>。</p>
</li>
</ol>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309200353003.png" class="">

<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>父类提供的方法不满足子类的需求，如不定义，则表示所有动物都不会吃，睡。若定义，略显多余，多数会被子类覆盖。</p>
<img src="/2021-01-JavaSE-%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20210309203302004.png" class="">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>abstract 修饰类：不能new对象，但可以声明引用(多态)</li>
<li>abstract修饰方法：只有方法声明，没有方法实现，必须包含在抽象类中</li>
<li>抽象类不一定有抽象方法，但抽象方法一定是在抽象类中</li>
<li>子类继承抽象类后，必须重写父类中所有的抽象方法，除非子类还是抽象类</li>
</ul>
<p>代码实列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;  <span class="comment">//2.抽象方法必须在抽象类中</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//1.被子类都实现了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123; <span class="comment">//继承</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    <span class="comment">//继承抽象类必须重写抽象类中所有抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开着&quot;</span>+<span class="keyword">super</span>.brand+<span class="string">&quot;去上班&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bike</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;骑着&quot;</span>+brand+<span class="string">&quot;自行车回家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(Vehicle vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;要上班了&quot;</span>);</span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">black</span><span class="params">(Vehicle vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;该回家了&quot;</span>);</span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMaster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Master xm = <span class="keyword">new</span> Master(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Vehicle baoma = <span class="keyword">new</span> Car(<span class="string">&quot;宝马&quot;</span>);  <span class="comment">//多态父类引用指向子类</span></span><br><span class="line">        Vehicle yelv = <span class="keyword">new</span> Bike(<span class="string">&quot;野驴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        xm.go(baoma);</span><br><span class="line">        xm.black(yelv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h2><h3 id="什么是静态"><a href="#什么是静态" class="headerlink" title="什么是静态"></a>什么是静态</h3><p>个人理解：static修饰的成员 直接类名调用，不用创建类的实例，从而有效的降低内存泄漏的风险，所以应该是空间的减少</p>
<p>（工具类<br>操作全局变量<br>共享）</p>
<ul>
<li>概念：<ul>
<li>静态可以修饰属性和方法。</li>
<li>称为静态属性（类属性），静态方法（类方法）。不属于类实例出来的对象，实例出来的属性称为实例属性。</li>
<li>静态成员是全类所有对象共享的成员</li>
<li>在全类中只有一份，不因创建多个对象而产生多份</li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>特点<ul>
<li>静态方法允许直接访问静态成员</li>
<li>静态方法不能直接访问非静态成员（对象还未创建）</li>
<li>静态访问中不允许使用this或super关键字</li>
<li>静态方法可以继承，不能重写，没有多态</li>
</ul>
</li>
<li>已知静态方法<ul>
<li>Arrays.copyOf()</li>
<li>Arrays.sort()</li>
<li>Math.random()</li>
<li>Math.sqrt()</li>
</ul>
</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>类加载时，触发静态代码块的执行(仅一次)。</p>
<ul>
<li>执行顺序：静态属性初始化之后。</li>
<li>作用：可为静态属性赋值，或必要的初始化行为。</li>
<li>触发时机：<ul>
<li>创建对象。</li>
<li>创建子类对象</li>
<li>访问静态属性</li>
<li>调用静态方法</li>
<li>主动加载：Class.forName(“”);</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>static修饰的成员为静态成员，无需创建对象，可直接通过类名访问。</li>
<li>静态方法不能直接访问非静态成员。</li>
<li>静态方法中不能使用this或super</li>
<li>静态方法可以继承、不能重写、没有多态。</li>
<li>静态代码块在类加载时被执行，且只执行一次。</li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.staticMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;  <span class="comment">//1.静态属性（类属性）</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;------&quot;</span>+age+<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;个学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCount</span><span class="params">()</span></span>&#123; <span class="comment">//2.静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生总数：&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//3.静态代码块 让count从1000开始</span></span><br><span class="line">        count=<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        s2.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.count);</span><br><span class="line">        Student.showCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最终final"><a href="#最终final" class="headerlink" title="最终final"></a>最终final</h2><ul>
<li>概念：最后的，不可更改的。</li>
<li>final修饰的内容：<ul>
<li>类（最终类）：此类不能被继承<ul>
<li>String、Math、System</li>
</ul>
</li>
<li>方法（最终方法）：此方法不能被重写，覆盖。</li>
<li>变量（最终变量，常量）：此变量值不能被改变。</li>
</ul>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>局部常量：此变量值不能被改变</li>
<li>实例常量：实例常量不再提供默认值，必须手动赋予初始值<ul>
<li>赋值时机：显示初始化，构造方法</li>
<li>注意：在构造方法中为实列常量复制，必须包装所有构造方法都能对其正确赋值</li>
</ul>
</li>
<li>静态常量：实例常量不再提供默认值，必须手动赋予初始值<ul>
<li>赋值时机：显示初始化，静态代码块</li>
</ul>
</li>
<li>对象常量：final修饰引用类型：地址不可变</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>final修饰类：此类不能被继承</li>
<li>final修饰方法：此方法不能被覆盖</li>
<li>final修饰变量：此变量值不能被改变。（如果不设置初始值，初始赋值只能一次）<ul>
<li>局部常量：显示初始化</li>
<li>实例常量：显示初始化、构造方法</li>
<li>静态常量：显式初始化、静态代码块</li>
<li>基本类型常量：值不可改变</li>
<li>引用类型常量：地址不可改变</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.finalMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fristName=<span class="string">&quot;张&quot;</span>;<span class="comment">//2.实例常量</span></span><br><span class="line">    <span class="keyword">final</span> String lastName; <span class="comment">//2.1实例常量 在初始化时赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String provincial=<span class="string">&quot;四川&quot;</span>;<span class="comment">//3.静态常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String city;<span class="comment">//3.1 静态常量 在静态代码块中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//final修饰基本类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> iphone=<span class="number">138888888</span>; <span class="comment">//1.局部常量 赋值后不能进行修改</span></span><br><span class="line">        <span class="comment">//iphone=&quot;1111&quot;;  报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态对象（final修饰引用类型）</span></span><br><span class="line">        <span class="keyword">final</span> String[] interest=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;唱歌&quot;</span>,<span class="string">&quot;跳舞&quot;</span>&#125;; <span class="comment">//4.1静态对象</span></span><br><span class="line">        <span class="comment">//interest=new String[]&#123;&quot;打游戏&quot;,&quot;看电影&quot;&#125;; 不能再进行初始化（更改地址） 但是可以更改里面的值</span></span><br><span class="line">        interest[<span class="number">0</span>]=<span class="string">&quot;打游戏&quot;</span>; </span><br><span class="line">        <span class="keyword">final</span> Pet pig = <span class="keyword">new</span> Pet(<span class="string">&quot;小猪&quot;</span>);</span><br><span class="line">        <span class="comment">//pig=new Pet (&quot;罗志祥&quot;); 不能再进行初始化（更改地址） 但是可以更改里面的值</span></span><br><span class="line">        pig.setName(<span class="string">&quot;时间管理大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(iphone+fristName+lastName+provincial+city+Arrays.toString(interest)+pig.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lastName=<span class="string">&quot;三&quot;</span>; <span class="comment">//2.2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName; <span class="comment">//必须保证正确的赋值</span></span><br><span class="line">        <span class="comment">//this.lastName=&quot;四&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        city=<span class="string">&quot;成都&quot;</span>;<span class="comment">//3.1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier.finalMod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Person(<span class="string">&quot;五&quot;</span>);</span><br><span class="line">        zhangsan.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-基本类型和包装类以及==和equals的区别</title>
    <url>/2021-01-JavaSE-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E4%BB%A5%E5%8F%8A-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="基本类型与包装类型的区别"><a href="#基本类型与包装类型的区别" class="headerlink" title="基本类型与包装类型的区别"></a>基本类型与包装类型的区别</h2><ol>
<li><p>在Java中，一切皆对象，但八大基本类型却不是对象。</p>
</li>
<li><p>声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。</p>
</li>
<li><p>存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。</p>
</li>
<li><p>初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；</p>
</li>
<li><p>使用方式的不同，比如与集合类合作使用时只能使用包装类型。</p>
</li>
<li><p>什么时候该用包装类，什么时候用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许null值，则必然要用封装类，否则值类型就可以了，用到比如泛型和反射调用函数，就需要用包装类了！</p>
<span id="more"></span>

</li>
</ol>
<h2 id="与equals的区别与联系"><a href="#与equals的区别与联系" class="headerlink" title="==与equals的区别与联系"></a>==与equals的区别与联系</h2><ul>
<li>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li>
<li>“==”使用情况如下：<ul>
<li>a) 基本类型，比较的是值</li>
<li>b) 引用类型，比较的是地址</li>
<li>c) 不能比较没有父子关系的两个对象</li>
</ul>
</li>
<li>equals()方法使用如下：<ul>
<li>a) 系统类一般已经覆盖了equals()，比较的是内容。</li>
<li>b) 用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址<br>（return (this == obj);）</li>
<li>c) 用户自定义类需要覆盖父类的equals()</li>
</ul>
</li>
<li>注意<ul>
<li>Object的==和equals比较的都是地址，作用相同</li>
<li>基本数据类型的包装类之间，==比较地址，equals比较值</li>
<li>基本数据类型与包装类之间，包装类自动拆封为基本类型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String比较</span></span><br><span class="line">        String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//str1 str2均为常量，常量在常量池中只有一份 所以为true</span></span><br><span class="line">        System.out.println(str1==str2);</span><br><span class="line">        <span class="comment">//equals在String类中为比较值</span></span><br><span class="line">        System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String str3=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String str4=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new出的对象 地址不同 所以为false</span></span><br><span class="line">        System.out.println(str3==str4);</span><br><span class="line">        <span class="comment">//同9行</span></span><br><span class="line">        System.out.println(str3.equals(str4));</span><br><span class="line">        <span class="comment">//常量地址与new出的对象地址肯定不同</span></span><br><span class="line">        System.out.println(str1==str3);</span><br><span class="line">        <span class="comment">//同9行</span></span><br><span class="line">        System.out.println(str1.equals(str3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本类型与包装类比较</span></span><br><span class="line">        <span class="comment">//int与Integer</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num11=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//==Integer.valueOf(10);</span></span><br><span class="line">        Integer num3=<span class="number">10</span>;</span><br><span class="line">        Integer num4=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//==Integer.valueOf(1000) ==new Integer(1000)</span></span><br><span class="line">        Integer num33=<span class="number">1000</span>;</span><br><span class="line">        Integer num44=<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//产生一个新的Integer 对象</span></span><br><span class="line">        Integer num5=<span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//指定的 int 值的 Integer 实例</span></span><br><span class="line">        Integer num6=Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//小于-128||大于127 ==new Integer(1000)</span></span><br><span class="line">        Integer num66=Integer.valueOf(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----使用==----&quot;</span>);</span><br><span class="line">        System.out.println(num1 == num2);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//包装对象与数值比较，自动拆箱</span></span><br><span class="line">        System.out.println(num1 == num3);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num1 == num5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num1 == num6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num5 == num6);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(num3 == num4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num33 == num44);<span class="comment">//false</span></span><br><span class="line">        System.out.println(num3 == num5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(num3 == num6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(num66 == num33);<span class="comment">//flase</span></span><br><span class="line">        System.out.println(num66 == num11);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----使用equals----&quot;</span>);</span><br><span class="line">        <span class="comment">//equals 方法比较的是数值大小</span></span><br><span class="line">        System.out.println(num3.equals(num1));</span><br><span class="line">        System.out.println(num5.equals(num1));</span><br><span class="line">        System.out.println(num4.equals(num3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//double与Double</span></span><br><span class="line">        <span class="keyword">double</span> a=<span class="number">66.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a1=<span class="number">66.0</span>;</span><br><span class="line">        Double b=<span class="number">66.0</span>;</span><br><span class="line">        Double b1=<span class="number">66.0</span>;</span><br><span class="line">        Double c=<span class="number">2000.1</span>;</span><br><span class="line">        Double c1=<span class="number">2000.1</span>;</span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line">        System.out.println(a == a1);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//double取的是近似值 运输会失真</span></span><br><span class="line">        System.out.println(b == b1);<span class="comment">//false</span></span><br><span class="line">        System.out.println(c == c1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">//equals</span></span><br><span class="line">        System.out.println(b.equals(b1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        <span class="comment">//boolean</span></span><br><span class="line">        Boolean i=<span class="keyword">null</span>;</span><br><span class="line">        Boolean i1 = <span class="keyword">null</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown-lint规则</title>
    <url>/2021-03-MarkDown-lint%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>markdownlint是vscode上一款非常好用的 Markdown 格式检查扩展工具，它规定了许多规则并实时对文档进行检查，防止一些语法错误，同时维持文档风格的统一，使用此工具有助于形成一个良好的写作习惯和规范。但因其规则较多，写文档时很容易就出错（或不符合规则），所以需要对工具的规则有一个详细的了解，另外，有时工作要求的文档风格与markdownlint工具规定的规则并不相同，比如标题、列表的创建格式，缩进的空格数等等，这时就需要对规则进行一定的设置。</p>
<p>本文主要参考markdownlint的<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwMDItLS1maXJzdC1oZWFkaW5nLXNob3VsZC1iZS1hLXRvcC1sZXZlbC1oZWFkaW5n">rules文档<i class="fa fa-external-link-alt"></i></span>，对每一个规则都进行了说明，指明了一些规则中可以设置的参数，便于用户设置相应的规则。</p>
<span id="more"></span>

<h2 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h2><p>标题级数每次只能扩大1, 也就是不能隔级创建标题（从1级到6级的顺序）</p>
<h2 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top level heading"></a>MD002 - First heading should be a top level heading</h2><p>文档的第一个标题必须是最高级的标题（标题等级1级到6级逐渐降低）</p>
<p>参数：<br> “level”：指定最高级标题的级数，默认是1</p>
<h2 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h2><p>整篇文档要采用一致的标题格式</p>
<p>参数：<br> “style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”, “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p>
<p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p>
<h2 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h2><p>整篇文档定义无序列表的格式要一致</p>
<p>参数：<br> “style”：字符串，指定无序列表的定义格式，有(“consistent”, “asterisk”, “plus”, “dash”, “sublist”)五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是”consistent”</p>
<h2 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h2><p>同一级的列表缩进必须一致<br> 在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p>
<h2 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a>MD006 - Consider starting bulleted lists at the beginning of the line</h2><p>1级列表不能缩进</p>
<h2 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h2><p>无序列表嵌套缩进时默认采用两个空格</p>
<p>参数：<br> “ident”：指定无序列表嵌套时缩进的空格数，默认是2</p>
<h2 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h2><p>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p>
<p>参数：<br> “br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格<br> “list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p>
<h2 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h2><p>不能使用tab键缩进，要使用空格</p>
<p>参数：<br> “code_blocks”：指定本条规则在代码块里是否(true or false)生效</p>
<h2 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h2><p>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p>
<h2 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h2><p>文档中不能有连续的空行，在代码块中此规则不会生效</p>
<p>参数：<br> “maximum”：指定文档中可以连续的最多空行数，默认值是1</p>
<h2 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h2><p>默认行的最大长度是80，此规则对代码块、表格、标题也生效</p>
<p>参数：<br> “line_length”：指定行的最大长度，默认是80<br> “heading_line_length”：指定标题行的最大长度，默认是80<br> “code_blocks”：指定规则是否(true or false)对代码块生效，默认true<br> “tables”：指定规则是否(true or false)对表格生效，默认true<br> “hesdings”：指定规则是否(true or false)对标题生效，默认true</p>
<h2 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h2><p>在代码块中，终端命令前不需要有美元符号($)<br> 如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ls</span><br><span class="line">foo bar</span><br><span class="line"><span class="variable">$ </span>cat foo</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间需用一个空格隔开</p>
<h2 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p>
<h2 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p>
<h2 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p>
<h2 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h2><p>标题行的上下行必须都是空行</p>
<p>参数：<br> “lines_above”：指定标题行上方的空行数，默认为1，可以设为更大或0<br> “lines_below”：指定标题行下方的空行数，默认为1，可以设为更大或0</p>
<p>注意当此处的空行设为比1大的数时，规则MD012的设置也要改</p>
<h2 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h2><p>标题行不能缩进</p>
<h2 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h2><p>文档不能有内容重复的标题</p>
<p>参数：<br> “siblings_only”：默认为false，设为true时，不同标题下的子标题内容可以重复</p>
<h2 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top level headings in the same document"></a>MD025 - Multiple top level headings in the same document</h2><p>同一文档只能有一个最高级的标题，默认是只能有一个1级标题</p>
<p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p>
<h2 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h2><p>标题行末尾不能有以下标点符号：”.,;:!?”</p>
<p>参数：<br> “punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p>
<p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p>
<h2 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h2><p>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p>
<h2 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h2><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p>
<h2 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h2><p>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字(“one_or_ordered”)</p>
<p>参数：<br> “style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是”one_or_ordered”</p>
<p>本条规则支持在前缀序号中补0，以实现对齐，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">08.  one</span><br><span class="line">09.  two</span><br><span class="line">10.  three</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h2><p>列表（有序、无序）的前缀符号和文字之间用1个空格隔开<br> 在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p>
<p>参数：<br> “ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1</p>
<h2 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h2><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p>
<h2 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h2><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br> 列表的缩进必须一致，否则会警告</p>
<h2 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h2><p>文档中不允许使用HTML语句</p>
<p>参数：<br> “allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p>
<h2 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h2><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p>
<h2 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h2><p>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p>
<p>参数：<br> “style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***”,”—“,”___”)，默认是”consistent”</p>
<h2 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h2><p>不能用强调代替标题</p>
<p>参数：<br> “punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p>
<p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p>
<h2 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h2><p>用于创建强调的符号和强调的的文字之间不能有空格</p>
<h2 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h2><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br> 如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p>
<h2 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h2><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">百 度</span>](http:<span class="comment">//www.baidu.com &quot;百 度&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h2><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p>
<h2 id="MD041-First-line-in-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in file should be a top level heading"></a>MD041 - First line in file should be a top level heading</h2><p>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p>
<p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p>
<h2 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h2><p>链接的地址不能为空</p>
<h2 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h2><p>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p>
<p>参数：<br> “headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;# head&quot;</span>,</span><br><span class="line">    <span class="string">&quot;## item&quot;</span>,</span><br><span class="line">    <span class="string">&quot;### detail&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwNDMtLS1yZXF1aXJlZC1oZWFkaW5nLXN0cnVjdHVyZQ==">MD043<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h2><p>指定一些名称，会检查它是否有正确的大写</p>
<p>参数：<br> “names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br> “code_blocks”：指定本规则是否(true or false)对代码块生效，默认是true<br> 一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数”names”中，防止写错</p>
<h2 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h2><p>图片链接必须包含描述文本（alt text）</p>
<h2 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h2><p>整篇文档采用一致的代码格式</p>
<p>参数：<br> “style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p>
<h2 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h2><p>文档需用一个空行结尾</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dpdGh1Yi5jb20vRGF2aWRBbnNvbi9tYXJrZG93bmxpbnQvYmxvYi9tYXN0ZXIvZG9jL1J1bGVzLm1kJTIzbWQwMDItLS1maXJzdC1oZWFkaW5nLXNob3VsZC1iZS1hLXRvcC1sZXZlbC1oZWFkaW5n">rules文档<i class="fa fa-external-link-alt"></i></span></p>
<p>原文作者：夜行的鸟<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MTUyM2ExYzZmZTE=">https://www.jianshu.com/p/51523a1c6fe1<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-IO流</title>
    <url>/2021-01-JavaSE-IO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a><strong>流的概念</strong></h2><ul>
<li><strong>概念</strong>：内存与存储设备之间传输数据的通道。<img src="/2021-01-JavaSE-IO%E6%B5%81/1.png" class=""></li>
<li>水借助管道传输；数据借助流传输。<span id="more"></span>
</li>
</ul>
<hr>
<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a><strong>流的分类</strong></h2><h3 id="按方向【重点】"><a href="#按方向【重点】" class="headerlink" title="按方向【重点】"></a><strong>按方向【重点】</strong></h3><ul>
<li><strong>输入流</strong>：将&lt;存储设备&gt;中的内容读入到&lt;内存&gt;中。</li>
<li><strong>输出流</strong>：将&lt;内存&gt;中的内容写入到&lt;存储设备&gt;中。</li>
</ul>
<img src="/2021-01-JavaSE-IO%E6%B5%81/2.png" class="">

<h3 id="按单位"><a href="#按单位" class="headerlink" title="按单位"></a><strong>按单位</strong></h3><ul>
<li><strong>字节流</strong>：以字节为单位，可以读写所有数据。</li>
<li><strong>字符流</strong>：以字符为单位，只能读写文本数据。</li>
</ul>
<h3 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a><strong>按功能</strong></h3><ul>
<li><strong>字节流</strong>：具有实际传输数据的读写功能。</li>
<li><strong>过滤流</strong>：在节点流的基础之上增强功能。</li>
</ul>
<hr>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h2><img src="/2021-01-JavaSE-IO%E6%B5%81/3.png" class="">

<h3 id="字节流的父类（抽象类）"><a href="#字节流的父类（抽象类）" class="headerlink" title="字节流的父类（抽象类）"></a><strong>字节流的父类（抽象类）</strong></h3><ul>
<li><p>InputStream</p>
<p>字节输入流</p>
<ul>
<li><code>public int read()&#123;&#125;</code></li>
<li><code>public int read(byte[] b)&#123;&#125;</code></li>
<li><code>public int read(byte[] b,int off,int len)&#123;&#125;</code></li>
</ul>
</li>
<li><p>OutputStream</p>
<p>字节输出流</p>
<ul>
<li><code>public void write(int n)&#123;&#125;</code></li>
<li><code>public void write(byte[] b)&#123;&#125;</code></li>
<li><code>public void write(byte[] b,int off,int len)&#123;&#125;</code></li>
</ul>
</li>
</ul>
<h3 id="字节流的子类"><a href="#字节流的子类" class="headerlink" title="字节流的子类"></a><strong>字节流的子类</strong></h3><h4 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a><strong>文件字节流</strong></h4><ul>
<li><strong>FileInputStream</strong><ul>
<li><code>public int read()</code>//从输入流中读取一个字节数据，返回读到的字节数据，如果达到文件末尾，返回-1。</li>
<li><code>public int read(byte[] b)</code>//从输入流中读取字节数组长度的字节数据存入数组中，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</li>
</ul>
</li>
<li><strong>FileOutputStream</strong><ul>
<li><code>public void write(int b)</code>//将指定字节写入输出流。</li>
<li><code>public void write(bute[] b)</code>//一次写多个字节，将b数组中所有字节，写入输出流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件字节输入流的使用</span></span><br><span class="line"><span class="comment"> * FileInputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//文件内容：abcdefg</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\aaa.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//read();读入单个字节</span></span><br><span class="line">    <span class="keyword">int</span> data=fileInputStream.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)data);<span class="comment">//a</span></span><br><span class="line">    <span class="keyword">while</span>((data=fileInputStream.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;<span class="comment">//bcdefg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//read(byte[] b);读入多个字节</span></span><br><span class="line">    <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span>((data=fileInputStream.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,data));</span><br><span class="line">    &#125;<span class="comment">//bcdefg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件字节输出流的使用</span></span><br><span class="line"><span class="comment"> * FileOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有文件会自动创建</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\bbb.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write(int b);</span></span><br><span class="line">    fileOutputStream.write(<span class="number">97</span>);</span><br><span class="line">    fileOutputStream.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    fileOutputStream.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write(byte[] b);</span></span><br><span class="line">    fileOutputStream.write(<span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>).getBytes());</span><br><span class="line">    <span class="comment">//此时文件bbb.txt内容为abc    helloworld</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件字节流小案例"><a href="#文件字节流小案例" class="headerlink" title="文件字节流小案例"></a><strong>文件字节流小案例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用文件字节流复制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//将图片读取到输入流</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\MrG1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//从输出流写入数据</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\MrG2.jpg&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//保存一次读取到的实际个数</span></span><br><span class="line">    <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((count=fileInputStream.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    fileOutputStream.write(b, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a><strong>字节缓冲流</strong></h4><ul>
<li><p><strong>缓冲流</strong>：BufferedInputStream/BufferedOutputStream</p>
<ul>
<li>提高IO效率，减少访问磁盘的次数；</li>
<li>数据存储在缓冲区中。flush可以将缓存区的内容写入文件，也可以直接close。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字节缓冲流读取</span></span><br><span class="line"><span class="comment">* BufferedInputStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用该输入流每次会从硬盘读入</span></span><br><span class="line">        FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\aaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//缓冲流需要一个底层流</span></span><br><span class="line">        <span class="comment">//缓冲流每次从缓冲区读取</span></span><br><span class="line">        BufferedInputStream bufferedInputStream=<span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">int</span> data; </span><br><span class="line">        <span class="keyword">while</span>((data=bufferedInputStream.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)data); </span><br><span class="line">        &#125;     </span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们也可以自己创建一个缓冲区；</span></span><br><span class="line">        <span class="comment">//每次读取从自己创建的缓冲区中读取。</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((count=bufferedInputStream.read(b,<span class="number">0</span>,b.length))!=-<span class="number">1</span>) &#123;    </span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedInputStream.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字节缓冲流写入文件</span></span><br><span class="line"><span class="comment">* BufferedOutputStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\buf.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//缓冲流将数据写入到缓冲区</span></span><br><span class="line">    BufferedOutputStream bufferedOutputStream=<span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    bufferedOutputStream.write(<span class="string">&quot;helloworld&quot;</span>.getBytes());</span><br><span class="line">    bufferedOutputStream.flush();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实内部也会调用flush</span></span><br><span class="line">    bufferedOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a><strong>对象流</strong></h2><ul>
<li><p><strong>对象流</strong>：ObjectOutputStream/ObjectInputStream</p>
<ul>
<li>增加了缓冲区功能。</li>
<li>增强了读写8种基本数据类型和字符串功能。</li>
<li>增强了读写对象的功能：<ul>
<li><code>readObject()</code>//从流中读取一个对象。</li>
<li><code>writeObject(Object obj)</code>向流中写入一个对象。</li>
</ul>
</li>
</ul>
<p><strong>使用流传输对象的过程称为序列化、反序列化。</strong></p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ObjectOutputStream实现对象的序列化</span></span><br><span class="line"><span class="comment"> * 注：序列化的类必要要实现Serializable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这个文件后缀名表示二进制文件，但你可以写成其他如obj等任意后缀。</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\stu.bin&quot;</span>);</span><br><span class="line">    ObjectOutputStream objectOutputStream=<span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//序列化（写入操作）</span></span><br><span class="line">    Student tang=<span class="keyword">new</span> Student(<span class="string">&quot;唐瑞&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    objectOutputStream.writeObject(tang);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;序列化完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：执行上述代码后IDE会抛出<code>java.io.NotSerializableException</code>，意思是Student类不能被序列化，需要实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不需要实现任何方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>Serializable其实是一个标志接口，用来标志该类是否可以被序列化。我们进到该接口的源码可以发现里面不含任何属性和抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ObjectInputStream实现反序列化（读取重构对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\stu.bin&quot;</span>);</span><br><span class="line">    ObjectInputStream objectInputStream=<span class="keyword">new</span> ObjectInputStream(fileInputStream);</span><br><span class="line">    <span class="comment">//读取文件（反序列化）</span></span><br><span class="line">    Student student=(Student) objectInputStream.readObject();</span><br><span class="line">    </span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化和反序列化注意事项"><a href="#序列化和反序列化注意事项" class="headerlink" title="序列化和反序列化注意事项"></a><strong>序列化和反序列化注意事项</strong></h3><ul>
<li><p>序列化类必须实现Serializable接口，前文已经说过。</p>
</li>
<li><p>序列化类中的对象属性也要求实现Serializable接口。也就是说如果Student类中有一个Grad类型的属性<code>private Grad info;</code>那么Grad这个类也要实现Serializable接口。</p>
</li>
<li><p>序列化类中可以添加序列化版本号ID，以保证序列化的类和被序列化的类是同一个类。在上面的代码中我并没有添加序列号版本，虽然IDE没有报错，但是会显示一个警告，提示我添加序列化版本号（串行版本标识）。我们可以在Student类中添加：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>  此时再运行Demo7就会报一个无效类的异常：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException:</span><br><span class="line">local class incompatible: stream classdesc serialVersionUID = -3126921853274410929, local class serialVersionUID = 666660</span><br></pre></td></tr></table></figure>

<p>  意思就是两个类的serialVersionUID不一样。可以看到之前虽然没有显式添加序列版本号，但它已经自动生成了一个。我们再运行一下Demo6序列化，再运行Demo7反序列化就可以正常执行了。</p>
<ul>
<li>使用transient（短暂的）修饰属性，可以避免该属性被序列化。用它来修饰age：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>

<p>  对象序列化后再反序列化，这个对象的age属性就变成了0。</p>
<ul>
<li><p>静态属性不能被序列化。</p>
</li>
<li><p>可以利用集合来序列化多个对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">arrayList.add(s1);</span><br><span class="line">arrayList.add(s2);</span><br><span class="line">arrayList.add(s3);</span><br><span class="line">objectOutputStream.writeObject(arrayList);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; list=(ArrayList&lt;Student&gt;)objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a><strong>编码方式</strong></h2><ul>
<li><p>IOS-8859-1</p>
<p>收录除ASCII外，还包括西欧、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。采用1个字节来表示，最多只能表示256个字符。</p>
</li>
<li><p>UTF-8</p>
<p>针对Unicode码表的可变长度字符编码。国际上使用的编码，也称为“万国码”，收录了几乎所有国家的常用字符。采用1至3个字节来表示一个字符。</p>
</li>
<li><p>GB2312</p>
<p>简体中文，采用1个或2个字节来表示字符，95年之前所采用的编码。</p>
</li>
<li><p>GBK</p>
<p>简体中文的扩充，GB2312的升级版本。</p>
</li>
<li><p>BIG5</p>
<p>台湾，繁体中文。</p>
</li>
</ul>
<p><strong>当编码方式和解码方式不一致时，会出现乱码。</strong>假如Demo1中的文件内容不是字母而是“<strong>我爱中国</strong>”这样的汉字，那么读取出来的信息就是乱码。因为字节流按字节输入输出，而这1个汉字占了12个字节，1个汉字占3个字节，把一个汉字按一个一个字节读入自然会出现问题，这时就需要使用字符流。</p>
<hr>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a><strong>字符流</strong></h2><img src="/2021-01-JavaSE-IO%E6%B5%81/4.png" class="">

<h3 id="字符流的父类（抽象类）"><a href="#字符流的父类（抽象类）" class="headerlink" title="字符流的父类（抽象类）"></a>字符流的父类（抽象类）</h3><ul>
<li><p><strong>Reader：</strong>字符输入流</p>
<ul>
<li><p><code>public int read()</code></p>
<p>从流中读取单个字符，用整型来返回读取的字符；当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] c)</code></p>
<p>从流中读取字符保存到c数组中，返回读取的字符个数，当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] cbuf,int off,int len)&#123;&#125;</code></p>
<p>抽象方法。</p>
</li>
</ul>
</li>
<li><p><strong>Writer：</strong>字符输出流</p>
<ul>
<li><p><code>public void write(int n)</code></p>
<p>写入单个字符，只能写入包含16位低阶字节的整型数值，16位高阶字节将会被忽略。</p>
</li>
<li><p><code>public void write(String str)</code></p>
<p>写入一个字符串。</p>
</li>
<li><p><code>public void write(char[] cbuf)</code></p>
<p>写入一个字符数组。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符流的子类"><a href="#字符流的子类" class="headerlink" title="字符流的子类"></a><strong>字符流的子类</strong></h3><ul>
<li><p><strong>FileReader：</strong></p>
<ul>
<li><p><code>public int read()</code></p>
<p>继承自InputStreamReader类。读取单个字符，返回读取的字符，当读到流底部时返回-1。</p>
</li>
<li><p><code>public int read(char[] c)</code></p>
<p>继承自Reader类。</p>
</li>
<li><p><code>public int read(char[] cbuf,int offset,int length)</code></p>
<p>继承自InputStreamReader类。从流中读取部分字符到cbuf中指定位置，返回读取到的字符个数，当读到流底部时返回-1。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    <span class="comment">//文件内容：</span></span><br><span class="line">    <span class="comment">//要是能活在梦里，我情愿醒不过来。</span></span><br><span class="line">    FileReader fileReader=<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\cbuf.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">//read();与字节流不同，该方法读取单个字符而不是字节</span></span><br><span class="line">    <span class="keyword">while</span>((data=fileReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出：</span></span><br><span class="line">    <span class="comment">//要是能活在梦里，我情愿醒不过来。</span></span><br><span class="line">    fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里记录我遇到的一个问题</strong>：</p>
<p>上述代码执行后理应是正常输出一段文字，但我这里出现了文字乱码。猜测是编码出现了问题，于是查看本地文本的保存格式为UTF-8，感觉也没错，于是打开JDK API查看FileReader类的描述：</p>
<blockquote>
<p>Convenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate. To specify these values yourself, construct an InputStreamReader on a FileInputStream.</p>
</blockquote>
<p>大意就是该类的构造方法有一个默认的字符编码格式和一个默认字节缓冲区，并没有指明这个编码格式就是UTF-8。于是查看系统默认编码，打开CMD输入chcp，得到一个值为936的活动编码页，通过查询得知该代码页所对应的国家（地区）或语言为：中国 - 简体中文(GB2312)。这与本地所保存的文本编码UTF-8不一致，所以导致了文字乱码的出现。而要指定编码格式需要创建一个InputStreamReader或FileInputStream对象使用其构造方法。</p>
<p>以下是我在本地能正常运行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    <span class="comment">//指定编码格式</span></span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\cbuf.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">while</span>((data=inputStreamReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">    &#125;</span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>FileWriter:</strong></p>
<ul>
<li><p><code>public void write(int c)</code></p>
<p>继承自OutputStreamWriter类，写入一个字符。</p>
</li>
<li><p><code>public void write(String str)</code></p>
<p>继承自Writer类。</p>
</li>
<li><p><code>public void Write(char[] cbuf)</code></p>
<p>继承自Writer类。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用FileWriter写入文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileWriter fileWriter=<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//写入</span></span><br><span class="line">    fileWriter.write(<span class="string">&quot;给自己一个希望。&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    fileWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符流小案例"><a href="#字符流小案例" class="headerlink" title="字符流小案例"></a><strong>字符流小案例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FileReader和FileWrite复制文本文件</span></span><br><span class="line"><span class="comment"> *  注：不能复制图片或二进制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\w.txt&quot;</span>));</span><br><span class="line">    FileWriter fileWriter=<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">int</span> data=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((data=inputStreamReader.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    fileWriter.write(data);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">    fileWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a><strong>字符缓冲流</strong></h4><ul>
<li><p><strong>缓冲流</strong>：BufferedReader/BufferedWriter</p>
<ul>
<li>高效读写</li>
<li>支持换行输入符</li>
<li>可一次写一行、读一行。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字符缓冲流读取文件</span></span><br><span class="line"><span class="comment">* BufferedReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader inputStreamReader=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\cbuf.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">    <span class="comment">//read(char[] cbuf)</span></span><br><span class="line">    <span class="keyword">char</span>[] cbuf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">while</span>((count=bufferedReader.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,count));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//readline();</span></span><br><span class="line">    <span class="comment">//该方法一次读取一行，返回一个字符串</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line=bufferedReader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用字符缓冲流写入文件</span></span><br><span class="line"><span class="comment">* BufferedWriter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\w3.txt&quot;</span>));</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;真有人看这篇博客吗？&quot;</span>);</span><br><span class="line">    <span class="comment">//写入一个换行符windows \r\n  linux \n</span></span><br><span class="line">    bufferedWriter.newLine();</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;不会吧不会吧！！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    bufferedWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a><strong>打印流</strong></h4><ul>
<li><p><strong>PrintWriter：</strong></p>
<ul>
<li>封装了print()/println()方法，支持写入后换行。</li>
<li>支持数据原样打印。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PrintWriter的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;d:\\p.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//打印到文件</span></span><br><span class="line">    printWriter.println(<span class="number">97</span>);<span class="comment">//97</span></span><br><span class="line">    printWriter.println(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//b</span></span><br><span class="line">    printWriter.println(<span class="number">3.14</span>);<span class="comment">//3.14</span></span><br><span class="line">    printWriter.println(<span class="keyword">true</span>);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    printWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><strong>转换流</strong></h4><ul>
<li><p><strong>桥转换流</strong>：InputStreamReader/OutputStreamWriter</p>
<ul>
<li>可将字节流转换为字符流。</li>
<li>可设置字符的编码方式。</li>
</ul>
<p>其实这个在上面的Demo中我已经用过了，这里不再演示InputStreamReader的使用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用OutputStreamWriter写入文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//可以自行指定编码</span></span><br><span class="line">    OutputStreamWriter outputStreamWriter=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\info.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.write(<span class="string">&quot;知道的越多，不明白的也就更多，学海无涯。&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用案例-总结"><a href="#常用案例-总结" class="headerlink" title="常用案例(总结)"></a>常用案例(总结)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCommon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D://IOCommon.txt&quot;</span>);<span class="comment">//字节输入流</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//转换流 字节转字符+指定编码</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);<span class="comment">//缓冲输入流</span></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="comment">//方式1</span></span><br><span class="line">        FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D://IOCommon1.txt&quot;</span>);<span class="comment">//字节输出流</span></span><br><span class="line">        OutputStreamWriter osw= <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//转换流 字符转字节+指定编码</span></span><br><span class="line">        BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(osw);<span class="comment">//缓冲输出流</span></span><br><span class="line">        <span class="comment">//方式2 原样输出 不支持指定编码</span></span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;D://IOCommon2.txt&quot;</span>);<span class="comment">//打印流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String line=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.write(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line">        br.close();</span><br><span class="line">        osw.close();</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a><strong>File类</strong></h2><ul>
<li><p><strong>概念</strong>：代表物理盘符中的一个<strong>文件</strong>或者<strong>文件夹</strong>。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><p><code>public boolean CreateNewFile()</code></p>
<p>当且仅当指定的文件名不存在时创建一个指定的新的、空的文件。创建成功返回true，如果指定文件名已存在返回false。</p>
</li>
<li><p><code>public boolean mkdir()</code></p>
<p>创建一个指定路径名的文件夹。当且仅当文件夹被创建时返回true，否则返回false。</p>
</li>
<li><p><code>public boolean delete()</code></p>
<p>删除一个指定的文件或文件夹，文件夹必须为空才能被删除。当且仅当指定的文件或文件夹被删除时返回true，否则返回false。</p>
</li>
<li><p><code>public boolean exists()</code></p>
<p>检查指定的文件或文件夹是否存在。当且仅当指定的文件或者文件夹存在时返回true，否则返回false。</p>
</li>
<li><p><code>public File[] listFiles()</code></p>
<p>列出目录中的所有内容，返回一个指定路径名中的文件数组，如果指定的路径名不代表一个文件夹（目录）就返回null。</p>
</li>
<li><p><code>public boolean renameTo(File dest)</code></p>
<p>重命名一个路径名所指定的文件。当且仅当修改操作成功时返回true，否则返回false。</p>
</li>
</ul>
</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示文件操作</span></span><br><span class="line"><span class="comment"> * 分隔符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//输出：</span></span><br><span class="line">    <span class="comment">//路径分隔符：;</span></span><br><span class="line">    <span class="comment">//名称分隔符：\</span></span><br><span class="line">    separator();</span><br><span class="line">    </span><br><span class="line">    fileOp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;路径分隔符：&quot;</span>+File.pathSeparator);</span><br><span class="line">    System.out.println(<span class="string">&quot;名称分隔符：&quot;</span>+File.separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileOp</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建文件</span></span><br><span class="line">    File file=<span class="keyword">new</span> File(<span class="string">&quot;d:\\file.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag=file.createNewFile();    </span><br><span class="line">    System.out.println(<span class="string">&quot;创建状态：&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.删除文件</span></span><br><span class="line">    <span class="comment">//2.1 直接删除</span></span><br><span class="line">    <span class="comment">/* System.out.println(&quot;删除结果：&quot;+file.delete()); */</span></span><br><span class="line">    <span class="comment">//2.2 使用JVM退出时删除（不是自己删除）</span></span><br><span class="line">    file.deleteOnExit();</span><br><span class="line">    <span class="comment">//调用休眠程序观察删除操作</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.获取文件信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取路径：&quot;</span>+file.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取父目录：&quot;</span>+file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件名称：&quot;</span>+file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件长度：&quot;</span>+file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取文件创建时间：&quot;</span>+<span class="keyword">new</span> Date(file.lastModified()).toLocaleString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否可写：&quot;</span>+file.canWrite());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可读：&quot;</span>+file.canRead());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span>+file.isHidden());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+file.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件夹：&quot;</span>+file.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a><strong>文件夹操作</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件夹的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    directorOp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">directorOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建文件夹</span></span><br><span class="line">    File dir=<span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb\\ccc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">    <span class="comment">//mkdir();只能创建单级目录</span></span><br><span class="line">    <span class="keyword">boolean</span> flag=dir.mkdirs();<span class="comment">//创建多级目录</span></span><br><span class="line">    System.out.println(<span class="string">&quot;创建结果：&quot;</span>+flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.删除文件夹</span></span><br><span class="line">    <span class="comment">//2.1 直接删除（必须为空目录）</span></span><br><span class="line">    <span class="comment">//System.out.println(&quot;删除结果：&quot;+dir.delete());</span></span><br><span class="line">    <span class="comment">//2.2 使用jvm删除</span></span><br><span class="line">    dir.deleteOnExit();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.获取文件夹信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取绝对路径：&quot;</span>+dir.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取路径：&quot;</span>+dir.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取父目录：&quot;</span>+dir.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;获取创建时间：&quot;</span>+<span class="keyword">new</span> Date(dir.lastModified()).toLocaleString());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件夹名称：&quot;</span>+dir.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span>+dir.isHidden());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是文件：&quot;</span>+dir.isFile());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历文件夹</span></span><br><span class="line">    File dir2=<span class="keyword">new</span> File(<span class="string">&quot;d:\\&quot;</span>);</span><br><span class="line">    String[] files=dir2.list();</span><br><span class="line">    <span class="keyword">for</span> (String string : files) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a><strong>文件过滤器</strong></h3><ul>
<li><p><strong>FileFilter接口：</strong></p>
<p><code>public interface FileFilter</code></p>
<ul>
<li><code>boolean accepte(File pathname)</code></li>
<li>当调用File类中的listFiles()方法时，支持传入FileFilter接口实现类，对获取的文件进行过滤，只有满足条件的文件才可以出现在listFiles()的返回值中。</li>
</ul>
<p>在上文Demo2中添加演示代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">directorOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File[] files1=dir2.listFiles(<span class="keyword">new</span> FileFilter() &#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathname.getName().endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (File file : files1) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件操作小案例"><a href="#文件操作小案例" class="headerlink" title="文件操作小案例"></a><strong>文件操作小案例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.递归遍历文件夹</span></span><br><span class="line"><span class="comment"> * 2.递归删除文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//案例1：递归遍历文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDer</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    File[] files=dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        listDer(file);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//案例2：递归删除文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    File[] files=dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files!=<span class="keyword">null</span>&amp;&amp;files.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        deleteDir(file);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    dir.delete();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="补充：Properties"><a href="#补充：Properties" class="headerlink" title="补充：Properties"></a><strong>补充：Properties</strong></h2><ul>
<li><p><strong>Properties：</strong>属性集合</p>
</li>
<li><p><strong>特点：</strong></p>
</li>
<li><p>存储属性名和属性值（键值对）。</p>
<ul>
<li>属性名和属性值都是字符串类型。</li>
<li>没有泛型。</li>
<li>和流有关（所以没有整理在集合里面）。</li>
</ul>
</li>
<li><p><strong>方法：</strong></p>
<ul>
<li><p><code>public String getProperty(String key)</code></p>
<p>根据key在属性列表里查找value，如果原始属性列表找不到就去默认属性列表找。返回key所对应的value。</p>
</li>
<li><p><code>public void list(PrintWriter out)</code></p>
<p>将属性列表打印在指定的输出流上，在debug时很有用。</p>
</li>
<li><p><code>public Object setProperty(String key,String value)</code></p>
<p>内部调用的是Hashtable的put方法，将key和value成对地保存在属性列表中。返回这个key上一个对应的value，没有就返回null。</p>
</li>
</ul>
<p>Properties可以保存在一个流中或是从一个流中加载，属性列表中的每个键值对都是一个字符串。一个属性列表可以包括另一个第二属性列表来作为它的默认值，如果在原始属性列表中没有找到key时就搜索第二属性列表。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示集合properties的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//添加数据</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tangrui&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    System.out.println(properties.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="comment">//3.1 keySet 略</span></span><br><span class="line">    <span class="comment">//3.2 entrySet 略</span></span><br><span class="line">    <span class="comment">//3.3 stringPropertyNames()</span></span><br><span class="line">    Set&lt;String&gt; set=properties.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">    System.out.println(string+<span class="string">&quot; &quot;</span>+properties.getProperty(string));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//和流有关的方法</span></span><br><span class="line">    <span class="comment">//list</span></span><br><span class="line">    PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;d:\\print.txt&quot;</span>);</span><br><span class="line">    properties.list(printWriter);</span><br><span class="line">    printWriter.close();</span><br><span class="line">    <span class="comment">//store保存</span></span><br><span class="line">    FileOutputStream fileOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\s.properties&quot;</span>);</span><br><span class="line">    properties.store(fileOutputStream, <span class="string">&quot;NOTES&quot;</span>);</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    <span class="comment">//load加载</span></span><br><span class="line">    Properties properties2=<span class="keyword">new</span> Properties();</span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\s.properties&quot;</span>);</span><br><span class="line">    properties2.load(fileInputStream);</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    System.out.println(properties2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用类</title>
    <url>/2021-01-JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li><strong>内部类的概念</strong><br>在一个类的内部再定义一个完整的类，一般内部类和外部类都会有依赖（层次）关系。</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类 身体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;</span><br><span class="line">    <span class="comment">//内部类 头</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>内部类的特点</strong></p>
<ul>
<li><p><strong>编译之后可生成独立的字节码文件</strong>。<br>上述代码在编译之后，除了生成一个<code>Body.class</code>文件，还会生成一个内部类文件<code>Body$Head.class</code>。</p>
</li>
<li><p><strong>内部类可以直接访问外部类的私有成员，而不破外封装性</strong>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> headNum=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//直接访问，没有问题</span></span><br><span class="line">            System.out.println(headNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>可为外部类提供必要的内部功能组件</strong>。<br>比如Head作为Body的“组件”。</p>
</li>
<li><p><strong>内部类的分类</strong></p>
<ol>
<li>成员内部类</li>
<li>静态内部类【重点】</li>
<li>局部内部类</li>
<li>匿名内部类【重点】</li>
</ol>
</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li><p><strong>在类的内部定义的</strong>，<strong>与实例变量</strong>、<strong>实例方法同级别的类</strong>。</p>
</li>
<li><p><strong>作为外部类的一个实例部分</strong>，<strong>创建内部类对象时</strong>，<strong>必须依赖外部类对象</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//访问外部类</span></span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">            <span class="comment">//访问内部类</span></span><br><span class="line">            System.out.println(phone);</span><br><span class="line">            System.out.println(address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建外部类对象</span></span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//2.创建内部类对象</span></span><br><span class="line">        Inner inner=outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一步到位</span></span><br><span class="line">        Inner inner2=<span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>当外部类</strong>、<strong>内部类存在同名属性时</strong>，<strong>会优先访问内部类属性</strong>。</p>
<p>在Inner类中新增属性<code>private int age=18;</code></p>
<p>再次运行testOuter类，控制台打印的age属性为18而不是21。</p>
<p>那么如何在Inner内部类中访问外部类的同名属性呢？很简单：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这表示访问Outer类的当前对象的age</span></span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.age);<span class="comment">//21</span></span><br><span class="line"><span class="comment">//这表示访问当前类对象的age</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.age);<span class="comment">//18</span></span><br></pre></td></tr></table></figure>

<p>第二句话中不加this也可以，但是加了会更清楚访问的是哪个类中的属性。</p>
<ul>
<li><strong>成员内部类不能定义静态成员</strong>。</li>
</ul>
<p>例外就是可以包含final修饰的静态常量。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul>
<li><strong>在成员内部类的基础之上添加一个static关键字</strong>，<strong>就变成了静态内部类</strong>。</li>
<li><strong>不依赖外部对象</strong>，<strong>可直接创建或通过类名访问</strong>，<strong>可声明静态成员</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类，相当于一个外部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//访问外部类的属性，需要创建外部类对象</span></span><br><span class="line">            Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">            System.out.println(outer.name);</span><br><span class="line">            System.out.println(outer.age);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用静态内部类的属性和方法，直接使用</span></span><br><span class="line">            System.out.println(phone);</span><br><span class="line">            System.out.println(address);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类直接创建</span></span><br><span class="line">        <span class="comment">//外部类.内部类 仅表示一种包含关系</span></span><br><span class="line">        Outer.Inner inner=<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>只有内部类才可以用static修饰，普通的类（外部类）不可以。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul>
<li><strong>类似局部变量</strong>，<strong>定义在外部类方法中</strong>；<strong>作用范围和创建对象范围仅限于当前方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示局部内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义局部变量</span></span><br><span class="line">        String address=<span class="string">&quot;四川&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类,不能加任何访问修饰符</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String phone=<span class="string">&quot;110&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> String email=<span class="string">&quot;99@qq.com&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//直接访问外部类的属性</span></span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="comment">//其实上一句省略了前缀，建议以后使用时加上。</span></span><br><span class="line">                System.out.println(Outer.<span class="keyword">this</span>.age);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//访问内部类属性</span></span><br><span class="line">                System.out.println(phone);</span><br><span class="line">                <span class="comment">//上一句省略了this</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.email);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//直接使用show方法，会有输出结果吗？</span></span><br><span class="line">        outer.show();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在testOuter中，创建了一个外部类对象调用其show方法，不会有任何结果，因为在show方法中，只是定义了一个局部变量和一个类，除此之外没有做任何事。如果要调用innerShow方法，想想该怎么修改代码？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//要调用局部内部类的方法，就要创建局部内部类对象</span></span><br><span class="line">        Inner inner=<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerShow();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候重新运行代码，控制台就正常打印了。</p>
<ul>
<li><p><strong>局部内部类访问外部类当前方法中的局部变量时</strong>，<strong>因无法保障变量的生命周期与自身相同</strong>，<strong>变量必须修饰为final</strong>。</p>
<p>举个例子，看上文的Outer类代码段，在JDK1.7之前，在局部内部类Inner的innerShow方法中添加代码：</p>
<p><code>System.out.println(address);//访问局部变量</code></p>
<p>这是不行的，除非address变量被final修饰成为一个常量。因为方法中的局部变量在离开方法体之后就会被立即销毁，而在方法体中new的局部内部类对象却不会立即消失（当然inner这个变量是没有了），而是留在堆中等待回收。想一想，局部内部类对象还存在，而他所访问的局部变量被销毁了，这是不可行的。而局部变量被final修饰之后就变成了一个常量，上文所添加的代码就相当于：</p>
<p>``System.out.println(“四川”);`</p>
<p>在JDK1.8中，局部变量即使没有被final修饰，在局部内部类使用时IDE也不会报错，这是因为在JDK1.8中会自动添加final修饰词。</p>
</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ul>
<li><p><strong>没有类名的局部内部类</strong>（<strong>一切特征都与局部内部类相同</strong>）。</p>
<p>实际上只是我们定义的时候没有取名字罢了，编译器编译之后会自动取一个名字。</p>
</li>
<li><p><strong>必须继承一个父类或者实现一个接口</strong>。</p>
<p>这不仅是使用的要求，这也是一般情况下使用匿名内部类的目的。</p>
</li>
</ul>
<p>演示一下匿名内部类的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个实现接口的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标正在工作。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        USB usb=<span class="keyword">new</span> Mouse();</span><br><span class="line">        usb.work();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是正常情况下我们新建一个实现类，可以让我们在不同类中多次使用。但是如果某个实现类只需要用到一次，之后就不会再用了，如果还是单独建一个class来实现的话是否麻烦且多余了？这时候就可以简化成局部内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机已连接。&quot;</span>);            </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        Phone phone=<span class="keyword">new</span> Phone();</span><br><span class="line">        phone.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为实现类只使用一次，类名看起来也是多余的，那么再精简优化一下就变成了<strong>匿名内部类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在new的接口中实现方法，这里也可以是一个抽象方法或者一个父类</span></span><br><span class="line">        USB phone=<span class="keyword">new</span> USB() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机已连接。&quot;</span>);        </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;;</span><br><span class="line">        phone.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>它是定义类</strong>、<strong>实现类</strong>、<strong>创建对象的语法合并</strong>，<strong>只能创建一个该类的对象</strong>。</p>
</li>
<li><p><strong>优点是减少代码量</strong>，<strong>缺点是可读性差</strong>。</p>
<p>我们可以查看一下本地生成的class文件，发现会一个<code>testUSB$1.class</code>文件，这个1就可以理解是匿名内部类的名字。</p>
</li>
</ul>
<hr>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li><p><strong>超类</strong>、<strong>基类</strong>，<strong>所有类的直接或间接父类</strong>，<strong>位于继承树的最顶层</strong>。</p>
</li>
<li><p><strong>任何类</strong>，<strong>如果没写extends关键字继承某个类</strong>，<strong>那么默认的就是直接继承Object类</strong>。</p>
</li>
<li><p><strong>Object类中所定义的方法</strong>，<strong>是所有对象都具备的方法</strong>。</p>
</li>
<li><p>Object类型可以存储任何对象</p>
<p>。</p>
<ul>
<li>作为参数，可接受任何对象。</li>
<li>作为返回值，可返回任何对象。</li>
</ul>
</li>
</ul>
<h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h3><ul>
<li><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></li>
<li><strong>返回引用中存储的实际对象类型</strong>。</li>
<li><strong>应用</strong>：<strong>通常用于判断两个引用中实际存储对象类型是否一致</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示getClass方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        Class class1=s1.getClass();</span><br><span class="line">        Class class2=s2.getClass();</span><br><span class="line">        <span class="keyword">if</span>(class1==class2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;属于同一类&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不属于同一类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><ul>
<li><p><code>pubilc int hashCode()&#123;&#125;</code></p>
</li>
<li><p><strong>返回该对象的哈希码值</strong>。</p>
</li>
<li><p><strong>哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值</strong>。</p>
</li>
<li><p><strong>一般情况下相同对象返回相同哈希码</strong>。</p>
<p>在我的另一篇有关集合的博客里就重写过这个方法使不同的对象返回相同的哈希码值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        System.out.println(s1.hashCode());<span class="comment">//96321</span></span><br><span class="line">        System.out.println(s2.hashCode());<span class="comment">//97314</span></span><br><span class="line">        <span class="comment">//相同字符串生成的哈希值相同</span></span><br><span class="line">        System.out.println(s3.hashCode());<span class="comment">//96321</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li><p><code>public String toString()&#123;&#125;</code></p>
</li>
<li><p><strong>返回该对象的字符串表示</strong>（<strong>表现形式</strong>）。</p>
<p>默认返回的是类名和一个十六进制表示的哈希值，也就是<code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code>。</p>
</li>
<li><p><strong>可以根据程序需求覆盖该方法</strong>，<strong>如展示对象的各个属性值</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//输出 包名.Student@15db9742</span></span><br><span class="line">        System.out.println(s1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般在使用这个方式时不会直接调用Object的父类方法，而是重写成自己期望的输出，例如通过调用这个方法得知当前对象的属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student类中重写方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再运行程序就是我们想看到的结果了。</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><ul>
<li><code>public boolean equals(Object obj)&#123;&#125;</code></li>
<li><strong>默认实现为（this==obj）</strong>，<strong>比较两个对象地址是否相同</strong>。</li>
<li><strong>可进行覆盖</strong>，<strong>比较两个对象的内容是否相同</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示equals的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);        </span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个对象的地址不同所以两个对象不相等，如果两个对象属性相同便认为他们是同一个对象，可以重写equals代码，重写一般会有固定的步骤：</p>
<ol>
<li>比较两个引用是否指向同一个对象。</li>
<li>判断obj是否为null。</li>
<li>判断两个引用指向的实际对象类型是否一致。</li>
<li>强制类型转换。</li>
<li>依次比较各个属性值是否相同。</li>
</ol>
<p>也可以使用IDE的快捷功能自动重写，以下是eclipes的重写内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Student other = (Student) obj;</span><br><span class="line">    <span class="keyword">if</span> (age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再次运行代码，控制台就输出true了。</p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><ul>
<li><p><strong>当对象被判定为垃圾对象时</strong>，<strong>由JVM自动调用此方法</strong>，<strong>用以标记垃圾对象</strong>，<strong>进入回收队列</strong>。</p>
<ul>
<li><p><strong>垃圾对象</strong></p>
<p>没有有效引用指向此对象时，为垃圾对象。</p>
</li>
<li><p><strong>垃圾回收</strong></p>
<p>由GC销毁垃圾对象，释放数据存储空间。</p>
</li>
<li><p><strong>自动回收机制</strong></p>
<p>JVM的内存耗尽，一次性回收所有垃圾对象。</p>
</li>
<li><p><strong>手动回收机制</strong></p>
<p>使用<code>System.gc();</code>通知JVM执行垃圾回收。</p>
</li>
</ul>
<p>这个方法实际上是不包含任何代码，它是一个空的方法，你可以重写该方法来观察JVM是否回收了某些对象，此处不再演示。</p>
</li>
</ul>
<hr>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p><strong>什么是包装类</strong>？</p>
<p>基本数据类型所对应的引用数据类型。</p>
</li>
<li><p><strong>Object可统一所有数据</strong>，<strong>包装的默认值为null</strong>。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>每个基本类型都对应着一个引用（包装）类型，基本类型存储在栈空间而引用类型存储在堆空间；把基础类型转换成引用类型的过程叫做装箱，每个引用类型都提供了一些方法和属性可供使用；把引用类型转换成基础类型的过程叫做拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拆箱和装箱演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装箱（两种方法）</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">        Integer integer1=<span class="keyword">new</span> Integer(num1);</span><br><span class="line">        Integer integer2=Integer.valueOf(num1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拆箱</span></span><br><span class="line">        <span class="keyword">int</span> num2=integer1.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.5之前，我们需要进行如上的操作来装箱和拆箱，但在JDK1.5之后，java就提供了自动装箱和拆箱的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">10</span>;</span><br><span class="line">    Integer integer1=num1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆箱</span></span><br><span class="line">    <span class="keyword">int</span> num2=integer1;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不必调用方法传值便可以实现装箱和拆箱。但实际上并不是不需要写，而是编译的时候java自动帮你做了这些工作。我们可以使用一个小工具Xjad来验证一下，这是一个反编译的工具，可以把class文件反编译成java代码，如果有需要可以自己百度下，这里只简单描述一下。运行上一段代码，将编译的class文件拖到这个小工具中，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    Integer integer1 = Integer.valueOf(num1);</span><br><span class="line">    <span class="keyword">int</span> num2 = integer1.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件在编译后自动调用了Integer中的方法。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>8种包装类提供不同类型间的转换方式。</p>
<ol>
<li>Number父类中提供的6个共性方法。</li>
<li>parseXXX()静态方法。</li>
<li>valueOf()静态方法。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基本类型和字符串之间的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.基本类型转换成字符串</span></span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">255</span>;</span><br><span class="line">        <span class="comment">//1.1 使用+号</span></span><br><span class="line">        String s1=n1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//1.2 使用Integer中的tostring方法</span></span><br><span class="line">        String s3=Integer.toString(n1);</span><br><span class="line">        String s2=Integer.toString(n1, <span class="number">10</span>);<span class="comment">//第二个参数是基数，可以理解为x进制</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.字符串转换成基本类型</span></span><br><span class="line">        String string=<span class="string">&quot;150&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n2=Integer.parseInt(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串转换成boolean类型，&quot;true&quot;-&gt;&quot;true&quot;  &quot;非true&quot;-&gt;&quot;false&quot;</span></span><br><span class="line">        String string2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line">        String string3=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b1=Boolean.parseBoolean(string2);<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">boolean</span> b2=Boolean.parseBoolean(string3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数缓冲区【重点】"><a href="#整数缓冲区【重点】" class="headerlink" title="整数缓冲区【重点】"></a>整数缓冲区【重点】</h3><ul>
<li><p><strong>Java预先创建了256个常用的整数包装类型对象</strong>。</p>
<p>什么意思呢？给大家三个问题，在继续往下看时，你先在心里给出一个答案：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 结果输出什么？</span></span><br><span class="line">        Integer integer1=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.结果输出什么？</span></span><br><span class="line">        Integer integer3=<span class="number">100</span>;</span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer3==integer4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.结果输出什么？</span></span><br><span class="line">        Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">        System.out.println(integer5==integer6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  三个问题的结果分别是<strong>false</strong>，<strong>true</strong>，<strong>false</strong>。</p>
<p>  先来回答第一个问题，两个存储在栈空间的变量分别指向的是两个堆空间中的对象，两个对象的地址不一样，所以在比较时返回了false。</p>
<p>  第二个问题和第三个问题都是进行了自动装箱，为什么结果不一样？我们先来看看java是如何自动装箱的，同样借助Xjad小工具反编译Demo2.class文件，得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1 == integer2);</span><br><span class="line">        Integer integer3 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        Integer integer4 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer3 == integer4);</span><br><span class="line">        Integer integer5 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        Integer integer6 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        System.out.println(integer5 == integer6);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  发现java自动装箱调用的是valueOf这个方法，<strong>重点</strong>来了，进入到这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  可以看见该方法首先判断了传入值的范围，我们查看一下这个范围的大小，进入到IntegerCache类的源码（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码只截取了部分，以便更好地分析与讲解</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  IntegerCache字面意思就是整型缓冲区。该类定义了一个值为-128的变量low和一个值为127的变量high，还有一个数组大小为[(127+128)+1]=256的变量cache；并且，使用了一个for循环，用-128到127范围的值初始化了cache数组。</p>
<p>  这时候再回到valueOf方法源码中，发现if判断的就是传入值是否在-128到127之间，是的话就直接返回cache数组中的对应值，也就是说，如果传入的数字在这个范围内，那么对应装箱的Integer对象其实已经是初始化过的，直接拿来用。如果valueOf方法传入的值不在这个范围，那么返回的就是用Integer构造方法new的一个对象。</p>
<p>  所以第二个问题答案是true，它们所引用的就是cache数组中的同一个地址；而第三个问题中的变量不在cache范围内，所以所执行的代码同第一个问题。</p>
<hr>
<h2 id="可变字符串"><a href="#可变字符串" class="headerlink" title="可变字符串"></a>可变字符串</h2><ul>
<li><strong>StringBuffer</strong>：可变长字符串，JDK1.0提供，运行效率慢、线程安全。</li>
<li><strong>StringBuilder</strong>：可变长字符串，JDK1.5提供，运行效率快、线程不安全。</li>
</ul>
<p>这两个类相当于String的增强类，事先开辟了一块缓冲区；这两个类的用法是一样的，效率都比String高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示StringBuilder常用方法的使用</span></span><br><span class="line"><span class="comment"> * 效率比String高；比String节省内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//1. append();追加</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;我&quot;</span>);<span class="comment">//我</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;菜&quot;</span>);<span class="comment">//我菜</span></span><br><span class="line">        <span class="comment">//2. insert();插入</span></span><br><span class="line">        stringBuilder.insert(<span class="number">0</span>, <span class="string">&quot;前&quot;</span>);<span class="comment">//前我菜</span></span><br><span class="line">        <span class="comment">//3. replace();替换</span></span><br><span class="line">        stringBuilder.replace(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;你&quot;</span>);<span class="comment">//前你菜</span></span><br><span class="line">        <span class="comment">//4. delete();删除</span></span><br><span class="line">        stringBuilder.delete(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//你菜</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>下面的输出结果是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> b1=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> b2=<span class="number">0.9</span>;</span><br><span class="line">System.out.print(b1-b2);</span><br></pre></td></tr></table></figure>

<p>正常的运算答案是0.1，而程序输出的结果是<code>0.0999...98</code>。因为浮点类型存储的实际是一个近似值，经过计算之后肯定会有误差，只不过这种误差很小。</p>
<p>很多实际应用中需要精确计算，用double肯定不符合要求，这时候需要借助BigDecimal类来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示BigDecimal类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        BigDecimal b2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        System.out.println(b1.subtract(b2));<span class="comment">//减法 0.1</span></span><br><span class="line">        System.out.println(b1.add(b2));<span class="comment">//加法 1.9</span></span><br><span class="line">        System.out.println(b1.multiply(b2));<span class="comment">//乘法 0.90    </span></span><br><span class="line">        System.out.println(b2.divide(b1));<span class="comment">//除法 0.9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到以上计算没有问题，但是要注意的是，如果除法的结果除不尽，那么就会报一个异常；所以在除法运算的时候需要使用divide的另外一个构造方法<code>divide(divisor, scale, roundingMode)</code>。</p>
<ul>
<li>参数divisor：除数</li>
<li>参数scale：指定精确到小数点后几位</li>
<li>参数roundingMode：<ul>
<li>指定小数部分的取舍模式，通常采用四舍五入的模式。</li>
<li>取值为<code>BigDecimal.ROUND_HALF_UP</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;10&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//3.33</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;20&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//6.67</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><ul>
<li>Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代（已过时）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Date类中尚未过时的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date d1=<span class="keyword">new</span> Date();</span><br><span class="line">        Date d2=<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//当前时间 Wed Nov 04 12:01:52 CST 2020</span></span><br><span class="line">        System.out.println(d1.toString());</span><br><span class="line">        <span class="comment">//已过时，打印当地时间</span></span><br><span class="line">        <span class="comment">//2020-11-4 12:01:52</span></span><br><span class="line">        System.out.println(d1.toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//after before判断两个时间前后关系</span></span><br><span class="line">        d2=<span class="keyword">new</span> Date(d1.getTime()-<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">1000</span>);<span class="comment">//昨天此刻</span></span><br><span class="line">        System.out.println(d1.after(d2));<span class="comment">//true 今天在昨天后面</span></span><br><span class="line">        System.out.println(d1.before(d2));<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//compareTo比较，两者毫秒数相减，返回正负0</span></span><br><span class="line">        System.out.println(d1.compareTo(d2));<span class="comment">//1</span></span><br><span class="line">        System.out.println(d2.compareTo(d1));<span class="comment">//-1</span></span><br><span class="line">        System.out.println(d1.compareTo(d1));<span class="comment">//0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//equals判断是否相等</span></span><br><span class="line">        System.out.println(d1.equals(d2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li><p><strong>Calendar提供了获取或设置各种日历字段的方法</strong>。</p>
</li>
<li><p><strong>构造方法</strong><code>protected Calendar()</code></p>
<p>由于修饰符是protected，所以无法直接创建该对象。</p>
</li>
</ul>
<p>其他方法：</p>
<ul>
<li><p><code>static Calendar getInstance()</code></p>
<p>使用默认时区和区域获取日历。</p>
</li>
<li><p><code>void set(int year,int month,int date,int hourOfDay,int minute,int second)</code></p>
<p>设置日历的年、月、日、时、分、秒。</p>
</li>
<li><p><code>int get(int field)</code></p>
<p>返回给定日历字段的值。字段比如年、月、日等。</p>
</li>
<li><p><code>void setTime(Date date)</code></p>
<p>用给定的Date设置次日历的时间。Date-&gt;Calendar</p>
</li>
<li><p><code>Date getTime()</code></p>
<p>返回一个Date表示此日历的时间。Calendar-&gt;Date</p>
</li>
<li><p><code>void add(int field,int amount)</code></p>
<p>按照日历的规则，给指定字段添加或减少时间量。</p>
</li>
<li><p><code>long getTimeMillies()</code></p>
<p>毫秒为单位返回该日历的时间值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Calendar类常用方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Calendar对象</span></span><br><span class="line">        Calendar calendar=Calendar.getInstance();</span><br><span class="line">        <span class="comment">//2020-11-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        <span class="comment">//1604469056368</span></span><br><span class="line">        System.out.println(calendar.getTimeInMillis());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取时间信息</span></span><br><span class="line">        <span class="comment">//年 2020</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        <span class="comment">//月 11 值为0-11</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//日 4</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="comment">//小时 1/13 12小时/24小时</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        <span class="comment">//分钟 50</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.MINUTE));</span><br><span class="line">        <span class="comment">//秒 56</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.SECOND));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改时间</span></span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">//2019-11-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加或减少时间量</span></span><br><span class="line">        calendar.add(Calendar.MONTH, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2019-10-4 13:50:56</span></span><br><span class="line">        System.out.println(calendar.getTime().toLocaleString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取时间字段的最大值、最小值</span></span><br><span class="line">        <span class="comment">//31 / 1</span></span><br><span class="line">        System.out.println(calendar.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(calendar.getActualMinimum(Calendar.DAY_OF_MONTH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><ul>
<li><p><strong>SimpleDateFormat是一个以语言环境有关的方式来格式化和解析日期的具体类</strong>。</p>
</li>
<li><p><strong>可以进行格式化</strong>（<strong>日期到文本</strong>）<strong>和解析</strong>（<strong>文本和日期</strong>）。</p>
</li>
<li><p><strong>常用的时间模式字母</strong>：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>年中月份</td>
</tr>
<tr>
<td>d</td>
<td>月中天数</td>
</tr>
<tr>
<td>H</td>
<td>1天中小时数（0-23）</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Date对象</span></span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String string=simpleDateFormat.format(date);</span><br><span class="line">        <span class="comment">//2020/11/04 14:10:21</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解析（必须按照上面格式化的形式）</span></span><br><span class="line">        Date date2=simpleDateFormat.parse(<span class="string">&quot;1999/01/30 00:00:00&quot;</span>);</span><br><span class="line">        <span class="comment">//1999-1-30 0:00:00</span></span><br><span class="line">        System.out.println(date2.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li><p>系统类，主要用于获取系统的属性数据和其他操作，其构造方法是私有的。</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p><code>static void array(...)</code></p>
<p>复制数组</p>
</li>
<li><p><code>static long currentTimeMillis()</code></p>
<p>获取当前系统时间，返回的是毫秒值。通常用来计算某个操作的用时，操作前后各获取一个时间然后相减，所得的毫秒数就是用时。</p>
</li>
<li><p><code>static void gc()</code></p>
<p>建议JVM赶快启动垃圾回收器回收垃圾，具体是否调用是由系统决定的。</p>
</li>
<li><p><code>static void exit(int status)</code></p>
<p>退出JVM，如果参数是0表示正常退出JVM，非0表示异常退出JVM。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示array的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src= &#123;<span class="number">3</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">92</span>,<span class="number">65</span>,<span class="number">35</span>,<span class="number">85</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">int</span> srcPos=<span class="number">0</span>,destPos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=src.length;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * src:源数组</span></span><br><span class="line"><span class="comment">         * scrPos：复制的源数组起始位置</span></span><br><span class="line"><span class="comment">         * dest：目标数组</span></span><br><span class="line"><span class="comment">         * destPos：复制的目标数组起始位置</span></span><br><span class="line"><span class="comment">         * length：复制的数组长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.array(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Arrays类里也有一个Of复制数组的方法，这两个方法有什么区别呢？通过查看源码发现Arrays的这个方法内部调用的就是<code>System.array()</code>方法，而array方法的源码是被native修饰的本地方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到方法体是空的，它是一个原生函数，并不是由java来实现的，而是由c/c++来实现的，java只是调用了它，由c++实现的这个方法效率会比java快很多。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote>
<p>持续更新… 待工期间感觉无聊，一直觉得程序猿一定要有一个属于自己的博客，记录自己的学习过程、笔记，于是重新捡起了Hexo，完整的记录我搭建Hexo Next主题博客的过程,碰到无数的坑，掉了无数的头发，才勉勉强强搭建成现在的样子，给新手朋友一些建议，碰到问题多百度，多尝试，由于Next主题版本的原因，网上的方法不一定行，但一定有解决的办法，多参考一些大神的博客。你们也可以在下面评论给我提出建议。慢慢完成、完善后你会继续感到无尽寂寞（无敌）….</p>
</blockquote>
<span id="more"></span>

<ul>
<li>参考博客： 强烈感谢以下博主，存在copy的地方请见谅</li>
</ul>
<ol>
<li><p><span class="exturl" data-url="aHR0cDovL3NhaWxpLnNjaWVuY2UvZ2l0Lw==">http://saili.science/git/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sYXp5ZG9nMDM2LmdpdGVlLmlvLw==">https://lazydog036.gitee.io/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ub3Rlcy5kb3VibGVtaW5lLm1lLw==">https://notes.doublemine.me/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>QQ群：722344383 里面全是大佬</p>
</li>
</ol>
<h2 id="需要环境"><a href="#需要环境" class="headerlink" title="需要环境"></a>需要环境</h2><ol>
<li>Git</li>
<li>Node.js</li>
</ol>
<p>安装参考技术储备</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v //查看版本</span><br><span class="line">//hexo: <span class="number">5</span>.<span class="number">4</span>.<span class="number">0</span></span><br><span class="line">//hexo-cli: <span class="number">4</span>.<span class="number">2</span>.<span class="number">0</span></span><br><span class="line">//node: <span class="number">12</span>.<span class="number">21</span>.<span class="number">0</span>  不建议使用太高的版本，坑挺多</span><br></pre></td></tr></table></figure>

<p>在需要生成博客项目的路径下打开命令行输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init myblog //myblog 任意取名</span><br><span class="line"><span class="built_in">cd</span> myblog //进入项目文件</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹目录下有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>_config.yml: 博客的配置文件</li>
</ul>
<h3 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo g  //生成静态文件 </span><br><span class="line">hexo s  //启动Hexo服务</span><br></pre></td></tr></table></figure>

<p>打开hexo的服务，在浏览器输入localhost:4000访问博客</p>
<p>ctrl+c关闭服务</p>
<h3 id="放置主题"><a href="#放置主题" class="headerlink" title="放置主题"></a>放置主题</h3><ol>
<li><p>将下载好的主题文件 放入Hexo\themes文件下 我这里使用的是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">hexo-theme-next v7.8.0<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>更改<mark>站点配置文件</mark>中的theme: hexo-theme-next即可</p>
</li>
</ol>
<h2 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a><div id="1.4.1">将Hexo部署到GitHub</div></h2><h3 id="创建GitPage"><a href="#创建GitPage" class="headerlink" title="创建GitPage"></a>创建GitPage</h3><p>创建一个和你用户名相同的仓库，后面加.github,只有这样，将来要部署到GitHub page的时候，才会被识别, mw-gh.github.io</p>
<h3 id="绑定github"><a href="#绑定github" class="headerlink" title="绑定github"></a>绑定github</h3><p>绑定github用户名和邮箱</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br><span class="line"></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email  //检查</span><br></pre></td></tr></table></figure>

<p>然后创建SSH</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p>查看是否绑定成功<br>ssh -T <span class="exturl" data-url="bWFpbHRvOiYjeDY3OyYjeDY5OyYjeDc0OyYjNjQ7JiN4Njc7JiMxMDU7JiMxMTY7JiN4Njg7JiMxMTc7JiM5ODsmIzQ2OyYjOTk7JiMxMTE7JiN4NmQ7">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Hexo部署配置"><a href="#Hexo部署配置" class="headerlink" title="Hexo部署配置"></a>Hexo部署配置</h3><p>这一步，将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/mw-gh/mw-gh.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>然后安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>最后</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>过一会就可以访问<span class="exturl" data-url="aHR0cDovL213LWdoLmdpdGh1Yi5pby8=">http://mw-gh.github.io<i class="fa fa-external-link-alt"></i></span> 这个网站看到你的博客了</p>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><ol>
<li><p>购买域名 我是在腾讯云上购买的是chenmw.top</p>
</li>
<li><p>添加Github Pages解析：在Hexo/source中建立CNAME文件（没有后缀），文件内容为你希望访问项目的地址如：mw-blog.chenmw.top</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210228235810.jpg" class=""></li>
<li><p>在Github仓库设置中找到Custom domain 内容设置成一样</p>
</li>
<li><p>在你所购买域名网站，域名管理中找到DNS解析，添加一条主机记录为@,记录类型为CNAME，线路类型默认，记录值为你的github pages路径</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E5%9B%BE%E7%89%8720210301001016.png" class=""></li>
<li><p>项目重新部署 hexo d 访问chenmw.top即可</p>
<blockquote>
<p>hexo-d 报Error: Spawn failed 是CNAME文件与仓库中CNAME文件不一样</p>
</blockquote>
</li>
<li><p>项目添加了Valine功能的记得在LeanCloun 安全中心中添加Web安全域名</p>
</li>
</ol>
<h3 id="把代码放在github上管理"><a href="#把代码放在github上管理" class="headerlink" title="把代码放在github上管理"></a>把代码放在github上管理</h3><p><a href="#1.4.1">1.4.1</a>那一步创建的个人仓库只保存了个人文件和文章 github用来部署github pages的</p>
<p>这里我们自己上传一份代码便于管理</p>
<p>创建名为MyBlog的仓库 获取仓库链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL013LUdIL015QmxvZy5naXQ=">https://github.com/Mw-GH/MyBlog.git<i class="fa fa-external-link-alt"></i></span></p>
<p>然后在MyBlog文件夹中运行Git Bash</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git init   //<span class="number">1</span>. 初始化本地仓库</span><br><span class="line">git add .  //<span class="number">2</span>. add到暂缓区</span><br><span class="line">git commit -m &#x27;初始化&#x27;  //commit到提交区</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/Mw-GH/MyBlog.git  //添加远程仓库地址</span><br><span class="line">git push -u origin master //上传到远程仓库 第一次上传 远程仓库为空 所有要加-u参数</span><br></pre></td></tr></table></figure>

<p>由此完成代码上传到github</p>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><p>先拉去站点文件Mw-Blog，再拉取主题文件hexo-theme-next</p>
<p>站点文件中没有node_modules原因是不是自己写的代码，且文件较大，只要目录中有package.json文件，运行npm install就会自动建立node_modules且下载原来的依赖</p>
<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><h3 id="博客信息"><a href="#博客信息" class="headerlink" title="博客信息"></a>博客信息</h2></h3><p><mark>站点配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Mw-Blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">个人博客</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Mw</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line"><span class="comment"># Sidebar Position.</span></span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="string">//右侧</span></span><br><span class="line"><span class="comment">#position: right</span></span><br></pre></td></tr></table></figure>

<h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line"><span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="comment"># You can also use other linking images.</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">/images/Mw.png</span></span><br><span class="line"><span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line"><span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line"><span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="浏览进度百分比"><a href="#浏览进度百分比" class="headerlink" title="浏览进度百分比"></a>浏览进度百分比</h3><p><mark>主题配置文件</mark></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="个性化设置（进阶）"><a href="#个性化设置（进阶）" class="headerlink" title="个性化设置（进阶）"></a>个性化设置（进阶）</h2><h3 id="卜蒜子统计访客人数"><a href="#卜蒜子统计访客人数" class="headerlink" title="卜蒜子统计访客人数"></a>卜蒜子统计访客人数</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line"><span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line"><span class="attr">post_views:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h3 id="顶部背景-菜单栏阴影"><a href="#顶部背景-菜单栏阴影" class="headerlink" title="顶部背景 菜单栏阴影"></a>顶部背景 菜单栏阴影</h3><p>\themes\hexo-theme-next\source\css_common\outline\header\header.styl</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: url(<span class="string">&quot;../images/bg.jpg&quot;</span>) no-repeat <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\themes\hexo-theme-next\source\css_common\outline\header\menu.styl</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.65</span>);</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加统计文章字数和文章阅读时间"><a href="#添加统计文章字数和文章阅读时间" class="headerlink" title="添加统计文章字数和文章阅读时间"></a><strong>添加统计文章字数和文章阅读时间</strong></h3><ol>
<li>安装插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br><span class="line">npm install eslint --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><mark>站点配置文件</mark>添加</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span>   <span class="comment"># 文章阅读时长</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span>  <span class="comment"># 站点总字数统计</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment"># 站点总阅读时长</span></span><br><span class="line"><span class="attr">exclude_codeblock:</span> <span class="literal">false</span> <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><mark>站点配置文件</mark>添加</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span> <span class="comment"># 是否另起一行（true的话不和发表时间等同一行）</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span> <span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">true</span>   <span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span>  <span class="comment"># Average Word Length</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span> <span class="comment"># Words Per Minute（每分钟阅读词数）</span></span><br><span class="line"><span class="attr">suffix:</span> <span class="string">mins.</span></span><br><span class="line"></span><br><span class="line"><span class="string">post_wordcount:#</span> <span class="string">字数统计</span></span><br><span class="line"><span class="attr">item_text:</span> <span class="literal">true</span><span class="comment"># 是否显示文字</span></span><br><span class="line"><span class="attr">wordcount:</span> <span class="literal">true</span><span class="comment"># 显示字数</span></span><br><span class="line"><span class="attr">min2read:</span> <span class="literal">true</span> <span class="comment"># 显示阅读时间</span></span><br><span class="line"><span class="attr">totalcount:</span> <span class="literal">true</span><span class="comment"># 显示总数</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否分开</span></span><br></pre></td></tr></table></figure>

<h3 id="修改底部顺序-由于卜算子是单独的一个文件-文件读取靠前"><a href="#修改底部顺序-由于卜算子是单独的一个文件-文件读取靠前" class="headerlink" title="修改底部顺序 由于卜算子是单独的一个文件 文件读取靠前"></a>修改底部顺序 由于卜算子是单独的一个文件 文件读取靠前</h3><p>找到busuanzi-counter.swig文件  把文件内容拷贝到footer.swig文件中  调整模块div位置即可</p>
<p>删除themes\hexo-theme-next\layout_third-party\statistics\index.swig中对busuanzi-counter.swig文件的引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.beian.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;beian&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;- next_url(&#x27;https://beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;</span><br><span class="line">&#123;%- if theme.footer.beian.gongan_icon_url %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(theme.footer.beian.gongan_icon_url) &#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block;&quot;</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line">&#123;%- if theme.footer.beian.gongan_id and theme.footer.beian.gongan_num %&#125;</span><br><span class="line">&#123;&#123;- next_url(&#x27;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=&#x27; + theme.footer.beian.gongan_id, theme.footer.beian.gongan_num + &#x27; &#x27;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span></span><br><span class="line">&#123;% set copyright_year = date(null, &#x27;YYYY&#x27;) %&#125;</span><br><span class="line"><span class="symbol">&amp;copy;</span> &#123;% if theme.footer.since and theme.footer.since != copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">&quot;copyrightYear&quot;</span>&gt;</span>&#123;&#123; copyright_year &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;with-love&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;copyrightHolder&quot;</span>&gt;</span>&#123;&#123; theme.footer.copyright or author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wordcount&quot;</span>&gt;</span></span><br><span class="line">&#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-chart-area&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; symbolsCountTotal(site) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-coffee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125; <span class="symbol">&amp;asymp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __(&#x27;symbols_count_time.time_minutes&#x27;)) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-count&quot;</span>&gt;</span></span><br><span class="line">&lt;script&#123;&#123; pjax &#125;&#125; async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-uv&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;site-pv&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;powered-by&quot;</span>&gt;</span></span><br><span class="line">&#123;%- set next_site = &#x27;https://theme-next.org&#x27; %&#125;</span><br><span class="line">&#123;%- if theme.scheme !== &#x27;Gemini&#x27; %&#125;</span><br><span class="line">&#123;%- set next_site = &#x27;https://&#x27; + theme.scheme | lower + &#x27;.theme-next.org&#x27; %&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line">&#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.add_this_id %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;addthis_inline_share_toolbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//s7.addthis.com/js/300/addthis_widget.js#pubid=&#123;&#123; theme.add_this_id &#125;&#125;&quot;</span> <span class="attr">async</span>=<span class="string">&quot;async&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject(&#x27;footer&#x27;) &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>打开<mark>主题配置文件</mark>，修改auto_excerpt:字段为true，length表示显示文本的长度</p>
<p>在想要隐藏的位置加入以下代码：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加文章评论和阅读次数"><a href="#添加文章评论和阅读次数" class="headerlink" title="添加文章评论和阅读次数"></a>添加文章评论和阅读次数</h3><blockquote>
<p>Valine 仅支持 Next 7.+ 以下版本<br>Next8.0 以上版本取消了Valine评论系统的支持</p>
</blockquote>
<ol>
<li><p>创建LeanCloud账号: <span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhbmNsb3VkLmNuLw==">https://www.leancloud.cn/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>创建应用</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227123921.png" class=""></li>
<li><p>点击存储-&gt;结构化数据 检查是否有Counter Comment 没有则创建</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227125317.png" class=""></li>
<li><p>点击设置-&gt;应用Key 获取AppID AppKey 下文需要用到</p>
<img src="/2021-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QQ%E6%88%AA%E5%9B%BE20210227130954.png" class="" width="700" height="600"></li>
<li><p>打开<mark>主题配置文件</mark>开启Valine</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">appid:</span> <span class="comment">#你的AppID</span></span><br><span class="line"><span class="attr">appkey:</span> <span class="comment">#你的AppKey</span></span><br><span class="line"><span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line"><span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line"><span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line"><span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line"><span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line"><span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读次数</span></span><br><span class="line"><span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 评论次数</span></span><br><span class="line"><span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line"><span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line"><span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定文章关闭评论</p>
</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>自定义头像<br>参考：<span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnL2F2YXRhci5odG1s">https://valine.js.org/avatar.html<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<blockquote>
<p>本篇参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdW5pYW5fMjc2MS9hcnRpY2xlL2RldGFpbHMvOTczODg5OTc=">https://blog.csdn.net/jiunian_2761/article/details/97388997<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="文章插入图片，点击查看大图"><a href="#文章插入图片，点击查看大图" class="headerlink" title="文章插入图片，点击查看大图"></a>文章插入图片，点击查看大图</h3><h4 id="文章插入图片"><a href="#文章插入图片" class="headerlink" title="文章插入图片"></a>文章插入图片</h4><ol>
<li>绝对路径本地引用(不采用)</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>

<p>不推荐 图片存放过多后不便于查找</p>
<ol start="2">
<li>相对路径引用(不采用)</li>
</ol>
<p>开启<mark>站点配置文件</mark>中的post_asset_folder:true,执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<p>这种相对路径的图片显示方法在博文详情页面显示没有问题，但是在首页预览页面图片将显示不出来。</p>
<ol start="3">
<li>标签插件语法引用(采用)</li>
</ol>
<p>标签插件语法，可以使图片在文章和首页中同时显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 本地图片资源，不限制图片尺寸</span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br><span class="line"># 网络图片资源，限制图片显示尺寸</span><br><span class="line">&#123;% img http://www.viemu.com/vi-vim-cheat-sheet.gif 200 400 vi-vim-cheat-sheet %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="点击查看大图"><a href="#点击查看大图" class="headerlink" title="点击查看大图"></a>点击查看大图</h4><p>开启<mark>主题配置文件</mark>中的fancybox</p>
<p>fancybox:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1mYW5jeWJveDM=">https://github.com/theme-next/theme-next-fancybox3<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>本篇参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuenl3dnZkLmNvbS8yMDIwLzAyLzI3L2hleG8vNF9oZXhvX2FkZF9pbWFnZS9oZXhvLWFkZC1pbWFnZS8=">https://www.zywvvd.com/2020/02/27/hexo/4_hexo_add_image/hexo-add-image/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="添加全局搜索功能"><a href="#添加全局搜索功能" class="headerlink" title="添加全局搜索功能"></a>添加全局搜索功能</h3><ol>
<li>安装插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启<mark>主题配置文件</mark>中的local_search</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line"><span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line"><span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line"><span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line"><span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line"><span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h3><ol>
<li>手动修改/node_modules/hexo-generator-index/lib/generator.js</li>
</ol>
<blockquote>
<p>网上的方法，个人不采用，node_modules文件不上传到github 不便于后期维护</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line"><span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line"><span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.top - b.top; <span class="comment">// 否则按照top值升序排</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">perPage: config.index_generator.per_page,</span><br><span class="line">layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">data: &#123;</span><br><span class="line">__index: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在文章title添加top值，值越大文章越靠前</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Linux常用命令 长期更新</span><br><span class="line">date: 2019-09-03</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 技术储备</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Linux</span><br><span class="line">top: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我个人关闭了主题配置文件中的created_at: false和不要文章title中的date 即创建时间，主页和文章仅显示更新时间，Hexo会已更新时间自动进行排序，然后加入top指定文章排序 普通文章设定为0(必须每篇文章都设定，这有点搞心态)，指定文章设定为1，2，3 值越大排序越靠前</p>
</blockquote>
<h3 id="hexo文章模板设置"><a href="#hexo文章模板设置" class="headerlink" title="hexo文章模板设置"></a>hexo文章模板设置</h3><p>每次使用hexo new post “post-name”新建一篇文章时，只有title date tags，<br>还要手动增加top 和 categories。</p>
<p>为了偷懒，修改了hexo/scaffolds中的post.md模板。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">top: 0</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><ul>
<li>新建文章结构</li>
</ul>
<p><mark>站点配置文件</mark>中找到new_post_name修改为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year\:month\:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hexo d 生成文章结构</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year-:month-:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown-语法大全</title>
    <url>/2021-03-MarkDown-%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1496626-851332d4c4ebc3d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt="img"></p>
<p><strong>说明</strong>：现在markDown编译器和各平台支持情况都不太统一，为了达到一些效果会使用语法超集，但有些平台支持不好，请自行裁剪。简书使用的精简语法集合，文中有些语法效果显示不出来，为了发文的格式统一，同时也建议谨慎使用此类语法。</p>
<span id="more"></span>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-设计理念"><a href="#1-1-设计理念" class="headerlink" title="1.1 设计理念"></a>1.1 设计理念</h3><ul>
<li>Markdown 易于阅读，方便创作web文档，利于各平台无缝分发。</li>
<li>Markdown 语法灵感最大的来源还是纯文本 email 的格式，完全由标点符号标签组成的纯文本。</li>
<li>Markdown 文件应该以纯文本形式原样发布，不应该包含标记标签和格式化指令。</li>
</ul>
<h3 id="1-2-内联-HTML-语法"><a href="#1-2-内联-HTML-语法" class="headerlink" title="1.2 内联 HTML 语法"></a>1.2 内联 HTML 语法</h3><ul>
<li>HTML 是一种<strong>发布格式</strong>，Markdown 是一种<strong>创作格式</strong>。</li>
<li>Markdown语法集合比较小，只是HTML标签的一小部分。</li>
<li>对于 Markdown 中未包含的标签, 可以直接使用 HTML标签，例如用 HTML <code>&lt;a&gt;</code> 标签替代 Markdown 的链接语法。</li>
</ul>
<h3 id="1-3-特殊字符自动转义"><a href="#1-3-特殊字符自动转义" class="headerlink" title="1.3 特殊字符自动转义"></a>1.3 特殊字符自动转义</h3><p>  在 HTML 中, 有两个字符需要特殊对待: &lt; 和 &amp;，左尖括号用于起始标签。如果你想将它们用作字面量, 你必须将它们转义为字符实体, 例如<code>&lt;</code> 和 <code>&amp;</code>。</p>
<h2 id="二、行内语法讲解"><a href="#二、行内语法讲解" class="headerlink" title="二、行内语法讲解"></a>二、行内语法讲解</h2><h3 id="2-1-注释的表述"><a href="#2-1-注释的表述" class="headerlink" title="2.1 注释的表述"></a>2.1 注释的表述</h3><ul>
<li><strong>代码法</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#x27;display: none&#x27;</span>&gt;</span></span><br><span class="line">哈哈我是注释，不会在浏览器中显示。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>html注释</strong></li>
</ul>
<p>既然支持html语法，那也支持html注释，快捷键 comment + /。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">哈哈我是多段注释，</span></span><br><span class="line"><span class="comment">不会在浏览器中显示。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>hack方法</strong></li>
</ul>
<p>hack方法就是利用markdown的解析原理来实现注释的。<br> 一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。<br> hack方法比上面2种方法稳定得多，但是语义化太差。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">//</span>]: <span class="meta"># (哈哈我是最强注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="meta">^_^</span>]: <span class="meta"># (哈哈我是最萌注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="meta">//</span>]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[<span class="meta">comment</span>]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-分级标题、任务列表"><a href="#2-2-分级标题、任务列表" class="headerlink" title="2.2 分级标题、任务列表"></a>2.2 分级标题、任务列表</h3><ul>
<li><strong>分级标题</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题  <span class="comment">&lt;!--最多6级标题--&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于用了标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<ul>
<li><strong>任务列表</strong></li>
</ul>
<p>Markdown 语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- <span class="selector-attr">[ ]</span> 任务一 未做任务 `- + 空格 + <span class="selector-attr">[ ]</span>`</span><br><span class="line">- <span class="selector-attr">[x]</span> 任务二 已做任务 `- + 空格 + <span class="selector-attr">[x]</span>`</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>任务一 未做任务 <code>- + 空格 + [ ]</code></li>
<li>任务二 已做任务 <code>- + 空格 + [x]</code></li>
</ul>
<h3 id="2-3-缩进、换行、空行、对齐方式"><a href="#2-3-缩进、换行、空行、对齐方式" class="headerlink" title="2.3 缩进、换行、空行、对齐方式"></a>2.3 缩进、换行、空行、对齐方式</h3><ul>
<li><strong>首行缩进</strong></li>
</ul>
<p>不同特殊占位符所占空白是不一样大的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">【1】 &amp;emsp;或&amp;<span class="comment">#8195; //全角</span></span><br><span class="line">【2】 &amp;ensp;或&amp;<span class="comment">#8194; //半角</span></span><br><span class="line">【3】 &amp;nbsp;或&amp;<span class="comment">#160;  //半角之半角</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>换行</strong></li>
</ul>
<p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要<strong>换行必须得在一行字后面空两个格子才行</strong>。</p>
<ul>
<li><strong>空行</strong></li>
</ul>
<p>在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在<strong>渲染之后，只隔着一行</strong>。</p>
<ul>
<li><strong>对齐方式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">行中心对齐</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>行左对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>行右对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>行中心对齐<br> <p align="left">行左对齐</p><br> <p align="right">行右对齐</p></p>
<h3 id="2-4-斜体、粗体、删除线、下划线、背景高亮"><a href="#2-4-斜体、粗体、删除线、下划线、背景高亮" class="headerlink" title="2.4 斜体、粗体、删除线、下划线、背景高亮"></a>2.4 斜体、粗体、删除线、下划线、背景高亮</h3><ul>
<li>代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*或_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br><span class="line">++下划线++</span><br><span class="line">&#x3D;&#x3D;背景高亮&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li>显示效果：</li>
</ul>
<p>  <em>斜体</em>    <strong>粗体</strong>   <strong><em>加粗斜体\</em></strong>   <del>删除线</del>   ++删除线++   ==背景高亮==</p>
<h3 id="2-5-超链接、页内链接、自动链接、注脚"><a href="#2-5-超链接、页内链接、自动链接、注脚" class="headerlink" title="2.5 超链接、页内链接、自动链接、注脚"></a>2.5 超链接、页内链接、自动链接、注脚</h3><ul>
<li><strong>行内式</strong></li>
</ul>
<p>语法说明：</p>
<p>[]里写链接文字，()里写链接地址, ()中的””中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。</p>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">欢迎阅读 [择势勤](https://www.jianshu.com/u/16d77399d3a7 <span class="string">&quot;择势勤&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>欢迎阅读 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS8xNmQ3NzM5OWQzYTc=">择势勤<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>参考式</strong></li>
</ul>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明：<br> 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br> [链接文字]：链接地址的形式，见代码的最后一行。</p>
<p>代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">我经常去的几个网站[Google][<span class="number">1</span>]、[Leanote][<span class="number">2</span>]。</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]<span class="symbol">:http</span><span class="symbol">://www</span>.google.com </span><br><span class="line">[<span class="number">2</span>]<span class="symbol">:http</span><span class="symbol">://www</span>.leanote.com</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>我经常去的几个网站<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vd3d3Lmdvb2dsZS5jb20=">Google<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vd3d3LmxlYW5vdGUuY29t">Leanote<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li><strong>注脚</strong></li>
</ul>
<p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<p>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">使用 Markdown<span class="selector-attr">[^1]</span>可以效率的书写文档, 直接转换成 <span class="selector-tag">HTML</span><span class="selector-attr">[^2]</span>。</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[^1]</span>:Markdown是一种纯文本标记语言</span><br><span class="line"></span><br><span class="line">[^<span class="number">2</span>]:HyperText Markup Language 超文本标记语言</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>使用 Markdown[<a href="#fn1">1]</a>可以效率的书写文档, 直接转换成 HTML[<a href="#fn2">2]</a>。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的地方。</p>
<ul>
<li><strong>锚点（页内超链接）</strong></li>
</ul>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的，只支持在标题后插入锚点，其它地方无效。</p>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 0. 目录&#123;#index&#125;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>跳转到<a href="#index">目录</a></p>
<ul>
<li><strong>自动链接</strong></li>
</ul>
<p>语法说明：<br> Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p>代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&amp;lt;http:<span class="comment">//example.com/&amp;gt; &amp;emsp;&amp;emsp; </span></span><br><span class="line">&amp;lt;address<span class="meta">@example</span>.com&amp;gt;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>&lt;<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwOi8vZXhhbXBsZS5jb20v">http://example.com/<i class="fa fa-external-link-alt"></i></span>&gt;<br> &lt;<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1tYWlsdG86YWRkcmVzc0BleGFtcGxlLmNvbQ==">address@example.com<i class="fa fa-external-link-alt"></i></span>&gt;</p>
<h3 id="2-6-无序列表、有序列表、定义型列表"><a href="#2-6-无序列表、有序列表、定义型列表" class="headerlink" title="2.6 无序列表、有序列表、定义型列表"></a>2.6 无序列表、有序列表、定义型列表</h3><ul>
<li><strong>无序列表</strong><br> 使用 *，+，- 表示无序列表。<br> 代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表项 一</span><br><span class="line">+ 无序列表项 二</span><br><span class="line">- 无序列表项 三</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ul>
<li><p>无序列表项 一</p>
</li>
<li><p>无序列表项 二</p>
</li>
<li><p>无序列表项 三</p>
</li>
<li><p><strong>有序列表</strong></p>
</li>
</ul>
<p>有序列表则使用数字接着一个英文句点。<br> 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 有序列表项 一</span><br><span class="line">2. 有序列表项 二</span><br><span class="line">3. 有序列表项 三</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<ul>
<li><strong>定义型列表表</strong></li>
</ul>
<p>语法说明：</p>
<blockquote>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
</blockquote>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:   轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格）</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>Markdown<br> :   轻量级文本标记语言，可以转换成html，pdf等格式</p>
<h3 id="2-7-插入图像"><a href="#2-7-插入图像" class="headerlink" title="2.7 插入图像"></a>2.7 插入图像</h3><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<p>Markdown 语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--开始居中对齐--&gt;</span></span><br><span class="line"></span><br><span class="line">![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif &quot;图片Title&quot;)</span><br><span class="line">格式: ![图片Alt](图片地址 &quot;图片Title&quot;)</span><br><span class="line"> <span class="comment">&lt;!--结束居中对齐--&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1496626-c3d52ee452341b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310/format/webp" alt="img"></p>
<p>GitHub set up</p>
<h3 id="2-8-多级引用"><a href="#2-8-多级引用" class="headerlink" title="2.8 多级引用"></a>2.8 多级引用</h3><p>语法说明：</p>
<p>引用需要在被引用的文本前加上&gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 &gt; 。</p>
<p>代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白</span><br><span class="line"><span class="meta">&gt;&gt;</span> 自己看教程！ - 愤青</span><br><span class="line">&gt; 教程在哪？ - 小白</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="2-9-转义字符、字体、字号、颜色"><a href="#2-9-转义字符、字体、字号、颜色" class="headerlink" title="2.9 转义字符、字体、字号、颜色"></a>2.9 转义字符、字体、字号、颜色</h3><ul>
<li><strong>转义字符</strong></li>
</ul>
<p>Markdown中的转义字符为\，转义的有：</p>
<p>\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号  # 井号 + 加号 - 减号 . 英文句号 ! 感叹号</p>
<ul>
<li><strong>字体、字号、颜色</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">12</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span>黑体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span>gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">3</span>&gt;</span>null<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><font face="黑体">我是黑体字</font><br> <font face="微软雅黑">我是微软雅黑</font><br> <font face="STCAIYUN">我是华文彩云</font><br> <font color=#0099ff size=12 face="黑体">黑体</font><br> <font color=gray size=5>gray</font><br> <font color=#00ffff size=3>null</font></p>
<h2 id="三、块语法讲解"><a href="#三、块语法讲解" class="headerlink" title="三、块语法讲解"></a>三、块语法讲解</h2><h3 id="3-1-内容目录"><a href="#3-1-内容目录" class="headerlink" title="3.1 内容目录"></a>3.1 内容目录</h3><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>

<p>效果参见最上方的目录。</p>
<h3 id="3-2-代码块"><a href="#3-2-代码块" class="headerlink" title="3.2 代码块"></a>3.2 代码块</h3><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p>
<ul>
<li><strong>行内式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C语言里的函数 `<span class="built_in">scanf</span>()` 怎么使用？</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<ul>
<li><strong>缩进式多行代码</strong></li>
</ul>
<p>缩进 4 个空格或是 1 个制表符</p>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;#<span class="number">34</span>;Hello world\n&amp;#<span class="number">34</span>;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;#<span class="number">34</span>;Hello world\n&amp;#<span class="number">34</span>;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用六个`包裹多行代码</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">、、、</span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure>

<p><strong>显示效果：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-流程图"><a href="#3-3-流程图" class="headerlink" title="3.3 流程图"></a>3.3 流程图</h3><p>编辑自有道云笔记，代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">graph LR</span></span><br><span class="line"><span class="string">A--&gt;B</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">sequenceDiagram</span></span><br><span class="line"><span class="string">A-&gt;&gt;B: How are you?</span></span><br><span class="line"><span class="string">B-&gt;&gt;A: Great!</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: How are you?</span><br><span class="line">B-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>

<h3 id="3-4-表格"><a href="#3-4-表格" class="headerlink" title="3.4 表格"></a>3.4 表格</h3><p>语法说明：</p>
<p>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br> 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br> 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br> <code>-</code> 左对齐， <code>:-:</code> 中心对齐，<code>-:</code> 右对齐</p>
<p>表格代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="params">|学号|</span>姓名<span class="params">|序号|</span></span><br><span class="line"><span class="params">|-|</span>-<span class="params">|-|</span></span><br><span class="line"><span class="params">|小明明|</span>男<span class="params">|5|</span></span><br><span class="line"><span class="params">|小红|</span>女<span class="params">|79|</span></span><br><span class="line"><span class="params">|小陆|</span>男<span class="params">|192|</span></span><br></pre></td></tr></table></figure>

<p>原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th align="center">姓名</th>
<th align="right">序号</th>
</tr>
</thead>
<tbody><tr>
<td>小明明</td>
<td align="center">男</td>
<td align="right">5</td>
</tr>
<tr>
<td>小红</td>
<td align="center">女</td>
<td align="right">79</td>
</tr>
<tr>
<td>小陆</td>
<td align="center">男</td>
<td align="right">192</td>
</tr>
</tbody></table>
<h3 id="3-5-LaTeX-公式"><a href="#3-5-LaTeX-公式" class="headerlink" title="3.5 LaTeX 公式"></a>3.5 LaTeX 公式</h3><ul>
<li><strong>表示行内公式</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 `<span class="variable">$E</span> = m c^2 $`来表达。</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>质能守恒方程可以用一个很简洁的方程式 <code>$E = m c^2 $</code>来表达。</p>
<ul>
<li><strong>表示整行公式</strong><br> 大部分的浏览器支持的</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> 公式 <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>有道云笔记 使用格式，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">E = mc^2</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>块级公式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"><span class="string">``</span><span class="string">`math</span></span><br><span class="line"><span class="string">[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =</span></span><br><span class="line"><span class="string">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; &#x3D;</span><br><span class="line">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]</span><br></pre></td></tr></table></figure>

<p>访问 <span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL21hdGgubWV0YS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTAyMC9tYXRoamF4LWJhc2ljLXR1dG9yaWFsLWFuZC1xdWljay1yZWZlcmVuY2U=">MathJax<i class="fa fa-external-link-alt"></i></span> 参考更多使用方法。</p>
<h3 id="3-6-分隔线"><a href="#3-6-分隔线" class="headerlink" title="3.6 分隔线"></a>3.6 分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure>

<p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h3 id="3-7-HTML-原始码"><a href="#3-7-HTML-原始码" class="headerlink" title="3.7 HTML 原始码"></a>3.7 HTML 原始码</h3><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p><strong>代码：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">第一个例子：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">© 2004 Foo Corporation</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">第二个例子：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>值班人员<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>星期三<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>李强<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>张明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>王平<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p>第一个例子：<br> <div class="footer"><br> © 2004 Foo Corporation<br> </div></p>
<p>第二个例子：</p>
<table> <tr> <th rowspan="2">值班人员</th> <th>星期一</th> <th>星期二</th> <th>星期三</th> </tr> <tr> <td>李强</td> <td>张明</td> <td>王平</td> </tr> </table>

<h3 id="3-8-特殊字符"><a href="#3-8-特殊字符" class="headerlink" title="3.8 特殊字符"></a>3.8 特殊字符</h3><table>
<thead>
<tr>
<th align="center">特殊字符</th>
<th align="center">描述</th>
<th align="center">字符的代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">空格符</td>
<td align="center"><code> </code></td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于号</td>
<td align="center"><code>&lt;</code></td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于号</td>
<td align="center"><code>&gt;</code></td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">和号</td>
<td align="center"><code>&amp;</code></td>
</tr>
<tr>
<td align="center">￥</td>
<td align="center">人民币</td>
<td align="center"><code>¥</code></td>
</tr>
<tr>
<td align="center">©</td>
<td align="center">版权</td>
<td align="center"><code>©</code></td>
</tr>
<tr>
<td align="center">®</td>
<td align="center">注册商标</td>
<td align="center"><code>®</code></td>
</tr>
<tr>
<td align="center">°C</td>
<td align="center">摄氏度</td>
<td align="center"><code>°C</code></td>
</tr>
<tr>
<td align="center">±</td>
<td align="center">正负号</td>
<td align="center"><code>±</code></td>
</tr>
<tr>
<td align="center">×</td>
<td align="center">乘号</td>
<td align="center"><code>×</code></td>
</tr>
<tr>
<td align="center">÷</td>
<td align="center">除号</td>
<td align="center"><code>÷</code></td>
</tr>
<tr>
<td align="center">²</td>
<td align="center">平方（上标²）</td>
<td align="center"><code>²</code></td>
</tr>
<tr>
<td align="center">³</td>
<td align="center">立方（上标³）</td>
<td align="center"><code>³</code></td>
</tr>
</tbody></table>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lYmU1MmQyZDQ2OGY=">https://www.jianshu.com/p/ebe52d2d468f<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术储备</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-反射</title>
    <url>/2021-01-JavaSE-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="类对象概述"><a href="#类对象概述" class="headerlink" title="类对象概述"></a>类对象概述</h2><ul>
<li><p>类的对象：基于某个类 new创建出来的对象，也称实例对象。</p>
</li>
<li><p><strong>类对象</strong>：<strong>类加载的产物</strong>，<strong>封装了一个类的所有信息</strong>（类名、父类、接口、属性、方法、构造方法）。</p>
<p>每个类加载到内存后都对应一个class对象，每个类有且仅有一个class对象。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//1.通过类的对象获取类对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class c1=p1.getClass();</span><br><span class="line">    System.out.println(c1);     <span class="comment">//class classObject.Person</span></span><br><span class="line">    System.out.println(c1.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">    <span class="comment">//2.通过类名获取类对象</span></span><br><span class="line">    Class&lt;Person&gt; c2=Person.class;</span><br><span class="line">    System.out.println(c2.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">    <span class="comment">//3.通过静态方法获取类对象 [推荐方式] 以上两种可能类不存在</span></span><br><span class="line">    Class c3=Class.forName(<span class="string">&quot;classObject.Person&quot;</span>);</span><br><span class="line">    System.out.println(c3.hashCode());      <span class="comment">//966808741</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1298420035</span></span><br><span class="line"><span class="number">1298420035</span></span><br><span class="line"><span class="number">1298420035</span></span><br></pre></td></tr></table></figure>

<p>这三个类的hashcode一样，说明这三个类对象是同一个，而且每个类加载到内存中只对应一个类对象。</p>
<p>在获取类对象时推荐使用第三种方式，前两种看上去很简单但是代码的依赖性太强，假如编译的时候没有Person这个类就会报错 ，而第三种的参数是一个字符串，编译的时候可以没有Person类，只要运行的时候有就行。</p>
<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>常用方法：</p>
<ul>
<li><p><code>public String getName()</code></p>
<p>获取类对象所代表的类的名字。</p>
</li>
<li><p><code>public Package getPackage()</code></p>
<p>获取类对象所代表的包的名字。</p>
</li>
<li><p><code>public Class&lt;? super T&gt; getSuperclass()</code></p>
<p>获取类对象所代表的类的父类。</p>
</li>
<li><p><code>public Class&lt;?&gt;[] getInterfaces()</code></p>
<p>获取类对象所代表的类或接口实现的接口。</p>
</li>
<li><p><code>public Constructors&lt;?&gt;[] getConstructors()</code></p>
<p>获取类对象所代表的类的所有公共构造方法。</p>
</li>
<li><p><code>public T newInstance()</code></p>
<p>创建类对象所代表的类一个新实例。</p>
</li>
<li><p><code>public Method[] getMethods()</code></p>
<p>获取类对象所代表的类或接口的公共成员方法。</p>
</li>
<li><p><code>public Field[] getFields()</code></p>
<p>获取类对象所代表的类或接口的公共访问字段。</p>
</li>
</ul>
<h3 id="获取类信息（名字、包名、父类、接口）"><a href="#获取类信息（名字、包名、父类、接口）" class="headerlink" title="获取类信息（名字、包名、父类、接口）"></a>获取类信息（名字<strong>、</strong>包名<strong>、</strong>父类<strong>、</strong>接口）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class classObject=Class.forName(<span class="string">&quot;reflect.classObject.Person&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfoFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"><span class="comment">//1.获取类信息</span></span><br><span class="line"><span class="comment">//1.2.获取类的名字</span></span><br><span class="line">System.out.println(classObject.getName());</span><br><span class="line"><span class="comment">//1.2.获取包的名字</span></span><br><span class="line">System.out.println(classObject.getPackage());</span><br><span class="line"><span class="comment">//1.3.获取类的父类</span></span><br><span class="line">System.out.println(classObject.getSuperclass());</span><br><span class="line"><span class="comment">//1.4.获取类的接口</span></span><br><span class="line">System.out.println(Arrays.toString(classObject.getInterfaces()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个方法返回的是一个数组，如果该对象表示了一个<strong>不实现</strong>任何接口的类，则返回一个<strong>数组长度为0</strong>的数组。运行结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">io.gitee.lazydog036.demo.Person</span><br><span class="line"><span class="keyword">package</span> io.gitee.lazydog036.demo</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h3 id="获取类的构造方法，并创建对象"><a href="#获取类的构造方法，并创建对象" class="headerlink" title="获取类的构造方法，并创建对象"></a>获取类的构造方法<strong>，</strong>并创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stu</span><span class="params">(<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习了&quot;</span>+day+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这一个私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">protectedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这个受保护的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;执行了这个默认权限方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了这个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConstructorFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获取构造方法</span></span><br><span class="line">    <span class="comment">//2.1获取类的所有构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[]cons=classObject.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; con : cons) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>+con.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2获取无参构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; con1=classObject.getConstructor();</span><br><span class="line">    System.out.println(con1.toString());</span><br><span class="line">    <span class="comment">//通过反射实例一个对象</span></span><br><span class="line">    <span class="comment">//类对象classObject通过获取到的Constructor使用newInstance实例一个对象</span></span><br><span class="line">    Person p1=(Person)con1.newInstance();  <span class="comment">//Constructor类中的newInstance</span></span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line">    <span class="comment">//2.2.1简便方法</span></span><br><span class="line">    Person p2=(Person)classObject.newInstance();<span class="comment">//Class类重写newInstance</span></span><br><span class="line">    System.out.println(p2.toString());</span><br><span class="line">    <span class="comment">//2.3获取有参构造</span></span><br><span class="line">    Constructor con2=classObject.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person zhangsan=(Person)con2.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">44</span>);</span><br><span class="line">    System.out.println(zhangsan.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getConstructor返回的是构造方法是一个Constructor对象，参数为构造方法声明的形参类型。使用带参构造方法对象创建实例时需要传递相应的参数，如代码中的第3个演示所示。运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造方法<span class="keyword">public</span> reflect.classObject.Person(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line">构造方法<span class="keyword">public</span> reflect.classObject.Person()</span><br><span class="line"><span class="keyword">public</span> reflect.classObject.Person()</span><br><span class="line">无参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">无参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">有参构造被调用了</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">44</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类中的方法，并调用方法"><a href="#获取类中的方法，并调用方法" class="headerlink" title="获取类中的方法，并调用方法"></a>获取类中的方法<strong>，</strong>并调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMethodFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------公开的方法--------&quot;</span>);</span><br><span class="line">    <span class="comment">//3.获取类对象中所有的方法</span></span><br><span class="line">    <span class="comment">//3.1获取类中所有公开的（public）方法</span></span><br><span class="line">    Method[] methods=classObject.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----非公开的方法-----&quot;</span>);</span><br><span class="line">    <span class="comment">//3.2获取public以外权限的方法</span></span><br><span class="line">    Method[] declaredMethods=classObject.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(declaredMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.3获取单个方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取单个方法-----&quot;</span>);</span><br><span class="line">    Method stuMethod=classObject.getMethod(<span class="string">&quot;stu&quot;</span>);</span><br><span class="line">    Person wangwu=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    stuMethod.invoke(wangwu);</span><br><span class="line">    Method stuMethod2=classObject.getMethod(<span class="string">&quot;stu&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    Person zhaoliu=<span class="keyword">new</span> Person(<span class="string">&quot;赵六&quot;</span>,<span class="number">33</span>);</span><br><span class="line">    stuMethod2.invoke(zhaoliu,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//3.4获取单个非公开方法 需要设置访问权限</span></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取单个非公开方法-----&quot;</span>);</span><br><span class="line">    Method privateMethod=classObject.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">    privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    privateMethod.invoke(wangwu);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;---获取静态方法---&quot;</span>);</span><br><span class="line">    Method staticMethod=classObject.getMethod(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">    staticMethod.invoke(<span class="keyword">null</span>);    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是一个Method类型的数组。控制台输出如下，为了便于观察结果，我把结果在这里分成了两部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reflect.classObject.Person.staticMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> reflect.classObject.Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">-----非公开的方法-----</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String reflect.classObject.Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> reflect.classObject.Person.privateMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reflect.classObject.Person.staticMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> reflect.classObject.Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> reflect.classObject.Person.protectedMethod()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reflect.classObject.Person.stu()</span><br><span class="line"><span class="keyword">void</span> reflect.classObject.Person.defaultMethod()</span><br><span class="line">-----获取单个方法-----</span><br><span class="line">有参构造被调用了</span><br><span class="line">王五正在学习</span><br><span class="line">有参构造被调用了</span><br><span class="line">学习了<span class="number">10</span>天</span><br><span class="line">-----获取单个非公开方法-----</span><br><span class="line">王五执行了这一个私有方法</span><br><span class="line">---获取静态方法---</span><br><span class="line">执行了这个静态方法</span><br><span class="line">有参构造被调用了</span><br><span class="line">zhangsan执行了这一个私有方法</span><br><span class="line">&#123;张三=<span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong> </p>
<ul>
<li><p>getMethods 包含Person类的方法，也包含了继承自Object的方法；但是在Person的方法中，没有非public方法，也就是说，该方法获取了<strong>类中和继承自父类的公开方法</strong>。</p>
</li>
<li><p>getDeclaredMethods 包括了所有公有的，私有的，受保护的和默认的方法。</p>
</li>
<li><p>获得方法后使用<code>invoke(Object obj,Object... args)</code>来调用相应的方法，第一个参数是调用这个方法的对象，第二个参数是调用方法的形参列表，没有就不写。</p>
</li>
<li><p>获取私有方法时需要使用<code>getDeclaredMethod</code>，并且需要设置访问权限无效才能调用，不然私有方法是不允许在其他类中调用的。</p>
</li>
<li><p>调用静态方法时，invoke中调用方法的对象这个参数写null。</p>
</li>
</ul>
<h3 id="实现一个可以调用任何对象方法的通用方法"><a href="#实现一个可以调用任何对象方法的通用方法" class="headerlink" title="实现一个可以调用任何对象方法的通用方法"></a>实现一个可以调用任何对象方法的通用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeAll</span><span class="params">(Object obj,String methodName,Class&lt;?&gt;[]types,Object... args)</span> <span class="keyword">throws</span>  NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class classObject=obj.getClass();</span><br><span class="line">    Method method;</span><br><span class="line">    Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method=classObject.getMethod(methodName,types);  <span class="comment">//判断这条语句是否发生异常</span></span><br><span class="line">        o=method.invoke(obj,args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;    <span class="comment">//如果是找不到方法异常，就执行以下语句</span></span><br><span class="line">        method=classObject.getDeclaredMethod(methodName,types);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        o=method.invoke(obj,args);</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取类中的属性"><a href="#获取类中的属性" class="headerlink" title="获取类中的属性"></a>获取类中的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFieldFromClassObject</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取所有公开属性----&quot;</span>);</span><br><span class="line">        Field[] fields1=classObject.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取所有私有属性----&quot;</span>);</span><br><span class="line">        Field[] fields2=classObject.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------获取单个属性----&quot;</span>);</span><br><span class="line">        Field nameField=classObject.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(nameField);</span><br><span class="line">        <span class="comment">//set get属性</span></span><br><span class="line">        Person chenqi=(Person)classObject.newInstance();</span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>); <span class="comment">//属性为私有的 设置公开权限</span></span><br><span class="line">        nameField.set(chenqi,<span class="string">&quot;周八&quot;</span>);</span><br><span class="line">        System.out.println(nameField.get(chenqi));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------获取所有属性----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> reflect.classObject.Person.count</span><br><span class="line">------获取所有私有属性----</span><br><span class="line"><span class="keyword">private</span> java.lang.String reflect.classObject.Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> reflect.classObject.Person.age</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> reflect.classObject.Person.count</span><br><span class="line">------获取单个属性----</span><br><span class="line"><span class="keyword">private</span> java.lang.String reflect.classObject.Person.name</span><br><span class="line">无参构造被调用了</span><br><span class="line">周八</span><br></pre></td></tr></table></figure>

<h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ul>
<li><p><strong>什么是设计模式</strong>？</p>
<p>一套被反复使用、多数人知晓的、经过分类编目、代码设计经验的总结。简单理解：特定问题的固定解决方法。</p>
</li>
<li><p><strong>好处</strong>？</p>
<p>使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性、重用性。</p>
</li>
<li><p>在Gof的《设计模式》书中描述了23中设计模式。本文只介绍几种常见的。</p>
</li>
</ul>
<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><ul>
<li>工厂模式主要负责对象创建的问题。</li>
<li>开发中有一个非常重要的原则“开闭原则”，对拓展开放、对修改关闭。</li>
<li>可通过反射进行工厂模式的设计，完成动态的对象创建。</li>
</ul>
<p>工厂模式一般有父类产品、子类产品、工厂和客户。以下演示工厂模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 父类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyBoard</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upan</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;u盘开始工作。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂类（负责对象创建）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Usb <span class="title">createUsb</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        Usb usb=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type==<span class="number">1</span>) &#123;<span class="comment">//鼠标</span></span><br><span class="line">            usb=<span class="keyword">new</span> Mouse();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;<span class="comment">//键盘</span></span><br><span class="line">            usb=<span class="keyword">new</span> KeyBoard();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type==<span class="number">3</span>) &#123;<span class="comment">//U盘</span></span><br><span class="line">            usb=<span class="keyword">new</span> Upan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> usb;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择产品：1.鼠标 2.键盘 3.U盘&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> type=in.nextInt();</span><br><span class="line">        Usb usb=UsbFactory.createUsb(type);</span><br><span class="line">        <span class="keyword">if</span>(usb!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购买成功。&quot;</span>);</span><br><span class="line">            usb.service();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请选择产品：1.鼠标 2.键盘 3.U盘</span><br><span class="line">2</span><br><span class="line">购买成功。</span><br><span class="line">键盘开始工作。。</span><br></pre></td></tr></table></figure>

<p>如果新增了一个产品，比如画板，那么需要新建一个子类产品类，然后在工厂类的if语句中加一个type，在new一个画板类。这么做就破坏了“开闭原则”，修改了源代码。接下来使用反射来优化这个程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂类（负责对象创建）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Usb <span class="title">createUsb</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Usb usb=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; class1=Class.forName(type);</span><br><span class="line">            usb=(Usb) class1.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> usb;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在工厂类利用反射创建新实例，传递过来的就需要一个完整的“包名.类名”。</p>
<p>但是客户还是输入数字来选择购买哪个产品，我们可以用Properties类来将<strong>客户的选择</strong>和“<strong>包名.类名</strong>”存储为键值对，并将它放在单独的配置文件中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##Usb.properties</span></span><br><span class="line"><span class="attr">1</span> = <span class="string">io.gitee.lazydog036.pattern.Mouse</span></span><br><span class="line"><span class="attr">2</span> = <span class="string">io.gitee.lazydog036.pattern.KeyBoard</span></span><br><span class="line"><span class="attr">3</span> = <span class="string">io.gitee.lazydog036.pattern.Upan</span></span><br></pre></td></tr></table></figure>

<p>那么就相应地修改客户代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请选择产品：1.鼠标 2.键盘 3.U盘 4.画板&quot;</span>);</span><br><span class="line">    Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String choice=in.next();</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//将文件读入到流中</span></span><br><span class="line">    FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\Usb.properties&quot;</span>);</span><br><span class="line">    <span class="comment">//从流中加载数据</span></span><br><span class="line">    properties.load(fileInputStream);</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    Usb usb=UsbFactory.createUsb(properties.getProperty(choice));</span><br><span class="line">    <span class="keyword">if</span>(usb!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购买成功。&quot;</span>);</span><br><span class="line">        usb.service();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;产品不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Properties这个集合和IO框架的知识默认你已经知晓了，我的其他博客里也有总结。</p>
<p>执行代码，程序正常运行。还是刚才那个问题，这时候新加了一个产品画板，我们之前需要修改工厂类的代码，而现在我们只需要在<code>Usb.properties</code>文件中新加一行代码：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">4</span> = <span class="string">io.gitee.lazydog036.pattern.DrawingBoard</span></span><br></pre></td></tr></table></figure>

<p>不用去修改源代码，再新添加一个DrawingBoard类，然后执行代码，运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请选择产品：<span class="number">1.</span>鼠标 <span class="number">2.</span>键盘 <span class="number">3.</span>U盘</span><br><span class="line"><span class="number">4</span></span><br><span class="line">购买成功。</span><br><span class="line">画板开始工作。</span><br></pre></td></tr></table></figure>

<p>输入4，正常输出结果，符合了“开闭原则”。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li><p>单例（Singleton）：约束类只能创建一个该类的对象。</p>
<p>要保证整个系统在运行过程中只能创建一个对象，有两种方式：</p>
<ul>
<li><strong>方式1</strong>：<strong>饿汉式</strong>（<strong>类加载时创建</strong>，<strong>天生线程安全</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例模式-饿汉  在类初始化即实例化instanc</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 instance=<span class="keyword">new</span> Singleton1();  <span class="comment">//1.创建一个等于该类的常量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">//设置无参构造方法为私有 让外部类无法new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance1</span><span class="params">()</span> </span>&#123;  <span class="comment">//提供公开的静态方法返回常量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="comment">//return instance;   不等于return new Singleton1();  常量值不会改变，new会改变对象地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饿汉-变种</span></span><br><span class="line">    <span class="comment">//静态的概念：在全类中只有一份，不因创建多个对象而产生多份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance1=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是单列-饿汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式单例一共三个步骤，很简单：</p>
<ol>
<li>首先创建一个该类的常量对象。</li>
<li>构造方法设置为私有，类外部不能创建该对象。</li>
<li>通过一个公开的方法，返回这个对象。</li>
</ol>
<p>通过一个多线程的代码来测试其是否是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="comment">//饿汉</span></span><br><span class="line">                    System.out.println(Singleton1.getInstance1().hashCode());</span><br><span class="line">                    Singleton1 instance=Singleton1.getInstance1();</span><br><span class="line">                    <span class="comment">//instance.show();</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">                    System.out.println(Singleton1.getInstance2().hashCode());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于java多线程默认你已经有所了解，我的其他博客中总结得也很详细。</p>
<p>运行结果如下，三个对象的hashcode一样，说明三个线程获取的是同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1307179676</span><br><span class="line">1307179676</span><br><span class="line">1307179676</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式2</strong>：<strong>懒汉式</strong>（<strong>使用时创建</strong>，<strong>线程不安全</strong>，<strong>需要加同步</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例模式-懒汉 （线程不安全） 调用getInstance方法时才创建对象，比饿汉式节省空间</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//设置无参构造方法为私有 让外部类无法new</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  <span class="comment">//线程不安全，下面提供三种方式保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比饿汉式先创建一个对象而言，懒汉式只有在调用方法时才创建对象，比饿汉式节省空间。</p>
<p>懒汉式单例同样是三个步骤：</p>
<ol>
<li>首先创造一个对象，赋值为null。</li>
<li>构造方法改成私有，类外部不能创建对象。</li>
<li>通过一个公开的方法，返回这个对象。</li>
</ol>
<p>通过一个多线程的代码来测试其是否是线程安全的，测试代码同上，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">727916939</span><br><span class="line">1612280362</span><br><span class="line">727916939</span><br></pre></td></tr></table></figure>

<p>hashcode不一样，说明在多线程中创建了不同的对象。怎么解决呢？很容易想到的是使用同步方法，或者是使用同步代码块，在方法名前加一个synchronized关键字，或者把需要同步的代码放进同步代码块中：</p>
<ul>
<li>保证线程安全的三种方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：在方法名中加synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程比较多的情况下，每个线程在使用实例时，如果都需要判断是否上锁的话执行效率会大打折扣；其实当第一个线程进入到同步代码块中时就说明实例已经创建了，后来的其他线程执行的只是返回语句，所以可以让后来的线程绕过同步代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二：加synchronized代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//括号里不能是instance，因为前面赋值是null，会出现空指针异常</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同步代码块中再加一个if判断，就可以让后来的线程直接执行下面的返回语句，而不必再去判断是否上锁。这样可以优化执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态的概念：在全类中只有一份，不因创建多个对象而产生多份</span></span><br><span class="line"><span class="comment">// 方式三：创建静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Holder.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它跟饿汉不同的是（很细微的差别）：饿汉是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。</p>
</li>
<li><p>总结单例模式的两种写法的优缺点：</p>
<p>饿汉式：</p>
<ul>
<li>优点：线程安全，类一加载就创建了实例。</li>
<li>缺点：实例对象就算不用也存在于内存中，生命周期长，浪费空间。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>优点：只有在调用getInstance才会实例化，生命周期短，节省空间</li>
<li>缺点：线程不安全。不过可以使用同步来保证线程互斥访问。</li>
</ul>
</li>
</ul>
<h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><h3 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h3><ul>
<li>枚举是一个引用类型，枚举是一个规定了取值范围的数据类型。反映到现实生活中，比如性别就是男和女，一个星期就是从周一到周日等。</li>
<li>枚举变量不能使用其他的数据，只能使用枚举中常量赋值，提高程序安全性。</li>
<li>定义枚举使用enum关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建枚举类</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">    MALE,FMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类中必须包含枚举常量，如上段中的MALE，多个枚举常量之间使用逗号隔开，如果类中只有枚举常量末尾可以不加分号。</p>
<p>枚举类中还可以包含属性，方法，<strong>私有</strong>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Gender &#123;</span><br><span class="line">    MALE,FMALE;    </span><br><span class="line">    public int a;</span><br><span class="line">    private String bString;</span><br><span class="line">    static HashMap&lt;Integer, String&gt; hashMap;</span><br><span class="line">    &#x2F;&#x2F;构造方法必须私有</span><br><span class="line">    private Gender() &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">    public static void show() &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示枚举类的使用，结果输出FMALE：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testGender</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法私有，不能使用new来创建</span></span><br><span class="line">        <span class="comment">//所有引用EnumDemo.FMALE的对象都是一个对象</span></span><br><span class="line">        EnumDemo enumTest1=EnumDemo.FMALE;</span><br><span class="line">        System.out.println(enumTest1);</span><br><span class="line">        EnumDemo enumTest2=EnumDemo.FMALE;</span><br><span class="line">        EnumDemo enumTest3=EnumDemo.FMALE;</span><br><span class="line">        System.out.println(enumTest1.hashCode());</span><br><span class="line">        System.out.println(enumTest2.hashCode());</span><br><span class="line">        System.out.println(enumTest3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FMALE</span><br><span class="line">1908153060</span><br><span class="line">1908153060</span><br><span class="line">1908153060</span><br></pre></td></tr></table></figure>



<h3 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h3><p>在创建枚举类的时候，注意到这个类和以前接触过的类不太一样，枚举常量没有任何修饰关键字，那它是一个怎么的存在？</p>
<p>找到编译生成的<code>Gender.class</code>文件，借助Xjad小工具将其反编译成java代码，这个小工具在百度上可以找到，得到以下的反编译结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Gender extends Enum</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static final Gender MALE;</span><br><span class="line">    public static final Gender FMALE;</span><br><span class="line">    private static final Gender ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    private Gender(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Gender[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Gender agender[];</span><br><span class="line">        int i;</span><br><span class="line">        Gender agender1[];</span><br><span class="line">        System.array(agender &#x3D; ENUM$VALUES, 0, agender1 &#x3D; new Gender[i &#x3D; agender.length], 0, i);</span><br><span class="line">        return agender1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Gender valueOf(String s)</span><br><span class="line">    &#123;</span><br><span class="line">        return (Gender)Enum.valueOf(io&#x2F;gitee&#x2F;lazydog036&#x2F;meiJu&#x2F;Gender, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        MALE &#x3D; new Gender(&quot;MALE&quot;, 0);</span><br><span class="line">        FMALE &#x3D; new Gender(&quot;FMALE&quot;, 1);</span><br><span class="line">        ENUM$VALUES &#x3D; (new Gender[] &#123;</span><br><span class="line">            MALE, FMALE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Gender类变成了final修饰的终止类，意味着这个类没有子类，而且它继承了Enum抽象类。Enum是jdk1.5之后新增的一个类，实际上我们所创建的枚举类都隐式地继承了Enum类。而FMALE和MALE都变成了用该类所创建的静态的终止的属性，尽管我们只写了常量名。</p>
<p>还可以看到java编译时还添加了一个带参的私有构造方法和两个静态方法。还有一个静态代码块，在其中对这些静态常量进行了赋值。</p>
<p>所以枚举的本质就是：</p>
<ul>
<li>一个终止类，并继承Enum抽象类。</li>
<li>枚举常量是当前类型的静态常量。</li>
</ul>
<h3 id="枚举配合switch"><a href="#枚举配合switch" class="headerlink" title="枚举配合switch"></a>枚举配合switch</h3><p>在switch语句中，括号里的内容也可以是枚举类型的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Gender gender&#x3D;Gender.FMALE;</span><br><span class="line">    switch(gender) &#123;</span><br><span class="line">        case FMALE:</span><br><span class="line">            System.out.println(&quot;女性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case MALE:</span><br><span class="line">            System.out.println(&quot;男性&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case后面直接写枚举常量。结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">女性</span><br></pre></td></tr></table></figure>

<h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li><p>注解（Annotation）是代码里的特殊标记，程序可以读取注解，一般用于替代配置文件。</p>
</li>
<li><p>开发人员可以通过注解告诉类如何运行。</p>
<p>在JAVA技术里注解的典型应用是：可以通过反射技术得到类里面的注解，以决定怎么去运行类。</p>
</li>
<li><p>常见注解：<code>@Override</code>表示重写父类方法，<code>@Deprecated</code>表示方法已过时。</p>
</li>
<li><p>定义注解使用<code>@interface</code>关键字，注解中只能包含属性。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建注解类型</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    &#x2F;&#x2F;属性，无默认值</span><br><span class="line">    String nameString();</span><br><span class="line">    &#x2F;&#x2F;有默认值</span><br><span class="line">    int age() default 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解类型的属性与其他类有所不同，它需要在属性名后面加一个括号，但不叫方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注解的使用</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @MyAnnotation(nameString &#x3D; &quot;张三&quot;)</span><br><span class="line">    public void show() &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解时直接添加到方法上面，也可以添加到类上面；如果属性没有默认值的话，需要在注解名括号里写上。</p>
<ul>
<li><p>注解基本类型</p>
<ul>
<li>String类型</li>
<li>基本数据类型</li>
<li>Class类型</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>以上类型的一维数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    &#x2F;&#x2F;String类型</span><br><span class="line">    String nameString();</span><br><span class="line">    &#x2F;&#x2F;基本类型</span><br><span class="line">    int age() default 18;</span><br><span class="line">    &#x2F;&#x2F;Class类型</span><br><span class="line">    Class&lt;?&gt; class1();</span><br><span class="line">    &#x2F;&#x2F;枚举类型</span><br><span class="line">    Gender gender();</span><br><span class="line">    &#x2F;&#x2F;不允许</span><br><span class="line">    &#x2F;&#x2F;ArrayList&lt;String&gt; arrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><p>同上使用Xjad工具反编译生成的<code>MyAnnotation.class</code>文件，得到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MyAnnotation</span><br><span class="line">    extends Annotation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public abstract String nameString();</span><br><span class="line"></span><br><span class="line">    public abstract int age();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到注解类已经变成了一个接口，而在注解类中定义的两个属性也变成了两个抽象方法。</p>
<p>所以注解的本质其实就是<strong>接口</strong>。</p>
<h3 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解类</span></span><br><span class="line"><span class="meta">@Retention(value=RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PersionInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="function">String <span class="title">hobby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHobby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobby</span><span class="params">(String hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobby=hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name, <span class="keyword">int</span> age, String hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.hobby=hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PersionInfo(name=&quot;张三&quot;,age=20,hobby=&quot;足球&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name,<span class="keyword">int</span> age,String hobby)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot; 年龄：&quot;</span>+age+<span class="string">&quot; 爱好：&quot;</span>+hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPersionInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//获取类对象</span></span><br><span class="line">        Class&lt;?&gt; classObject=Class.forName(<span class="string">&quot;reflect.singletonDesignPattern.annotationDemo.Persion&quot;</span>);</span><br><span class="line">        <span class="comment">//获取类方法</span></span><br><span class="line">        Method method=classObject.getMethod(<span class="string">&quot;show&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class, String.class&#125;);</span><br><span class="line">        Constructor constructor=classObject.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class, String.class&#125;);</span><br><span class="line">        <span class="comment">//获取方法注解</span></span><br><span class="line">        PersionInfo annotation=method.getAnnotation(PersionInfo.class);</span><br><span class="line">        <span class="comment">//打印方法注解</span></span><br><span class="line">        System.out.println(annotation.name()+annotation.age()+annotation.hobby());</span><br><span class="line">        <span class="comment">//通过类对象创建实例p1</span></span><br><span class="line">        Persion p1=(Persion) classObject.newInstance();</span><br><span class="line">        <span class="comment">//执行方法(参数1=执行者)</span></span><br><span class="line">        method.invoke(p1,annotation.name(),annotation.age(),annotation.hobby());</span><br><span class="line">        <span class="comment">//通过有参构造方法实例对象</span></span><br><span class="line">        Persion p2=(Persion) constructor.newInstance(annotation.name(), annotation.age(), annotation.hobby());</span><br><span class="line">        System.out.println(p2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，看是否打印成功，得到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at io.gitee.lazydog036.annotation.testPersonInfo.main(testPersonInfo.java:14)</span><br></pre></td></tr></table></figure>

<p>发现报了一个空指针异常的错误，这个错误的原因就在于personInfo的值为null。第3步不是已经赋值了吗，为什么还是null？这是因为这个注解信息在运行的时候就没有了，PersonInfo注释类的类名上有一个默认的<strong>元注解</strong><code>@RetentionPolicy.CLASS</code>，使它只作用于编译后的class文件中。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解：用来描述注解的注解。</p>
<p><code>@Retention</code>：用于指定注解可以保留的域。</p>
<ul>
<li><code>@RetentionPolicy.CLASS</code>：注解记录在class文件中，运行Java程序时，JVM不会保留。这是注解的<strong>默认值</strong>。</li>
<li><code>@RetentionPolicy.RUNTIME</code>：注解记录在class文件中，运行Java程序中，JVM会保留注解，程序可以通过反射获取该注释。</li>
<li><code>@RetentionPolicy.SOURCE</code>：编译时直接丢弃这种策略的注释。</li>
</ul>
<p>解决上一节的问题，只需要在注解类上加一个元注解即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(value &#x3D; RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PersonInfo &#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意括号里的属性为value。然后再运行一下程序，控制台成功打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tang  21  足球</span><br></pre></td></tr></table></figure>

<p>我们也可以将注解里的属性值传入show方法中并进行调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5.调用方法</span><br><span class="line">Person person&#x3D;(Person) class1.newInstance();</span><br><span class="line">method.invoke(person, personInfo.name(),personInfo.age(),personInfo.hobby());</span><br></pre></td></tr></table></figure>

<p>输出结果如下，方法成功调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名：tang 年龄：21 爱好：足球</span><br></pre></td></tr></table></figure>

<hr>
<p><code>@Target</code>：元注解，指定注解用于修饰类的哪个成员。</p>
<p>上文演示的代码中PersonInfo注解是放在show方法上的，也可以说修饰了这个方法。在不加这个元注解的时候，注解可以修饰在任何地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(value &#x3D; RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; ElementType.TYPE &#125;)</span><br><span class="line">public @interface PersonInfo &#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Target</code>有一个枚举数组ElementType类型的value属性，在赋值的时候需要使用大括号括起来。这个枚举数组中有不同的枚举常量，如上的元注解表示该注解只能放在类上，比如放在show方法上编译器就会报错；如果枚举常量为METHOD，就表示该注解只能放在方法上。</p>
<p>ElementType枚举类型的源码如下（JDK1.8）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    &#x2F;** Class, interface (including annotation type), or enum declaration *&#x2F;</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Field declaration (includes enum constants) *&#x2F;</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Method declaration *&#x2F;</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Formal parameter declaration *&#x2F;</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Constructor declaration *&#x2F;</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Local variable declaration *&#x2F;</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Annotation type declaration *&#x2F;</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;** Package declaration *&#x2F;</span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据程序可以自己选择枚举常量，也可以不写这个元注解，就表示注解可以加在任何地方。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-集合框架</title>
    <url>/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul>
<li><p><strong>概念:</strong> 对象的容器，实现了对象常用的操作，类似与数组的功能</p>
</li>
<li><p><strong>集合与数组的区别</strong></p>
<ol>
<li>数组的长度是固定的，集合长度不固定</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>
</ol>
</li>
</ul>
<span id="more"></span>
<h2 id="Collection体系"><a href="#Collection体系" class="headerlink" title="Collection体系"></a>Collection体系</h2><ul>
<li>Collection:  <ul>
<li>List:</li>
<li>ArrayList  <ul>
<li>LinkedList  </li>
<li>Vector  </li>
</ul>
</li>
<li>Set:<ul>
<li>HashSet  </li>
<li>SortedSet<ul>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><p><strong>特点：</strong> 代表一组任意类型的对象、无序、无下标、元素不能重复</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>boolean add(Object obj) //添加一个对象。</li>
<li>boolean addAll(Collection c) //将一个集合中的所有对象添加到此集合</li>
<li>void clear() //清空此集合中的所有对象</li>
<li>boolean contains(Object o)//检查此集合中是否包含o对象</li>
<li>boolean equals(Object o)//比较此集合是否与指定对象相等</li>
<li>boolean isEmpty()//判断此集合是否为空</li>
<li>boolean remove(Object o)//在此集合 中移除o对象</li>
<li>int size()//返回此集合中的元素个数</li>
<li>Object[] toArray() //将此集合转换成数组。</li>
</ul>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> conllection.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Collection接口使用一</span></span><br><span class="line"><span class="comment">* 1.添加元素</span></span><br><span class="line"><span class="comment">* 2.删除元素</span></span><br><span class="line"><span class="comment">* 3.遍历元素</span></span><br><span class="line"><span class="comment">* 4.判断</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        Collection collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        collection.remove(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//3.遍历元素</span></span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj:collection) &#123;</span><br><span class="line">            System.out.println(obj.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用迭代器</span></span><br><span class="line">        <span class="comment">//hasnext();判断是否有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除下一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        Iterator iterator = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//删除操作</span></span><br><span class="line">            <span class="comment">//collection.remove(s);引发错误：并发修改异常</span></span><br><span class="line">            <span class="comment">//iterator.remove();应使用迭代器的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;被迭代器删除后 集合没有元素了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;橘子&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(collection.isEmpty());<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><ul>
<li><strong>特点：</strong> 有序、有下标、元素可以重复</li>
<li><strong>常用方法：</strong><ul>
<li>void add(int index,Object o) //在index位置插入对象o。</li>
<li>boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</li>
<li>Object get(int index) //返回集合中指定位置的元素。</li>
<li>List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。</li>
</ul>
</li>
</ul>
<h3 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a>List实现类</h3><h4 id="ArrayList【重点】"><a href="#ArrayList【重点】" class="headerlink" title="ArrayList【重点】"></a>ArrayList【重点】</h4><ul>
<li>数组结构实现，查询快，增删慢；</li>
<li>JDK1.2版本开始使用，运行效率快，线程不安全(处理方法：迭代器-快速失败)。</li>
<li>有下标，允许重复</li>
</ul>
<p>代码实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        Stu s1=<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Stu s2=<span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Stu s3=<span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        arrayList.add(s1);</span><br><span class="line">        arrayList.add(s2);</span><br><span class="line">        arrayList.add(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+arrayList.size());</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//arrayList.remove(s1);</span></span><br><span class="line">        <span class="comment">//arrayList.remove(new Stu(&quot;张三&quot;, 21));</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;删除后元素个数：&quot;+arrayList.size());</span></span><br><span class="line">        <span class="comment">//注：如何删除两个不同的对象 ，见下面代码块</span></span><br><span class="line">        <span class="comment">//3.遍历元素</span></span><br><span class="line">        <span class="comment">//3.1使用迭代器</span></span><br><span class="line">        Iterator iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用列表迭代器</span></span><br><span class="line">        ListIterator listIterator=arrayList.listIterator();</span><br><span class="line">        <span class="comment">//从前往后遍历</span></span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(listIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(arrayList.isEmpty());<span class="comment">//是否为空</span></span><br><span class="line">        System.out.println(arrayList.contains(s1));<span class="comment">//是否存在</span></span><br><span class="line">        <span class="comment">//System.out.println(arrayList.contains(new Stu(&quot;张三&quot;, 21)));</span></span><br><span class="line">        <span class="comment">//注：与上文相同的问题。</span></span><br><span class="line">        <span class="comment">//5.查找</span></span><br><span class="line">        System.out.println(arrayList.indexOf(s1)));<span class="comment">//返回下标 不存在返回-1</span></span><br><span class="line">        <span class="comment">//System.out.println(arrayList.indexOf(new Stu(&quot;张三&quot;, 21)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实体Stu类中 重写equals()方法 比较是否同一对象、是否为空、是否同类型、属性是否相等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.是否为同一对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>==obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (obj==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.判断是否是Student类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Stu) &#123;</span><br><span class="line">        Stu stu=(Stu) obj;</span><br><span class="line">        <span class="comment">//4.比较属性</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(stu.getName())&amp;&amp;<span class="keyword">this</span>.age==stu.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不满足，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArraryList源码解析"><a href="#ArraryList源码解析" class="headerlink" title="ArraryList源码解析"></a>ArraryList源码解析</h4><h5 id="详解add方法原理"><a href="#详解add方法原理" class="headerlink" title="详解add方法原理"></a>详解add方法原理</h5><p>属性：<br>  DEFAULT_CAPACITY = 10    //默认容量（无参时用到，后面按1.5倍扩容）<br>  DEFAULTCAPACITY_EMPTY_ELEMENTDATA    //默认空数据数组(无参时用到)<br>  EMPTY_ELEMENTDATA    //空数组(有参 参数为0时用到)<br>  elementData    //存放数据的数组<br>  size   //原数组大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//第一次add时 size=0    //第十一次 size=10</span></span><br><span class="line">    elementData[size++] = e;  <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;   <span class="comment">//minCapacity=1      minCapacity=11</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  <span class="comment">//判断是否使用的是无参构造</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);   <span class="comment">//成立返回DEFAULT_CAPACITY=10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">//minCapacity=10  minCapacity=11</span></span><br><span class="line">    modCount++;                                     <span class="comment">//见下面Iterator快速失败原理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)       <span class="comment">//elementData.length=0   elementData.length=10</span></span><br><span class="line">        grow(minCapacity);                          <span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length; </span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">//newCapacity=0    newCapacity=15  扩容1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;                       <span class="comment">//newCapacity=10</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.Of(elementData, newCapacity); <span class="comment">//元素数据 容量为10的新数组  容量为15的新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayList不支持并发抛出的异常-java-util-ConcurrentModificationException"><a href="#ArrayList不支持并发抛出的异常-java-util-ConcurrentModificationException" class="headerlink" title="ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException"></a><div id="failfast">ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException</div></h5><p>Iterator快速失败原理 迭代器中为什么不能使用列表的操作方法</p>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="number">1</span>);</span><br><span class="line">    arrayList.add(<span class="number">2</span>);</span><br><span class="line">    arrayList.add(<span class="number">3</span>);</span><br><span class="line">    Iterator iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="keyword">int</span> num= (<span class="keyword">int</span>) iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">2</span>)&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arrayList.remove(1);  //会抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码解析</p>
<p>属性：<br>    expectedModCount  //预期操作次数<br>    modCount  //操作次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractList</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArraryList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;  </span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)               <span class="comment">//再次判断中途是否操作了列表</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)                   <span class="comment">//ArrayList操作函数中都写入了 modCount++  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iterator和ListIterator"><a href="#Iterator和ListIterator" class="headerlink" title="Iterator和ListIterator"></a>Iterator和ListIterator</h4><h5 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h5><p>我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p>
<ol>
<li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
</ol>
<p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p>
<h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。</p>
<ul>
<li><p>常用方法：</p>
<ul>
<li>forEachRemaining(Consumer&lt;? super E&gt; action)：为每个剩余元素执行给定的操作,直到所有的元素都已经被处理或行动将抛出一个异常</li>
<li>hasNext()：如果迭代器中还有元素，则返回true。</li>
<li>next()：返回迭代器中的下一个元素</li>
<li>remove()：删除迭代器新返回的元素。</li>
</ul>
</li>
<li><p>注意：</p>
<ol>
<li>Iterator只能单向移动。</li>
<li>Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。详见<a href="#failfast">ArrayList不支持并发抛出的异常 java.util.ConcurrentModificationException</a></li>
</ol>
</li>
</ul>
<p><a href="#failfast">Iterator代码实例</a></p>
<h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p>
<ul>
<li><p>ListIterator特点:</p>
<ol>
<li>双向移动（向前/向后遍历）.</li>
<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.</li>
<li>可以使用set()方法替换它访问过的最后一个元素.</li>
<li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</li>
</ol>
</li>
<li><p>注意：使用反向列表迭代前必须使用正向列表迭代</p>
</li>
</ul>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI0MTM5Ny9hcnRpY2xlL2RldGFpbHMvNzk2ODc3ODk=">https://blog.csdn.net/weixin_39241397/article/details/79687789<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>问题</strong><br>由于一次大意 在反向列表迭代中使用了nextIndex获取下标，发现下标不对，其中原因如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Stu s1 = <span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">Stu s2 = <span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Stu s3 = <span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">linkedList.add(s1);</span><br><span class="line">linkedList.add(s2);</span><br><span class="line">linkedList.add(s3);</span><br><span class="line"></span><br><span class="line">ListIterator listIterator = linkedList.listIterator();</span><br><span class="line"><span class="comment">//使用正向列表迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---------使用列表迭代器---------&quot;</span>);</span><br><span class="line">ListIterator listIterator = linkedList.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//因为还位执行.next()，游标指向在列表后(并没有指向第一个元素)， 所以当前下标-1 ，nextIndex为0，previousIndex为-1</span></span><br><span class="line">    <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">    <span class="comment">//在正向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的开头，则返回-1）</span></span><br><span class="line">    <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">    <span class="comment">//每次执行next()后 游标向前移一位  下标递减</span></span><br><span class="line">    Stu stu = (Stu) listIterator.next();</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.5 使用反向列表迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---------使用反向列表迭代器---------&quot;</span>);</span><br><span class="line">LinkedList stuLinkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">ArrayList stuArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">    <span class="comment">//因为还位执行previous()，光标指向在列表前(并没有指向最后一个元素)， 所以当前下标3 ，previousIndex为2，nextIndex为3(列表)</span></span><br><span class="line">    <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">    <span class="comment">//在反向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的末尾，则返回列表大小）</span></span><br><span class="line">    <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">    <span class="comment">//每次执行previous()后 游标向后移一位  下标递减</span></span><br><span class="line">    Stu stu = (Stu) listIterator.previous();</span><br><span class="line">    <span class="comment">//存进新的集合 完成集合反向排序</span></span><br><span class="line">    stuLinkedList.add(stu);</span><br><span class="line">    stuArrayList.add(stu);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">    System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li>数组结构实现，查询快、增删慢；</li>
<li>JDK1.0版本，运行效率慢、线程安全。</li>
<li>有下标，允许重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector的演示使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *1.添加数据</span></span><br><span class="line"><span class="comment"> *2.删除数据</span></span><br><span class="line"><span class="comment"> *3.遍历</span></span><br><span class="line"><span class="comment"> *4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Vector vector=<span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="comment">//1.添加数据</span></span><br><span class="line">    vector.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    vector.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    vector.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素个数：&quot;</span>+vector.size());</span><br><span class="line">    <span class="comment">//2.删除数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * vector.remove(0);</span></span><br><span class="line"><span class="comment">        * vector.remove(&quot;张三&quot;);</span></span><br><span class="line"><span class="comment">        * vector.clear();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//使用枚举器 于迭代器功能相同</span></span><br><span class="line">    Enumeration enumeration=vector.elements();</span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">        String s = (String) enumeration.nextElement();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(vector.isEmpty());</span><br><span class="line">    System.out.println(vector.contains(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="comment">//5. Vector其他方法</span></span><br><span class="line">    <span class="comment">//firstElement()  lastElement()  ElementAt();</span></span><br><span class="line">    System.out.println(vector.elementAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>链表结构实现，增删快，查询慢。</li>
<li>无下标，允许重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stu s1 = <span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    Stu s2 = <span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Stu s3 = <span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//1.添加元素</span></span><br><span class="line">    linkedList.add(s1);</span><br><span class="line">    linkedList.add(s2);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素个数：&quot;</span> + linkedList.size());</span><br><span class="line">    System.out.println(linkedList.toString());</span><br><span class="line">    <span class="comment">//2.删除元素</span></span><br><span class="line">    <span class="comment">//linkedList.remove(1);</span></span><br><span class="line">    <span class="comment">//linkedList.remove(new Stu(&quot;张三&quot;, 21));</span></span><br><span class="line">    <span class="comment">//System.out.println(linkedList.toString());</span></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//3.1 使用for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用for---------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); ++i) &#123;</span><br><span class="line">        System.out.println(linkedList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 使用增强for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用foreach---------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object object : linkedList) &#123;</span><br><span class="line">        Stu student = (Stu) object;</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.3 使用迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用迭代器---------&quot;</span>);</span><br><span class="line">    Iterator iterator = linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) iterator.next();</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.4 使用列表迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用正向列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator = linkedList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//因为还位执行.next()，游标指向在列表后(并没有指向第一个元素)， 所以当前下标-1 ，nextIndex为0，previousIndex为-1</span></span><br><span class="line">        <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">        <span class="comment">//在正向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的开头，则返回-1）</span></span><br><span class="line">        <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">        <span class="comment">//每次执行next()后 游标向前移一位  下标递减</span></span><br><span class="line">        Stu stu = (Stu) listIterator.next();</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.5 使用反向列表迭代器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用反向列表迭代器---------&quot;</span>);</span><br><span class="line">    LinkedList stuLinkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    ArrayList stuArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">        <span class="comment">//因为还位执行previous()，光标指向在列表前(并没有指向最后一个元素)， 所以当前下标3 ，previousIndex为2，nextIndex为3(列表)</span></span><br><span class="line">        <span class="keyword">int</span> Pindex=listIterator.previousIndex();</span><br><span class="line">        <span class="comment">//在反向遍历中使用previousIndex() jdk1.8中提到（如果列表迭代器位于列表的末尾，则返回列表大小）</span></span><br><span class="line">        <span class="keyword">int</span> Nindex=listIterator.nextIndex();</span><br><span class="line">        <span class="comment">//每次执行previous()后 游标向后移一位  下标递减</span></span><br><span class="line">        Stu stu = (Stu) listIterator.previous();</span><br><span class="line">        <span class="comment">//存进新的集合 完成集合反向排序</span></span><br><span class="line">        stuLinkedList.add(stu);</span><br><span class="line">        stuArrayList.add(stu);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;previous元素下标为：&quot;</span>+Pindex);</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;next元素下标为：&quot;</span>+Nindex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//4. 判断</span></span><br><span class="line">    System.out.println(linkedList.contains(s1));</span><br><span class="line">    System.out.println(linkedList.isEmpty());</span><br><span class="line">    System.out.println(linkedList.indexOf(s3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合反向排序 &amp; Test LinkedList &amp; ArraryList</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------LinkedList使用列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator2 = stuLinkedList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator2.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) listIterator2.next();</span><br><span class="line">        <span class="keyword">int</span> index=listIterator2.nextIndex()-<span class="number">1</span>;</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;---------ArrayList使用列表迭代器---------&quot;</span>);</span><br><span class="line">    ListIterator listIterator3 = stuArrayList.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator3.hasNext()) &#123;</span><br><span class="line">        Stu stu = (Stu) listIterator3.next();</span><br><span class="line">        <span class="keyword">int</span> index=listIterator3.nextIndex()-<span class="number">1</span>;</span><br><span class="line">        System.out.println(stu.toString()+<span class="string">&quot;元素下标为：&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h4><p>属性：<br>    size //列表大小<br>    Node<E> first  //第一个节点<br>    Node<E> last   //最后一个节点<br>        prev   //节点指针  指向上一个节点<br>        element  //节点元素数据<br>        next  //节点指针  指向下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;          <span class="comment">//第一次add    第二次</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;   <span class="comment">//将最后一个节点赋值给l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);  <span class="comment">//新建一个节点 上一个节点=最后一个节点，下一个节点=null</span></span><br><span class="line">    last = newNode;     <span class="comment">//最后一个节点=新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)            <span class="comment">//成立         不成立</span></span><br><span class="line">        first = newNode;  <span class="comment">//第一个节点=新的节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;     <span class="comment">//上一次最后节点的下一个节点=新的节点</span></span><br><span class="line">    size++;            <span class="comment">//列表大小+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/QQ%E6%88%AA%E5%9B%BE20210305181826.jpg" class="">

<h4 id="ArraryList和LinkedList区别"><a href="#ArraryList和LinkedList区别" class="headerlink" title="ArraryList和LinkedList区别"></a>ArraryList和LinkedList区别</h4><ul>
<li>ArrayList：必须开辟连续空间，查询快，增删慢。</li>
<li>LinkedList：无需开辟连续空间，查询慢，增删快。</li>
</ul>
<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/febe000331d03d391696.png" class="">

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><strong>概述:</strong><ul>
<li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。  </li>
<li>常见形式有泛型类、泛型接口、泛型方法。</li>
<li>语法：<ul>
<li>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</li>
</ul>
</li>
</ul>
</li>
<li><strong>好处：</strong><ul>
<li>提高代码的重用性</li>
<li>防止类型转换异常，提高代码安全性</li>
</ul>
</li>
</ul>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 泛型类</span></span><br><span class="line"><span class="comment">* 语法：类名&lt;T&gt;</span></span><br><span class="line"><span class="comment">* T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//1.创建泛型变量</span></span><br><span class="line">  <span class="comment">//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span></span><br><span class="line">  T t;</span><br><span class="line">  <span class="comment">//2.泛型作为方法的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//泛型作为方法的返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 泛型接口</span></span><br><span class="line"><span class="comment">  * 语法：接口名&lt;T&gt;</span></span><br><span class="line"><span class="comment">  * 注意：不能创建泛型静态常量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//创建常量</span></span><br><span class="line">    String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function">T <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">*实现接口时确定泛型类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实现接口时不确定泛型类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericInterfaceImpl2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">show2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1.泛型只能使用引用类型</span></span><br><span class="line"><span class="comment"> * 2.不同泛型类型的对象不能相互赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> MyGeneric&lt;String&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;泛型作为参数&quot;</span>;</span><br><span class="line">        myGeneric1.show(<span class="string">&quot;这是泛型类&quot;</span>);</span><br><span class="line">        String t = myGeneric1.getT();</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*MyGeneric&lt;Integer&gt; myGeneric2=new MyGeneric&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">        myGeneric2.t=10;</span></span><br><span class="line"><span class="comment">        myGeneric2.show(20);</span></span><br><span class="line"><span class="comment">        Integer integer=myGeneric2.getT();</span></span><br><span class="line"><span class="comment">        System.out.println(integer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyGenericInterfaceImpl myGenericInterface=<span class="keyword">new</span> MyGenericInterfaceImpl();</span><br><span class="line">        myGenericInterface.show(<span class="string">&quot;这是泛型借口&quot;</span>);</span><br><span class="line">        MyGenericInterfaceImpl2&lt;String&gt; myGenericInterface2=<span class="keyword">new</span> MyGenericInterfaceImpl2();</span><br><span class="line">        myGenericInterface2.show(<span class="string">&quot;这是泛型借口2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyGenericMethod myGenericMethod = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        myGenericMethod.show(<span class="string">&quot;这是泛型方法 泛型作为参数&quot;</span>);</span><br><span class="line">        System.out.println(myGenericMethod.show2(<span class="string">&quot;这是泛型方法 泛型作为返回值&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h4><ul>
<li><p><strong>概念：</strong> 参数化类型，类型安全的集合，强制集合元素的类型必须一直。</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>编译时即可检查，而非运行时抛出异常。</li>
<li>访问时，不必类型转换（拆箱）。</li>
<li>不同泛型之间引用不能相互赋值，泛型不存在多态。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>特点：无序，无下标，元素不可重复</li>
<li>方法：全部继承于Collection中的方法</li>
</ul>
<p>代码实列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">//1.添加数据</span></span><br><span class="line">    set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;数据个数：&quot;</span>+set.size());</span><br><span class="line">    System.out.println(set.toString());<span class="comment">//无序输出</span></span><br><span class="line">    <span class="comment">//2.删除数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * set.remove(&quot;tang&quot;); System.out.println(set.toString());</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//3.遍历【重点】</span></span><br><span class="line">    <span class="comment">//3.1 使用增强for</span></span><br><span class="line">    <span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 使用迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(set.contains(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    System.out.println(set.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set实现类"><a href="#Set实现类" class="headerlink" title="Set实现类"></a>Set实现类</h3><h4 id="HashSet【重点】"><a href="#HashSet【重点】" class="headerlink" title="HashSet【重点】"></a>HashSet【重点】</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Person&gt; hashSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Person p3=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">//1.添加元素</span></span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    <span class="comment">//重复，添加失败</span></span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    <span class="comment">//直接new一个相同属性的对象，依然会被添加，不难理解。</span></span><br><span class="line">    <span class="comment">//假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">    hashSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    System.out.println(hashSet.toString());</span><br><span class="line">    <span class="comment">//2.删除元素</span></span><br><span class="line">    <span class="comment">//hashSet.remove(p2);</span></span><br><span class="line">    <span class="comment">//3.遍历</span></span><br><span class="line">    <span class="comment">//3.1 增强for</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : hashSet) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 迭代器</span></span><br><span class="line">    Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断</span></span><br><span class="line">    System.out.println(hashSet.isEmpty());</span><br><span class="line">    <span class="comment">//直接new一个相同属性的对象结果输出是false，不难理解。</span></span><br><span class="line">    <span class="comment">//注：假如相同属性便认为是同一个对象，该怎么做？</span></span><br><span class="line">    System.out.println(hashSet.contains(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注：hashSet存储过程：<ol>
<li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li>
<li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li>
</ol>
</li>
</ul>
<p>注： 重写hashCode和equals方法</p>
<p>idea 快捷键alt+insert</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hashCode方法里为什么要使用31这个数字大概有两个原因：<ol>
<li>31是一个质数，这样的数字在计算时可以尽量减少散列冲突。</li>
<li>可以提高执行效率，因为31*i=(i&lt;&lt;5)-i，31乘以一个数可以转换成移位操作，这样能快一点；但是也有网上一些人对这两点提出质疑</li>
</ol>
</li>
</ul>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li>基于排序顺序实现不重复。</li>
<li>实现了SortedSet接口，对集合元素自动排序。</li>
<li>元素对象的类型必须实现Comparable接口，指定排序规则。</li>
<li>通过CompareTo方法确定是否为重复元素。</li>
</ul>
<img src="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/QQ%E6%88%AA%E5%9B%BE20210305233210.jpg" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用TreeSet保存数据</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> * 要求：元素类必须实现Comparable接口，compareTo方法返回0，认为是重复元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> TreeSet&lt;Person&gt;();</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p3=<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//注：直接添加会报类型转换错误，需要实现Comparable接口</span></span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        persons.remove(p1);</span><br><span class="line">        persons.remove(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">//3.遍历（略）</span></span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(persons.contains(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类实现Comparable接口，重写compareTo方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//1.先按姓名比</span></span><br><span class="line">    <span class="comment">//2.再按年龄比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line">        <span class="keyword">int</span> n2=<span class="keyword">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Comparator 定制比较（比较器）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet&lt;Person&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;  <span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">                <span class="keyword">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;d&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;e&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Person p5 = <span class="keyword">new</span> Person(<span class="string">&quot;c&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        treeSet.add(p1);</span><br><span class="line">        treeSet.add(p2);</span><br><span class="line">        treeSet.add(p3);</span><br><span class="line">        treeSet.add(p4);</span><br><span class="line">        treeSet.add(p5);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小作业 要求按字符串长度比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 要求：按字符串长度比较</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=o1.length()-o2.length();     <span class="comment">//大于0排右边，小于0排左边</span></span><br><span class="line">                <span class="keyword">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;  <span class="comment">//匿名内部类</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;hjba&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        treeSet.add(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h3><ul>
<li><p><strong>特点：</strong> 存储一对数据（Key-Value），无序、无下标，键不可重复，值可以重复。</p>
</li>
<li><p><strong>方法：</strong></p>
</li>
<li><p>V put(K key,V value)//将对象存入到集合中，关联键值。key重复则覆盖原值。</p>
</li>
<li><p>Object get(Object key)//根据键获取相应的值。</p>
</li>
<li><p>Set<K> keySet()//返回所有的key</p>
</li>
<li><p>Collection<V> values()//返回包含所有值的Collection集合。</p>
</li>
<li><p>Set&lt;Map.Entry&lt;K,V&gt; entrySet()//键值匹配的set集合</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//1添加</span></span><br><span class="line">        map.put(<span class="string">&quot;cn&quot;</span>,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;uk&quot;</span>,<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;usa&quot;</span>,<span class="string">&quot;美国&quot;</span>);</span><br><span class="line">        <span class="comment">//map.put(&quot;cn&quot;,&quot;china&quot;);  //key不允许重复 --- 替换</span></span><br><span class="line">        map.put(<span class="string">&quot;us&quot;</span>,<span class="string">&quot;美国&quot;</span>);    <span class="comment">//值允许重复</span></span><br><span class="line">        map.put(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span>+map.size());</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        <span class="comment">//2删除</span></span><br><span class="line">        <span class="comment">//map.remove(&quot;us&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span>+map.size());</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        <span class="comment">//3遍历</span></span><br><span class="line">        <span class="comment">//3.1使用keySet</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; keyset = map.keySet();   //遍历获取key</span></span><br><span class="line">        <span class="keyword">for</span> (String key:map.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot;------&quot;</span>+map.get(key));   <span class="comment">//通过key获取value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用entrySet</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entryMap:entries)&#123;</span><br><span class="line">            System.out.println(entryMap.getKey()+<span class="string">&quot;-------&quot;</span>+entryMap.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3扩展 通过values获取keys</span></span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        Map&lt;String,String&gt; map2=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;cn&quot;</span>,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;uk&quot;</span>,<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;usa&quot;</span>,<span class="string">&quot;美国&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map2.values();</span><br><span class="line">        System.out.println(demo.forValuesGetKeys(map,values));</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;zh&quot;</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;中国&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">forValuesGetKeys</span><span class="params">(Map&lt;String,String&gt; map,Collection values)</span> </span>&#123;</span><br><span class="line">        Collection collection=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Object [] arrayValues = values.toArray();</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayValues.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entryMap : map.entrySet()) &#123;</span><br><span class="line">                <span class="comment">//arrayValues[i].equals(entryMap.getValue()) &amp;&amp;</span></span><br><span class="line">                <span class="keyword">if</span> ( arrayValues[i]==entryMap.getValue()) &#123;</span><br><span class="line">                     collection.add(entryMap.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map实现类"><a href="#Map实现类" class="headerlink" title="Map实现类"></a>Map实现类</h3><h4 id="HashMap【重点】"><a href="#HashMap【重点】" class="headerlink" title="HashMap【重点】"></a>HashMap【重点】</h4><p>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Stu, String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;Stu, String&gt;();</span><br><span class="line">        Stu s1=<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Stu s2=<span class="keyword">new</span> Stu(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Stu s3=<span class="keyword">new</span> Stu(<span class="string">&quot;王五&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        hashMap.put(s1, <span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">        hashMap.put(s2, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashMap.put(s3, <span class="string">&quot;贵州&quot;</span>);</span><br><span class="line">        <span class="comment">//添加成功，不过两个属性一模一样；</span></span><br><span class="line">        <span class="comment">//注：假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">        hashMap.put(<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>),<span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">        System.out.println(hashMap.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//hashMap.remove(s3);</span></span><br><span class="line">        System.out.println(hashMap.toString());</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1 使用keySet()遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Stu key : hashMap.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot; &quot;</span>+hashMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用entrySet()遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Stu, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        <span class="comment">//注：同上</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="keyword">new</span> Stu(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)));</span><br><span class="line">        System.out.println(hashMap.containsValue(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可,为了保证数据安全,不重复，尽可能在实体中重写hashCode方法和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stu stu = (Stu) o;</span><br><span class="line">        <span class="keyword">return</span> age == stu.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, stu.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a><strong>HashMap源码分析</strong></h4></li>
<li><p>默认初始化容量：<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></p>
<ul>
<li>数组最大容量：<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li>
</ul>
</li>
<li><p>默认加载因子：<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p>
</li>
<li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：<code>static final int TREEIFY_THRESHOLD = 8;</code></p>
</li>
<li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：<code>static final int UNTREEIFY_THRESHOLD = 6;</code></p>
</li>
<li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：<code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p>
</li>
<li><p>HashMap存储的数组：<code>transient Node&lt;K,V&gt;[] table;</code></p>
</li>
<li><p>HashMap存储的元素个数：<code>transient int size;</code></p>
<blockquote>
<ul>
<li>默认加载因子是什么？<ul>
<li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。</li>
</ul>
</li>
<li>链表调整为红黑树的链表长度阈值是什么？<ul>
<li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li>
</ul>
</li>
<li>红黑树调整为链表的链表长度阈值是什么？<ul>
<li>当红黑树的元素个数小于该阈值时就会转换成链表。</li>
</ul>
</li>
<li>链表调整为红黑树的数组最小阈值是什么？<ul>
<li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li>
</ul>
</li>
</ul>
</blockquote>
<p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p>
<p>  当我们往对象里添加元素时调用put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  扩容的代码如下（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newCap;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//略&#125;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p>
<ul>
<li>*注**：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</li>
</ul>
<hr>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h4><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><strong>Hashtable</strong></h4><ul>
<li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p>
</li>
<li><p>初始容量11，加载因子0.75。</p>
<p>这个集合在开发过程中已经不用了，稍微了解即可。</p>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h4><ul>
<li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li>
</ul>
<p>它继承了Hashtable的方法，与流关系密切，此处不详解。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h4><ul>
<li>实现了SortedMap接口（是Map的子接口），可以对key自动排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student, Integer&gt; treeMap=<span class="keyword">new</span> TreeMap&lt;Student, Integer&gt;();</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">        Student s3=<span class="keyword">new</span> Student(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        treeMap.put(s1, <span class="number">21</span>);</span><br><span class="line">        treeMap.put(s2, <span class="number">22</span>);</span><br><span class="line">        treeMap.put(s3, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span></span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        treeMap.remove(<span class="keyword">new</span> Student(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1 使用keySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Student key : treeMap.keySet()) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">&quot; &quot;</span>+treeMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用entrySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line">        System.out.println(treeMap.containsKey(s1));</span><br><span class="line">        System.out.println(treeMap.isEmpty());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学生类中实现Comparable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="keyword">this</span>.id-o.id;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以使用比较器来定制比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap2=<span class="keyword">new</span> TreeMap&lt;Student, Integer&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h4><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p>
<hr>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul>
<li><p><strong>概念</strong>：集合工具类，定义了除了存取以外的集合常用方法。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><code>public static void reverse(List&lt;?&gt; list)</code>//反转集合中元素的顺序</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>//随机重置集合元素的顺序</li>
<li><code>public static void sort(List&lt;T&gt; list)</code>//升序排序（元素类型必须实现Comparable接口）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示Collections工具类的使用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">20</span>);</span><br><span class="line">    list.add(<span class="number">10</span>);</span><br><span class="line">    list.add(<span class="number">30</span>);</span><br><span class="line">    list.add(<span class="number">90</span>);</span><br><span class="line">    list.add(<span class="number">70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sort排序</span></span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//binarySearch二分查找</span></span><br><span class="line">    <span class="keyword">int</span> i=Collections.binarySearch(list, <span class="number">10</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复制</span></span><br><span class="line">    List&lt;Integer&gt; list2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;<span class="number">5</span>;++i1) &#123;</span><br><span class="line">        list2.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法要求目标元素容量大于等于源目标</span></span><br><span class="line">    Collections.(list2, list);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reserve反转</span></span><br><span class="line">    Collections.reverse(list2);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//shuffle 打乱</span></span><br><span class="line">    Collections.shuffle(list2);</span><br><span class="line">    System.out.println(list2.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//补充：list转成数组</span></span><br><span class="line">    Integer[] arr=list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//补充：数组转成集合 </span></span><br><span class="line">    String[] nameStrings= &#123;<span class="string">&quot;tang&quot;</span>,<span class="string">&quot;he&quot;</span>,<span class="string">&quot;yu&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//受限集合，不能添加和删除</span></span><br><span class="line">    List&lt;String&gt; list3=Arrays.asList(nameStrings);</span><br><span class="line">    System.out.println(list3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注：基本类型转成集合时需要修改为包装类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
</search>
