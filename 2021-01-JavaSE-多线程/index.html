<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线程概述 关于进程和线程的知识都是操作系统里学过的内容，此处作为JAVA多线程的前置知识进行复习回顾，补充的内容可看可不看。  什么是进程进程是系统进行资源分配的基本单位，也是独立运行的基本单位。多个进程可以同时存在于内存中，能在一段时间内同时运行，在windows操作中，可以打开任务管理器看到各种各样的进程和对应的PID，并且都占用了一定的系统资源。单核CPU在同一个时刻，只能运行一个进程。所谓">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-多线程">
<meta property="og:url" content="http://example.com/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Mw-Blog">
<meta property="og:description" content="线程概述 关于进程和线程的知识都是操作系统里学过的内容，此处作为JAVA多线程的前置知识进行复习回顾，补充的内容可看可不看。  什么是进程进程是系统进行资源分配的基本单位，也是独立运行的基本单位。多个进程可以同时存在于内存中，能在一段时间内同时运行，在windows操作中，可以打开任务管理器看到各种各样的进程和对应的PID，并且都占用了一定的系统资源。单核CPU在同一个时刻，只能运行一个进程。所谓">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/QQ%E6%88%AA%E5%9B%BE20210312104252.jpg">
<meta property="og:image" content="https://pic.downk.cc/item/5fa5382b1cd1bbb86bb07912.png">
<meta property="og:image" content="https://pic.downk.cc/item/5fa610c41cd1bbb86bd6d0d9.png">
<meta property="article:published_time" content="2021-01-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-20T06:15:17.909Z">
<meta property="article:author" content="Mw">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/QQ%E6%88%AA%E5%9B%BE20210312104252.jpg">

<link rel="canonical" href="http://example.com/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaSE-多线程 | Mw-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
 
  <div id="music">
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52" src="//music.163.com/outchain/player?type=2&id=1305366486&auto=0&height=32"></iframe>
  </div>
  <style>
    #music {
        position: fixed;
        left: 20px;
        bottom: 5px;
        z-index: 998;
    }
  </style>
  
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mw-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Mw.png">
      <meta itemprop="name" content="Mw">
      <meta itemprop="description" content="God is Developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mw-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE-多线程
        </h1>

        <div class="post-meta">
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 14:15:17" itemprop="dateModified" datetime="2021-03-20T14:15:17+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
                </span>
            </span>

          
            <span id="/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="JavaSE-多线程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>43 min</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><blockquote>
<p>关于进程和线程的知识都是操作系统里学过的内容，此处作为JAVA多线程的前置知识进行复习回顾，补充的内容可看可不看。</p>
</blockquote>
<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p><strong>进程是系统进行资源分配的基本单位</strong>，<strong>也是独立运行的基本单位</strong>。多个进程可以同时存在于内存中，能在一段时间内同时运行，在windows操作中，可以打开任务管理器看到各种各样的进程和对应的PID，并且都占用了一定的系统资源。单核CPU在同一个时刻，只能运行一个进程。所谓同时运行是宏观上的概念，微观上进程之间是在不停地快速切换。</p>
<span id="more"></span>
<blockquote>
<p>补充：</p>
<p>进程具有几个基本特性：</p>
<ul>
<li>动态性。进程是程序在处理器上的一次执行过程，它因创建而产生，由调度而执行，因得不到资源而暂停，最后因撤销而消亡。</li>
<li>并发性：如概述里所说，多个进程可以同时存在于内存中，能在一段时间内同时运行。进程的目的是使程序能与其他程序并行，以提高资源利用率。</li>
<li>独立性：进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</li>
<li>异步性：进程以各自独立的、不可预知的速度向前推进。</li>
<li><strong>结构特征</strong>：为了描述和记录进程的运动变化过程，并使之能正确运行，每个进程都由程序段、数据段和一个进程控制块 (Process Control Block,PCB)组成。</li>
</ul>
<p>系统根据PCB感知进程的存在。PCB是进程存在的唯一标志。</p>
</blockquote>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程又称<strong>轻量级进程</strong> (Light Weight Process),它是进程内一个相对独立的、可调度的执行单元，也是CPU的基本调度单位。一个进程由一个或多个线程组成，彼此间完成不同的工作，同时执行，称为多线程，此处的同时执行也是宏观上的。在windows操作系统中，可以打开任务管理器，找到性能分页下的资源管理器，可以查看每个进程所拥有的线程数。</p>
<p>JAVA虚拟机是一个进程，当中默认包含主线程 (main)，可通过代码创建多个独立线程，与main并发执行。</p>
<blockquote>
<p>补充：</p>
<ul>
<li><p><strong>线程的引入</strong></p>
<p>在操作系统中引入线程，是为了减少程序并发执行时所付出的时空开销，使操作系统具有更好的并发性，为了说明这一点，先来回顾一下进程的两个基本属性：</p>
<ol>
<li>进程是一个拥有资源的独立单位。</li>
<li>进程同时又是一个可以被处理器独立调度和分配的单元。</li>
</ol>
<p>上述两个属性构成了程序并发执行的基础。然而，为了使进程能并发执行，操作系统还必须进行一系列的操作，如进程的创建、撤销进程和进程切换。在进行这些操作时，操作系统要为进程分配资源及回收资源，为运行进程保存现场信息，这些工作都需要付出较多的时空开销。为了使多个程序更好地并发执行，并尽量减少操作系统的开销，操作系统设计者考虑将进程的两个属性分离开来，让线程去完成第二个基本属性的任务，而进程只完成第一个基本属性的任务。</p>
</li>
<li><p><strong>线程的定义</strong></p>
<p>线程的定义存在多种不同的提法，前文概述中已阐述一二，此处进行补充说明。线程本身不能单独运行，只能包含在进程中，只能在进程中执行。线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源，但它可以与同属一个进程的其他线程<strong>共享</strong>该进程资源。多线程是指一个进程中有多个线程，这些线程共享该进程资源。如果一个线程修改了一个数据项，其他线程可以了解和使用此结果数据。一个线程打开并读一个文件时，同一进程中的其他线程也可以同时读此文件。</p>
</li>
</ul>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>进程是操作系统资源分配的基本单位，而线程是CPU的基本调度单位。</li>
<li>一个程序运行后之后有一个进程。</li>
<li>一个进程可以包含多个线程，但是至少需要有一个线程，否则这个线程是没有意义的。</li>
<li>进程间不能共享数据段地址，但同进程的线程之间可以。</li>
</ol>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><ul>
<li>任何一个线程都具有基本的组成部分：<ul>
<li>CPU时间片：操作系统会为每个线程分配执行时间。</li>
<li>运行数据：<ul>
<li>堆空间：存储线程需要使用的对象，多个线程可以共享堆中的对象。</li>
<li>栈空间：存储线程需要使用的局部变量，每个线程都拥有独立的栈。</li>
</ul>
</li>
<li>线程的逻辑代码</li>
</ul>
</li>
</ul>
<h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ul>
<li>线程抢占式执行。<ul>
<li>效率高。</li>
<li>可防止单一线程长时间独占CPU。</li>
</ul>
</li>
<li>在单核CPU中，宏观上同时执行，微观上顺序执行。</li>
</ul>
<hr>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><ul>
<li>创建线程的三种方式：<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口。</li>
<li>实现Callable接口。 (6.4节演示)</li>
</ol>
</li>
</ul>
<h3 id="继承Thread创建线程"><a href="#继承Thread创建线程" class="headerlink" title="继承Thread创建线程"></a>继承Thread创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testMyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//启动子线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----<span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">----<span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">----<span class="number">2</span></span><br><span class="line">----<span class="number">3</span></span><br><span class="line">----<span class="number">4</span></span><br><span class="line">----<span class="number">5</span></span><br><span class="line">----<span class="number">6</span></span><br><span class="line">----<span class="number">7</span></span><br><span class="line">----<span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">----<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>每次运行后得到的结果都不一样，而且主线程和子线程都是交替执行的，并且是抢占式执行。</p>
<p>需要<strong>注意</strong>的是，在main方法中需要调用线程类的start方法来启动线程，如果调用run方法就相当于调用了一个普通类中的方法，那么还是由主线程执行。</p>
<h3 id="获取和修改线程名称"><a href="#获取和修改线程名称" class="headerlink" title="获取和修改线程名称"></a>获取和修改线程名称</h3><ul>
<li><p><strong>获取线程ID和线程名称</strong></p>
<ol>
<li>在Thread的子类中调用<code>this.getId()</code>或<code>this.getName()</code>。</li>
<li>使用<code>Thread.currentThread().getId()</code>和<code>Thread.currentTread().getName()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类</span></span><br><span class="line"><span class="comment"> * 获取线程名方法演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//第一种方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程ID：&quot;</span>+<span class="keyword">this</span>.getId()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;线程名：&quot;</span>+<span class="keyword">this</span>.getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            <span class="comment">//第二种方法</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;线程ID：&quot;+Thread.currentThread().getId()+&quot; &quot;+&quot;线程名：&quot;+Thread.currentThread().getName());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用第一种方法的线程类必须继承Thread父类，否则不能使用这两个方法。</p>
<p>第二种方法调用的静态方法currentThread表示获取当前线程，哪个线程执行的当前代码就获取谁。</p>
<p>在<code>testMyThread</code>类中<strong>再新创建</strong>一个线程类对象并启动，可以看到如下结果：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">1</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">6</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：Thread-<span class="number">0</span> <span class="number">9</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">6</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：Thread-<span class="number">1</span> <span class="number">9</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">主线程：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改线程名称</strong></li>
</ul>
<ol>
<li>调用线程对象的<code>setName()</code>方法。</li>
<li>使用线程子类的构造方法赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用setName方法</span></span><br><span class="line">myThread.setName(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread2.setName(<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">myThread2.start();</span><br></pre></td></tr></table></figure>

<p>使用该方法需要注意必须在线程启动之前修改线程名，否则就没有意义了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程类的带参构造方法调用了父类的构造方法，也可以把name赋给线程名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">MyThread myThread=<span class="keyword">new</span> MyThread(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">MyThread myThread2=<span class="keyword">new</span> MyThread(<span class="string">&quot;子线程2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在创建线程对象时可以直接通过构造方法为线程修改名字，运行后结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">0</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">6</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">7</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">1</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">8</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">线程ID：<span class="number">11</span> 线程名：子线程<span class="number">2</span> <span class="number">9</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">2</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">3</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">4</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">5</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">6</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">7</span></span><br><span class="line">主线程：<span class="number">9</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">8</span></span><br><span class="line">线程ID：<span class="number">10</span> 线程名：子线程<span class="number">1</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="一个线程小案例"><a href="#一个线程小案例" class="headerlink" title="一个线程小案例"></a>一个线程小案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用继承Thread类实现4个窗口各卖100张票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWin</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWin</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    ticket--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+ticket+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//四个窗口</span></span><br><span class="line">        TicketWin ticketWin1=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        TicketWin ticketWin2=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        TicketWin ticketWin3=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        TicketWin ticketWin4=<span class="keyword">new</span> TicketWin(<span class="string">&quot;窗口4&quot;</span>);</span><br><span class="line">        ticketWin1.start();</span><br><span class="line">        ticketWin2.start();</span><br><span class="line">        ticketWin3.start();</span><br><span class="line">        ticketWin4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码后结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">95</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">94</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">93</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">92</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">91</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable创建线程"><a href="#实现Runnable创建线程" class="headerlink" title="实现Runnable创建线程"></a>实现Runnable创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象，实现run功能</span></span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程类</span></span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(myRunnable, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">主线程：<span class="number">0</span></span><br><span class="line">子线程：<span class="number">0</span></span><br><span class="line">主线程：<span class="number">1</span></span><br><span class="line">子线程：<span class="number">1</span></span><br><span class="line">主线程：<span class="number">2</span></span><br><span class="line">子线程：<span class="number">2</span></span><br><span class="line">主线程：<span class="number">3</span></span><br><span class="line">子线程：<span class="number">3</span></span><br><span class="line">主线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">5</span></span><br><span class="line">子线程：<span class="number">6</span></span><br><span class="line">子线程：<span class="number">7</span></span><br><span class="line">子线程：<span class="number">8</span></span><br><span class="line">子线程：<span class="number">9</span></span><br><span class="line">主线程：<span class="number">5</span></span><br><span class="line">主线程：<span class="number">6</span></span><br><span class="line">主线程：<span class="number">7</span></span><br><span class="line">主线程：<span class="number">8</span></span><br><span class="line">主线程：<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>上述代码段中使用的构造方法是<code>Thread((Runnable target, String name)</code>，Runnable是一个接口类，方法体只包含一个抽象方法run。既然参数传进来的是接口类，那么也可以使用匿名内部类 (如果线程只使用一次):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建可运行对象</span></span><br><span class="line">        Runnable runnable=<span class="keyword">new</span> Runnable() &#123;    </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(runnable, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable小案例"><a href="#Runnable小案例" class="headerlink" title="Runnable小案例"></a>Runnable小案例</h3><ol>
<li><strong>实现四个窗口共卖100张票</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 票类，实现买票功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建票对象</span></span><br><span class="line">        Ticket ticket=<span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread w1=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread w2=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread w3=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        Thread w4=<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;窗口4&quot;</span>);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">        w4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以这样的逻辑写代码是没有错的，但是在运行的时候大家会发现控制台打印的似乎并没有实现“共享”，但最终都会有某一个窗口卖完票：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">99</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">96</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">97</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">98</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">93</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">94</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">95</span>张。</span><br><span class="line">窗口<span class="number">1</span>卖出了一张票，还剩<span class="number">89</span>张。</span><br><span class="line">    ......</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">2</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">1</span>张。</span><br><span class="line">窗口<span class="number">4</span>卖出了一张票，还剩<span class="number">0</span>张。</span><br><span class="line">窗口<span class="number">3</span>卖出了一张票，还剩<span class="number">16</span>张。</span><br><span class="line">窗口<span class="number">2</span>卖出了一张票，还剩<span class="number">17</span>张。</span><br></pre></td></tr></table></figure>

<p>  这是因为线程是抢夺式占用CPU，每个线程都以各自的不可预知的进度执行。等后面讲完线程的同步之后你可以再来理解这个案例。<br>2. <strong>你和你女朋友同时向银行卡里面存取钱</strong>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 银行卡 (普通类)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        Money = money;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 存钱功能 (功能类)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BankCard card;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddMoney</span><span class="params">(BankCard bankCard)</span> </span>&#123;</span><br><span class="line">        card=bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//往卡里存200</span></span><br><span class="line">            card.setMoney(card.getMoney()+<span class="number">200</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存了200元，卡里余额为：&quot;</span>+(card.getMoney()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取钱功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubMoney</span><span class="params">(BandCard bandCard)</span> </span>&#123;</span><br><span class="line">        card=bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(card.getMoney()&gt;=<span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//往卡里取200</span></span><br><span class="line">                card.setMoney(card.getMoney()-<span class="number">200</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了200元，卡里还剩&quot;</span>+card.getMoney());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//余额不足，回退这次取钱过程，否则有效的取钱次数可能不到10次</span></span><br><span class="line">                i--;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testBankCard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建银行卡对象</span></span><br><span class="line">        BandCard bandCard=<span class="keyword">new</span> BandCard();</span><br><span class="line">        <span class="comment">//创建功能对象</span></span><br><span class="line">        AddMoney addMoney=<span class="keyword">new</span> AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney=<span class="keyword">new</span> SubMoney(bandCard);</span><br><span class="line">        <span class="comment">//创建线程对象并启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(addMoney,<span class="string">&quot;爸爸&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(subMoney,<span class="string">&quot;我&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行代码结果如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">0</span></span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">余额不足</span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">200</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">400</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">600</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">800</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1000</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1000</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1200</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1400</span></span><br><span class="line">爸爸存了<span class="number">200</span>元，卡里余额为：<span class="number">1600</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">800</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1400</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">1000</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">800</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">600</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">400</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">200</span></span><br><span class="line">我取了<span class="number">200</span>元，卡里还剩<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>  当然每次运行结果是不一样的，而且可以注意到控制台打印的数据似乎并不“正确”，原因同上一个案例，不过最终的结果卡里还是0元。这个案例也可以写成匿名内部类以减少代码量，缺点是可读性差，这里不再演示。</p>
<h3 id="Thread和Runnable的区别及正确写法"><a href="#Thread和Runnable的区别及正确写法" class="headerlink" title="Thread和Runnable的区别及正确写法"></a>Thread和Runnable的区别及正确写法</h3><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0NTM2MS9hcnRpY2xlL2RldGFpbHMvOTMyMjM0ODg=">https://blog.csdn.net/weixin_43145361/article/details/93223488<i class="fa fa-external-link-alt"></i></span></p>
<p>Thread正确写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line">        java.lang.Thread tA=<span class="keyword">new</span> java.lang.Thread(t1, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        tA.setPriority(<span class="number">5</span>);</span><br><span class="line">        java.lang.Thread tB=<span class="keyword">new</span> java.lang.Thread(t1, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        tB.setPriority(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程优先执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line"></span><br><span class="line">        tA.join();  <span class="comment">//插队 让主线程等待子线程进行完后执行</span></span><br><span class="line">        tB.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + i + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Runnable正确写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖了第&quot;</span> + ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable=<span class="keyword">new</span> Runnable();</span><br><span class="line">        java.lang.Thread t1=<span class="keyword">new</span> java.lang.Thread(runnable);</span><br><span class="line">        java.lang.Thread t2=<span class="keyword">new</span> java.lang.Thread(runnable);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程基本状态-源码补充"><a href="#线程基本状态-源码补充" class="headerlink" title="线程基本状态 (源码补充)"></a>线程基本状态 (源码补充)</h2><p>在JDK1.5之后，把就绪状态和运行状态合成了一个Runnable状态，可以通过<code>public Thread.State getState()</code>方法获取当前线程的状态。</p>
<p>我们可以通过源码来查看一下这几个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个State返回类型实际上一个枚举类。</p>
<ul>
<li><p><strong>NEW</strong> 初始状态<br>线程还没有启动时的状态。</p>
</li>
<li><p><strong>RUNNABLE</strong> 就绪状态和执行状态<br>线程启动时的状态。线程被JVM所执行但它还可能需要一些来自操作系统的其他资源才能执行。</p>
</li>
<li><p><strong>BLOCKED</strong> 阻塞状态<br>当线程访问临界区 (同步块代码)时，如果没有拿到访问锁，便进入阻塞状态。<br>线程被一个监听锁所阻塞时的状态。</p>
</li>
<li><p><strong>WAITING</strong>  (无期限)等待状态<br>线程正在等待时的状态。线程被以下方法所调用就会进入等待状态：</p>
<ul>
<li><code>Object.wait</code>无参方法</li>
<li><code>Thread.join</code>无参方法</li>
<li><code>LockSupport.park</code><br>wait方法可以让当前线程进入等待状态，需要其他线程调用此线程对象的notify方法或者notifyAll方法来唤醒此线程；调用join方法的线程需要等到被调用线程终止才能结束等待状态。</li>
</ul>
</li>
<li><p><strong>TIMED_WAITING</strong> 有限等待状态<br>线程在指定时间后才能结束等待的一种等待状态。是由于调用了以下方法所引起的一种状态：</p>
<ul>
<li><code>Thread.sleep</code></li>
<li><code>Object.wait</code>带参方法</li>
<li><code>Thread.join</code>带参方法</li>
<li><code>LockSupport.parkNanos</code></li>
<li><code>LockSupport.parkUntil</code></li>
</ul>
</li>
<li><p><strong>TERMINATED</strong> 终止状态<br>线程终止时的状态。该线程已经执行完毕。</p>
</li>
</ul>
<img src="/2021-01-JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/QQ%E6%88%AA%E5%9B%BE20210312104252.jpg" class="">

<hr>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><ul>
<li><p><code>public static void sleep(long millis)</code></p>
<p>当前线程主动休眠millis毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示sleep的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">// (主线程)每隔一秒打印一次</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>public static void yield()</code></p>
<p>当前线程主动放弃时间片，回到就绪状态，竞争下一次时间片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示yield的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">            <span class="comment">//打印一次后主动放弃时间片，释放CPU</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类里创建两个线程对象执行上述代码，所得到的打印结果会更接近于交替打印。</p>
</li>
<li><p><code>public final void join()</code></p>
<p>允许其他线程加入到当前线程中。当某线程调用该方法时，加入并阻塞当前线程，直到加入的线程执行完毕，当前线程才继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示join的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//加入到当前线程 (主线程main)，并阻塞当前线程</span></span><br><span class="line">        <span class="comment">//必须要在线程启动之后调用</span></span><br><span class="line">        thread.join();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉join这行代码，就和之前运行的结果一样，两个线程抢占执行；调用join之后结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">子线程：<span class="number">0</span></span><br><span class="line">子线程：<span class="number">1</span></span><br><span class="line">子线程：<span class="number">2</span></span><br><span class="line">子线程：<span class="number">3</span></span><br><span class="line">子线程：<span class="number">4</span></span><br><span class="line">子线程：<span class="number">5</span></span><br><span class="line">子线程：<span class="number">6</span></span><br><span class="line">子线程：<span class="number">7</span></span><br><span class="line">子线程：<span class="number">8</span></span><br><span class="line">子线程：<span class="number">9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>子线程加入到主线程并阻塞了主线程，子线程执行完毕后才恢复主线程的运行。</p>
</li>
<li><p><code>pubic final void setPriority(int newPriority)</code></p>
<p>改变该线程的优先级，线程优先级为1-10，默认为5，优先级越高，表示获取CPU机会越多。</p>
<p>把前面<code>MyRunnable</code>类中的循环次数写多一点，比如改成50次，然后在测试类里设置优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(myRunnable,<span class="string">&quot;子线程3&quot;</span>);</span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t3.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会发现每次运行的结果都是子线程1最后执行完，说明优先级设置成功了。</p>
</li>
<li><p><code>public final void setDaemon(boolean on)</code></p>
<p>如果参数为true，则标记该线程为守护线程。</p>
<p>在JAVA中线程有两类：<strong>用户线程</strong> (前台线程)、<strong>守护线程</strong> (后台线程)。守护可以理解为守护用户线程。如果程序中所有用户线程都执行完毕了，守护线程会自动结束。<strong>垃圾回收线程属于守护线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示守护线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread thread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//必须在start之前设置</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道线程争夺的情况，但当某个线程被设置成守护线程时，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">Thread-<span class="number">0</span>：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当主线程执行完毕后，子线程只打印了4次，但因为前者的结束而结束。</p>
</li>
</ul>
<hr>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>这里有一个线程安全问题，假设有A、B两个线程，他们都往一个数组中的index位置存入一个数据并且执行index+1。</p>
<p>A线程存入<code>&quot;hello&quot;</code>，然后使<code>index++</code>；B线程存入<code>&quot;world&quot;</code>，然后使<code>index++</code>。当这两个线程同时执行时，数组中存入的结果会是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String[] strings=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//存入hello</span></span><br><span class="line">        Runnable runnableA=<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                strings[index]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//存入world</span></span><br><span class="line">        Runnable runnableB=<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                strings[index]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread A=<span class="keyword">new</span> Thread(runnableA);</span><br><span class="line">        Thread B=<span class="keyword">new</span> Thread(runnableB);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">        <span class="comment">//加入主线程，用来阻塞主线程使最后的输出语句最后执行</span></span><br><span class="line">        A.join();</span><br><span class="line">        B.join();        </span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行代码，发现得到的结果并不一致，有可能出现<code>[hello, world, null, null, null]</code>，也有可能出现<code>[world, null, null, null, null]</code>；以第二个结果为例，当线程A存入hello之后，CPU马上就被线程B所抢夺，B存入了world覆盖了A存入的hello，这之后才执行了各自的<code>index++</code>。</p>
<p><strong>多线程安全问题</strong>：</p>
<ul>
<li><p>当多线程并发访问</p>
<p>临界资源</p>
<p>时，如果破坏了</p>
<p>原子操作</p>
<p>，可能会造成数据不一致。</p>
<ul>
<li>临界资源：共享资源 (对于同一个对象)，一次仅允许一个线程使用，才可以保证其正确性。</li>
<li>原子操作：不可分割的多步操作，被视为一个整体，其顺序和步骤不可打乱或缺省，比如上一段代码的存hello和存world应当被看成两个原子操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：</p>
<p><strong>临界资源和临界区</strong> (针对线程而言)：</p>
<p>线程在运行过程中，会与同一进程内的其他线程共享资源，把同时只允许一个线程使用的资源称为临界资源。为了保证临界资源的正确使用，可以把临界资源的访问分成以下四个部分：</p>
<ol>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区；如果可以进入临界区，通常设置相应的“正在访问临界区”标志，以阻止其他线程同时进入临界区。</li>
<li><strong>临界区</strong>。<strong>线程用于访问临界资源的代码</strong>，<strong>又称临界段</strong>。</li>
<li><strong>退出区</strong>。临界区后用于将“正在访问临界区”标志清除部分。</li>
<li>剩余区。线程中除上述3部分以外的其他部分。</li>
</ol>
<p>简单来说，临界资源是一种系统资源，需要不同的线程互斥访问，例如前文代码中的数组；而临界区则是每个线程中访问临界资源的一段代码，是属于对应线程的，前文代码中的存hello和存world就可以看成是两个临界区，临界区前后需要设置进入区和退出区以进行检查和恢复。</p>
</blockquote>
<p>JAVA中，在程序应用里要保证线程的安全性就需要用到<strong>同步代码块</strong>。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对临界资源对象加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(临界资源对象)&#123;</span><br><span class="line">    <span class="comment">//代码 (原子操作)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  把上文存hello和存world两个临界区放进同步代码块中就可以保证输出结果不会出现覆盖的情况：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (strings) &#123;</span><br><span class="line">    strings[index]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (strings) &#123;</span><br><span class="line">    strings[index]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>  现在就能解决之前的卖票小案例，你可以从目录跳转到Runnable小案例，并使用同步代码块来实现互斥访问票这个临界资源：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注：这个锁可以是任意一种对象，但不能直接在里面new</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;            </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再次运行你就能看到期望的结果，这里不再演示。</p>
<blockquote>
<p>注：</p>
<p><strong>每个对象都有一个互斥锁标记</strong>，<strong>用来分配给线程的</strong>。</p>
<p>只有拥有对象互斥锁标记的线程，才能进入对该对象加锁的同步代码块。</p>
<p>线程退出同步代码块时，会释放相应的互斥锁标记。</p>
</blockquote>
<p>  前文的银行卡存取案例同样也能解决了：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取钱</span></span><br><span class="line"><span class="keyword">synchronized</span> (card) &#123;</span><br><span class="line">    <span class="keyword">if</span>(card.getMoney()&gt;=<span class="number">200</span>) &#123;</span><br><span class="line">        card.setMoney(card.getMoney()-<span class="number">200</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了200元，卡里还剩&quot;</span>+card.getMoney());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i--;</span><br><span class="line">        System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存钱</span></span><br><span class="line"><span class="keyword">synchronized</span> (card) &#123;</span><br><span class="line">    card.setMoney(card.getMoney()+<span class="number">200</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存了200元，卡里余额为：&quot;</span>+(card.getMoney()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行一下，没有问题。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象 (this)加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> 返回值类型 方法名称 (形参列表)&#123;</span><br><span class="line">    <span class="comment">//代码 (原子操作)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  用这种同步方式改写2.5节中的第一个案例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>) &#123;            </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了一张票，还剩&quot;</span>+(--ticket)+<span class="string">&quot;张。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  得到的也是一样的正确结果。在这个同步方法中，锁就是<code>this</code>当前对象；如果是静态类，那么锁就是类对象，就相当于在同步代码块的括号里写<code>XXX.class</code>，XXX代表当前的类。</p>
<blockquote>
<p>注：</p>
<p>只有拥有对象互斥锁标记的线程，才能进入该对象加锁的同步方法中。线程退出同步方法时，会释放相应的互斥锁标记。</p>
</blockquote>
<ul>
<li><strong>同步规则</strong><ul>
<li>只有在调用包含同步代码块的方法，或者同步方法时，才需要对象的锁标记。<br>临界区 (互斥执行)才需要加锁。</li>
<li>如调用不包含同步代码块的方法，或普通方法时，则不需要锁标记，可直接调用。</li>
<li>已知JDK中线程安全的类：<ul>
<li>StringBuffer</li>
<li>Vector</li>
<li>Hashtable</li>
<li>以上类中的公开方法，均为synchronized修饰的同步方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经典问题-死锁"><a href="#经典问题-死锁" class="headerlink" title="经典问题 (死锁)"></a>经典问题 (死锁)</h3><p><strong>死锁</strong>：</p>
<ul>
<li>当第一个线程拥有A对象锁标记，并等待B对象锁标记，同时第二个线程拥有B对象锁标记，并等待A对象锁标记时，产生死锁。</li>
<li>一个线程可以同时拥有多个对象的锁标记，当线程阻塞时，不会释放已经拥有的锁标记，由此可能造成死锁。</li>
</ul>
<blockquote>
<p>补充：</p>
<p><strong>死锁的概念</strong> (对于线程)：</p>
<p>当多个线程因竞争系统资源或互相通信而处于半永久阻塞状态时，若无外力作用，这些线程都将无法向前推进。这些线程中的每一个线程，均无限期地等待此组线程中某个其他线程占用的、自己永远无法得到的资源，这种现象称为死锁。</p>
<p><strong>资源分类</strong>：</p>
<p>现代操作系统所管理的资源类型十分丰富，并且可以从不同角度出发对其进行分类，例如，可以把资源分为可剥夺资源和不可剥夺资源。</p>
<ul>
<li><strong>可剥夺资源</strong>是指虽然资源占有者线程需要使用该资源，但另一个线程可以强行把该资源从占有者线程处剥夺过来自己使用。</li>
<li><strong>不可剥夺资源</strong>是指<strong>除非</strong>占有者线程不再需要使用该资源而主动释放资源，否则其他线程不得在占有者线程使用资源过程中强行剥夺。</li>
</ul>
<p>死锁产生的原因是<strong>竞争资源</strong>。可剥夺资源的竞争不会引起死锁。更进一步看，死锁产生的原因是<strong>系统资源不足</strong>和线程<strong>推进顺序不当</strong>；后者是重要原因而前者是根本原因。</p>
</blockquote>
<p>通过一个小案例来演示死锁的产生，假如男孩和女孩桌子上同时吃饭，桌上只有一双筷子，当一个人同时拥有A，B两根筷子的时候才能吃：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;男孩拿到了a&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;男孩拿到了b&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;男孩可以吃东西了...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;女孩拿到了b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;女孩拿到了a&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;女孩可以吃东西了...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个锁(两个筷子)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object a=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object b=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boy boy=<span class="keyword">new</span> Boy();</span><br><span class="line">        Girl girl=<span class="keyword">new</span> Girl();</span><br><span class="line">        girl.start();</span><br><span class="line">        <span class="comment">//加上休眠 解决死锁问题</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            // TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        boy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后程序进入死锁状态，并且无限期地等待下去：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//控制台打印 (程序未结束)</span><br><span class="line">男孩拿到了a</span><br><span class="line">女孩拿到了b</span><br></pre></td></tr></table></figure>

<p>男孩和女还各持有一根筷子，并且都在等待对方的一根筷子，导致两个人都吃不了饭。可以通过sleep方式使其中一个线程休眠一小会，男孩用A (B)吃完女孩用B (A)再吃；或者把B (A)同步代码块中的锁换一下位置A (B)，一开始两个人都抢同一根筷子，有第一根筷子就有第二根筷子，没抢到的就等另一个吃完饭再吃。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>在2.5节中的第二个案例银行卡存取中，打印出了很多余额不足，取钱线程在银行卡里没钱时也在不停地取钱，为了让取钱线程只在银行卡里有钱时再取，就需要实现线程间通信。</p>
<ul>
<li><p>等待</p>
<p>：</p>
<ul>
<li><code>public final void wait()</code></li>
<li><code>public final void wait(long timeout)</code></li>
<li>必须在对obj加锁的同步代码块中调用。在一个线程中，调用<code>obj.wait()</code>时，此线程会释放其拥有的所有锁标记。同时此线程阻塞在obj的等待队列中。总而言之，就是释放锁，进入等待队列。</li>
</ul>
</li>
<li><p>通知</p>
<p>：</p>
<ul>
<li><code>public final void notify()</code></li>
<li><code>public final void notifyAll()</code></li>
<li>进入等待的线程需要其他线程调用该线程的通知方法来将其唤醒。</li>
</ul>
</li>
</ul>
<p>还是银行卡存取案例，此处应用线程通信再来演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 银行卡 (普通类)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BandCard &#123;</span><br><span class="line">    private double Money;</span><br><span class="line">    &#x2F;&#x2F;标志，true表示卡里有钱-可取，false表示无钱-可存</span><br><span class="line">    boolean flag&#x3D;false;    </span><br><span class="line">    public synchronized void put(double money) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;有钱不用存</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            &#x2F;&#x2F;进入等待队列 (锁.wait)，同时释放锁和CPU</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.Money+&#x3D;money;</span><br><span class="line">        System.out.println(&quot;你爸存了&quot;+money+&quot;元，卡里还剩&quot;+this.Money+&quot;元。&quot;);</span><br><span class="line">        &#x2F;&#x2F;存完之后卡里有钱</span><br><span class="line">        flag&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;唤醒取钱线程</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void take(double money) throws InterruptedException &#123;    </span><br><span class="line">        &#x2F;&#x2F;没钱不能取</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.Money-&#x3D;money;</span><br><span class="line">        System.out.println(&quot;你取了&quot;+money+&quot;元，卡里还剩&quot;+this.Money+&quot;元。&quot;);</span><br><span class="line">        flag&#x3D;false;</span><br><span class="line">        &#x2F;&#x2F;唤醒存钱线程</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存钱功能 (功能类)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AddMoney implements Runnable&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    public AddMoney(BandCard bandCard) &#123;</span><br><span class="line">        card&#x3D;bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;存10次</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                card.put(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 取钱功能</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SubMoney implements Runnable&#123;</span><br><span class="line">    BandCard card;</span><br><span class="line">    public SubMoney(BandCard bandCard) &#123;</span><br><span class="line">        card&#x3D;bandCard;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;取10次</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                card.take(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testBankCard &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建银行卡对象</span><br><span class="line">        BandCard bandCard&#x3D;new BandCard();</span><br><span class="line">        &#x2F;&#x2F;创建操作</span><br><span class="line">        AddMoney addMoney&#x3D;new AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney&#x3D;new SubMoney(bandCard);</span><br><span class="line">        &#x2F;&#x2F;创建线程对象并启动</span><br><span class="line">        new Thread(addMoney).start();</span><br><span class="line">        new Thread(subMoney).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后得到如下正确交替结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你取了200.0元，卡里还剩0.0元。</span><br></pre></td></tr></table></figure>

<p><strong>多存多取问题：</strong></p>
<ul>
<li><p><strong>if和while的区别</strong></p>
<p>if只适用用于单进单出，while适用于多进多出</p>
<p>但是如果往代码中再加入两个线程，比如你妈担心你钱不够用，也给你存钱；你妹妹来找你玩，往你卡里取钱。这时候就出现问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你爸存了200.0元，卡里还剩200.0元。</span><br><span class="line">你妹取了200.0元，卡里还剩0.0元。</span><br><span class="line">你妈存了200.0元，卡里还剩200.0元。</span><br><span class="line">你妹取了200.0元，卡里还剩0.0元。</span><br><span class="line">你取了200.0元，卡里还剩-200.0元。</span><br><span class="line">......</span><br><span class="line">你取了200.0元，卡里还剩-2000.0元。</span><br><span class="line">你妈存了200.0元，卡里还剩-1800.0元。</span><br><span class="line">你爸存了200.0元，卡里还剩-1600.0元。</span><br></pre></td></tr></table></figure>

<p>不仅余额负数，程序也并没有结束而进入永久等待的状态。</p>
<p>出现余额负数的原因是当“你”，“你妹”两个取钱线程都因为flag为false而进入等待队列时，然后“你妹”被存钱线程所唤醒，此时余额为200，被唤醒的“你妹”继续取钱，此时余额为0，然后唤醒“你”，<strong>注意</strong>，“你”被唤醒后接着从wait语句之后往下执行取钱操作，此时余额为-200。问题就出在“你”这里，“你”被唤醒后是继续往下执行的，并没有重新判断flag，解决办法很简单，将<mark>if改为while</mark>就可以了，如果flag为false被唤醒的你就会接着等待：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你爸存了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">200</span>.<span class="number">0</span>元。</span><br><span class="line">你取了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">0</span>.<span class="number">0</span>元。</span><br><span class="line">你妈存了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">200</span>.<span class="number">0</span>元。</span><br><span class="line">你取了<span class="number">200</span>.<span class="number">0</span>元，卡里还剩<span class="number">0</span>.<span class="number">0</span>元。</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>notify和notifyAll</strong></p>
<p>余额负数的问题解决了，但是程序陷入永久等待的问题还没解决，分析下原因：</p>
</li>
</ul>
<ol>
<li><strong>你爸存钱成功</strong>，flag为true，<strong>余额200</strong>；</li>
<li>你妈存钱失败，进入等待队列； (你妈)</li>
<li>你爸存钱失败，进入等待队列； (你妈，你爸)</li>
<li><strong>你取钱成功</strong>，flag为false，唤醒你妈，<strong>余额为0</strong>； (你爸)</li>
<li>你妹取钱失败，进入等待队列； (你爸，你妹)</li>
<li>你取钱失败，进入等待队列； (你爸，你妹，你)</li>
<li><strong>你妈存钱成功</strong>，flag为true，唤醒你，<strong>余额为200</strong>； (你爸，你妹)</li>
<li>你妈存钱失败，进入等待队列； (你爸，你妹，你妈)</li>
<li><strong>你取钱成功</strong>，flag为false，唤醒你妹，<strong>余额为0</strong>； (你爸，你妈)</li>
<li>你妹取钱失败，进入等待队列； (你爸，你妈，你妹)</li>
<li>你取钱失败，进入等待队列； (你爸，你妈，你妹，你)</li>
</ol>
<p>至此四个线程全部进入等待状态，在没有别的线程将其唤醒的情况下将陷入无限期等待。原因出在第9步，如果取钱线程“你”唤醒的是存钱线程，那么程序就会正常执行。修改方式也很简单，将代码中notify方法改成notifyAll就可以了，一次唤醒所有线程。结果正常运行不再演示，这里说这么多主要是体会线程同步的一个过程。</p>
<h3 id="经典问题-生产者消费者"><a href="#经典问题-生产者消费者" class="headerlink" title="经典问题 (生产者消费者)"></a>经典问题 (生产者消费者)</h3><p>若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个能存储多个产品的缓冲区，生产者将生产的产品放入缓冲区中，消费者从缓冲区取走产品进行消费，显然生产者和消费者之间必须保持<strong>同步</strong>，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个满的缓冲区中放入产品。</p>
<p>这个例子和上一节的案例差不多，理解了上一节的案例这个问题就能解决，以下是演示代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class ProductBuf &#123;</span><br><span class="line">    &#x2F;&#x2F;产品仓库 (缓冲区)</span><br><span class="line">    String[] products&#x3D;new String[6];</span><br><span class="line">    &#x2F;&#x2F;下标从-1开始，往0到5位置放产品</span><br><span class="line">    int index&#x3D;-1;</span><br><span class="line">    &#x2F;&#x2F;生产者生产</span><br><span class="line">    public synchronized void Productor() &#123;</span><br><span class="line">        while(index&gt;&#x3D;5) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;仓库已满，等待</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;放入产品</span><br><span class="line">        products[++index]&#x3D;&quot;product&quot;;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;生产了一个产品，产品数量：&quot;+(index+1));</span><br><span class="line">        System.out.println(Arrays.toString(products));</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;消费者消费</span><br><span class="line">    public synchronized void Consumer() &#123;</span><br><span class="line">        while (index&lt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;仓库已空，等待</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;取出产品</span><br><span class="line">        products[index--]&#x3D;null;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;消费了一个产品，产品数量：&quot;+(index+1));</span><br><span class="line">        System.out.println(Arrays.toString(products));</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Productor implements Runnable&#123;</span><br><span class="line">    ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">    public Productor() &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    public Productor(ProductBuf productBuf) &#123;</span><br><span class="line">        this.productBuf&#x3D;productBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;生产30个产品</span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++) &#123;</span><br><span class="line">            productBuf.Productor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line">    ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">    public Consumer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Consumer(ProductBuf productBuf) &#123;</span><br><span class="line">        this.productBuf&#x3D;productBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;消费30个产品</span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++) &#123;</span><br><span class="line">            productBuf.Consumer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProductBuf productBuf&#x3D;new ProductBuf();</span><br><span class="line">        Productor productor&#x3D;new Productor(productBuf);</span><br><span class="line">        Consumer consumer&#x3D;new Consumer(productBuf);</span><br><span class="line">        new Thread(productor,&quot;生产者1号&quot;).start();</span><br><span class="line">        new Thread(productor,&quot;生产者2号&quot;).start();</span><br><span class="line">        new Thread(consumer,&quot;消费者1号&quot;).start();</span><br><span class="line">        new Thread(consumer,&quot;消费者2号&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示，没有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">生产者1号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者1号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：2</span><br><span class="line">[product, product, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：3</span><br><span class="line">[product, product, product, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：4</span><br><span class="line">[product, product, product, product, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：5</span><br><span class="line">[product, product, product, product, product, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：6</span><br><span class="line">[product, product, product, product, product, product]</span><br><span class="line">消费者2号消费了一个产品，产品数量：5</span><br><span class="line">[product, product, product, product, product, null]</span><br><span class="line">......</span><br><span class="line">消费者2号消费了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者2号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br><span class="line">生产者2号生产了一个产品，产品数量：1</span><br><span class="line">[product, null, null, null, null, null]</span><br><span class="line">消费者2号消费了一个产品，产品数量：0</span><br><span class="line">[null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h3><p>首先有关线程的使用会出现两个问题：</p>
<ol>
<li>线程是宝贵的内存资源、单个线程约占1MB空间，过多分配易造成内存溢出。</li>
<li>频繁的创建及销毁线程会增加虚拟机回收频率、资源开销，造成性能下降。</li>
</ol>
<p>基于如上的问题，出现了线程池：</p>
<ul>
<li><strong>线程容器</strong>，<strong>可设定线程分配的数量</strong>。</li>
<li><strong>将预先创建的线程对象存入池中</strong>，<strong>并重用线程池中的线程对象</strong>。</li>
<li><strong>避免频繁的创建和销毁</strong>。</li>
</ul>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>假如线程池里固定有三个线程，有四个任务。线程池中的三个线程分别完成三个任务，第四个任务则进入等待状态，线程执行完前三个任务后继续执行第四个任务。</p>
<p><img src="https://pic.downk.cc/item/5fa5382b1cd1bbb86bb07912.png" alt="img"></p>
<ul>
<li>将任务提交给线程池，由线程池分配线程、运行任务，并在当前任务结束后复用线程。</li>
</ul>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul>
<li><p>常用的线程池接口的类 (所在包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent</span><br></pre></td></tr></table></figure>

<p>)</p>
<ul>
<li><p><strong>Executor</strong>：线程池的顶级接口。</p>
</li>
<li><p><strong>ExecutorService</strong>：线程池接口，可通过<code>submit(Runnable task)</code>提交任务代码。</p>
</li>
<li><p>Executors</p>
<p>工厂类：创建线程池的工具类。</p>
<ol>
<li>创建固定线程个数的线程池。</li>
<li>创建缓存线程池，由任务的多少决定。</li>
<li>创建单线程池。</li>
<li>创建调度线程池。调度：周期、定时执行。</li>
</ol>
</li>
<li><p>通过<code>newFixedThreadPool(int nThreads)</code>获得固定数量的线程池。参数：指定线程池中线程的数量。</p>
</li>
<li><p>通过<code>newCachedThreadPool()</code>获得动态数量的线程池，如不够则创建新的，没有上限。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示线程池的创建 (结果同银行卡案例，不再演示)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">        &#x2F;&#x2F;银行卡案例</span><br><span class="line">        BandCard bandCard&#x3D;new BandCard();</span><br><span class="line">        AddMoney addMoney&#x3D;new AddMoney(bandCard);</span><br><span class="line">        SubMoney subMoney&#x3D;new SubMoney(bandCard);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;1.1创建固定线程个数的线程池</span><br><span class="line">        &#x2F;&#x2F;ExecutorService executorService&#x3D;Executors.newFixedThreadPool(4);</span><br><span class="line">        &#x2F;&#x2F;1.2创建缓存线程池，线程个数由任务个数决定</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F;1.3创建单线程线程池</span><br><span class="line">        &#x2F;&#x2F;Executors.newSingleThreadExecutor();</span><br><span class="line">        &#x2F;&#x2F;1.4创建调度线程池</span><br><span class="line">        &#x2F;&#x2F;Executors.newScheduledThreadPool(corePoolSize);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务</span><br><span class="line">        executorService.submit(addMoney);</span><br><span class="line">        executorService.submit(subMoney);</span><br><span class="line">        executorService.submit(addMoney);</span><br><span class="line">        executorService.submit(subMoney);</span><br><span class="line">        &#x2F;&#x2F;等待所有已执行的任务执行完毕后关闭线程池，不再接受新任务</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        &#x2F;&#x2F;会试图停止所有正在执行的任务</span><br><span class="line">        &#x2F;&#x2F;executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt;&#123;</span><br><span class="line">    public V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JDK1.5加入，与Runnable接口类似，实现之后代表一个线程任务。</li>
<li>Callable具有泛型返回值、可以声明异常。</li>
</ul>
<p><strong>与Runnable接口的区别</strong>：</p>
<ol>
<li>Callable接口中call方法有返回值，Runnable接口中run方法没有返回值。</li>
<li>Callable接口中call方法有声明异常，Runnable接口中run方法没有异常。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示Callable接口的使用</span><br><span class="line"> * 功能需求：使用Callable实现1-100的和。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建Callable对象</span><br><span class="line">        Callable&lt;Integer&gt; callable&#x3D;new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            private int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;2.Thread的构造方法中没有带Callable的构造方法</span><br><span class="line">        &#x2F;&#x2F;需要把Callable对象转成可执行任务，FutureTask表示将要执行的任务</span><br><span class="line">        &#x2F;&#x2F;该类实现了RunnableFuture&lt;V&gt;接口，而该接口又继承了Runnable类</span><br><span class="line">        FutureTask&lt;Integer&gt; task&#x3D;new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;3.创建线程对象</span><br><span class="line">        Thread thread&#x3D;new Thread(task);</span><br><span class="line">        &#x2F;&#x2F;4.启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        &#x2F;&#x2F;5.获取结果 (等待call方法执行完毕，才会返回)</span><br><span class="line">        Integer sum&#x3D;task.get();</span><br><span class="line">        System.out.println(&quot;结果是&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable结合线程池使用"><a href="#Callable结合线程池使用" class="headerlink" title="Callable结合线程池使用"></a>Callable结合线程池使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用线程池计算1-100的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newFixedThreadPool(1);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务,Future表示将要执行任务的结果；</span><br><span class="line">        &#x2F;&#x2F;submit可以传入一个Callable&lt;T&gt;对象</span><br><span class="line">        Future&lt;Integer&gt; future&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            private int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;开始计算。。&quot;);</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;3.获取任务的结果 (等待任务完成才会返回)</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        &#x2F;&#x2F;4.关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><ul>
<li><strong>Future</strong>：<strong>表示将要完成任务的结果</strong>。</li>
</ul>
<p>演示一个案例：使用两个线程，并发计算1-50、51-100的和，再进行汇总统计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示Future接口的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService executorService&#x3D;Executors.newFixedThreadPool(2);</span><br><span class="line">        &#x2F;&#x2F;2.提交任务</span><br><span class="line">        Future&lt;Integer&gt; future1&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            &#x2F;&#x2F;计算1-50的和</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;50;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;1-50的和计算完毕。&quot;);</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; future2&#x3D;executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            int sum&#x3D;0;</span><br><span class="line">            @Override</span><br><span class="line">            &#x2F;&#x2F;计算51-100的和</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                for(int i&#x3D;51;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">                    sum+&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;51-100的和计算完毕。&quot;);</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;3.获取结果</span><br><span class="line">        System.out.println(future1.get()+future2.get());</span><br><span class="line">        &#x2F;&#x2F;4.关系线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>表示</strong><code>ExecutorService.submit()</code><strong>所返回的状态结果</strong>，<strong>就是call的返回值</strong>。</li>
<li><strong>方法</strong><code>V get()</code><strong>以阻塞形式等待Future中的异步处理结果</strong> (<strong>call的返回值</strong>)。</li>
</ul>
<h3 id="线程的同步与异步"><a href="#线程的同步与异步" class="headerlink" title="线程的同步与异步"></a>线程的同步与异步</h3><ul>
<li><p><strong>同步</strong></p>
<p>形容一次方法调用，同步一旦开始，调用者必须等待该方法返回，才能继续。</p>
<p>当主线程调用子线程执行任务时，必须等到子线程返回结果后才能继续。</p>
</li>
<li><p><strong>异步</strong></p>
<p>形容一次方法调用，异步一旦开始就像是一次消息传递，调用者告知之后立刻返回。二者竞争时间片，并发执行。<strong>异步有多条执行路径</strong>。</p>
</li>
</ul>
<p><img src="https://pic.downk.cc/item/5fa610c41cd1bbb86bd6d0d9.png" alt="img"></p>
<hr>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><ul>
<li>JDK1.5加入，与synchronized比较，不仅显示定义，而且结构更灵活。</li>
<li>提供了更多实用性方法，功能更强大、性能更优越。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><p><code>void lock</code></p>
<p>获取锁，如果锁被占用，当前线程则进入等待状态。</p>
</li>
<li><p><code>boolean tryLock()</code></p>
<p>尝试获取锁 (成功返回true，失败返回false，不阻塞)</p>
</li>
<li><p><code>void unlock()</code></p>
<p>释放锁。</p>
</li>
</ul>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><ul>
<li><p>ReentrantLock： Lock接口的<strong>实现类</strong>，与synchronized一样具有互斥锁功能。</p>
<p>所谓重入锁，<strong>是指一个线程拿到该锁后</strong>，<strong>还可以再次成功获取</strong>，而不会因为该锁已经被持有 (尽管是自己所持有)而陷入等待状态 (死锁)。<strong>之前说过的synchronized也是可重入锁</strong>。</p>
</li>
</ul>
<h4 id="可重入锁解释及应用"><a href="#可重入锁解释及应用" class="headerlink" title="可重入锁解释及应用"></a>可重入锁解释及应用</h4><p>为了具体解释什么叫可重入锁，这里重写5.4节死锁关于两个人拿筷子吃饭的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Chopsticks &#123;</span><br><span class="line">    boolean getOne&#x3D;false;</span><br><span class="line">    boolean getAnother&#x3D;false;</span><br><span class="line">    &#x2F;&#x2F;拿筷子，获取锁，该锁是当前Chopsticks对象</span><br><span class="line">    public synchronized void getOne() &#123;</span><br><span class="line">        getOne&#x3D;true;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;拿到了一根筷子。&quot;);</span><br><span class="line">        &#x2F;&#x2F;if语句块调用了另外的同步方法，需要再次获取锁，而该锁也是当前Chopsticks对象</span><br><span class="line">        if(getAnother) &#123;</span><br><span class="line">            &#x2F;&#x2F;有两根筷子，吃饭</span><br><span class="line">            canEat();</span><br><span class="line">            &#x2F;&#x2F;吃完放下两根筷子</span><br><span class="line">            getOne&#x3D;false;</span><br><span class="line">            getAnother&#x3D;false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;只有一根筷子，去拿另一根，然后吃饭</span><br><span class="line">            getAnother();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void getAnother() &#123;</span><br><span class="line">        getAnother&#x3D;true;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;拿到了一根筷子。&quot;);</span><br><span class="line">        if(getOne) &#123;</span><br><span class="line">            &#x2F;&#x2F;有两根筷子，吃饭</span><br><span class="line">            canEat();</span><br><span class="line">            &#x2F;&#x2F;吃完放下两根筷子</span><br><span class="line">            getOne&#x3D;false;</span><br><span class="line">            getAnother&#x3D;false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;只有一根筷子，去拿另一根，然后吃饭</span><br><span class="line">            getOne();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void canEat() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;拿到了两根筷子，开恰！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个筷子类中，拿第一根筷子的时候获取了一把锁，锁对象是this，也就是当前Chopsticks对象；拿第二根筷子的时候又获取了一次锁，锁对象是this，也是当前Chopsticks对象。测试类如下，说明在后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class testChopstick &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Chopsticks chopsticks&#x3D;new Chopsticks();</span><br><span class="line">        &#x2F;&#x2F;线程A,模拟人A</span><br><span class="line">        Thread A&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                chopsticks.getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;线程B，模拟人B</span><br><span class="line">        Thread B&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                chopsticks.getAnother();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程都执行的是<strong>同一个对象</strong>chopsticks中的方法，这两个同步方法在执行时将会<strong>获取同样的锁</strong>；当线程1抢到CUP进入getOne时获取锁然后执行代码，如果线程1<strong>还未</strong>执行完毕就被线程2抢占了CPU，当线程2进入getAnother时发现锁在线程1那里，<strong>于是线程2等待</strong>；线程1重新拿到CPU继续执行代码，进入getAnother方法获取锁，<strong>发现锁就在自己这里</strong>，<strong>于是继续执行</strong>，<strong>这就是可重入锁</strong>。可重入锁避免了死锁的发生，避免线程因获取不了锁而进入永久等待状态。</p>
<p>上述代码运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0拿到了一根筷子。</span><br><span class="line">Thread-0拿到了一根筷子。</span><br><span class="line">Thread-0拿到了两根筷子，开恰！</span><br><span class="line">Thread-1拿到了一根筷子。</span><br><span class="line">Thread-1拿到了一根筷子。</span><br><span class="line">Thread-1拿到了两根筷子，开恰！</span><br></pre></td></tr></table></figure>

<h4 id="重入锁的使用"><a href="#重入锁的使用" class="headerlink" title="重入锁的使用"></a>重入锁的使用</h4><p>还是以2.5节卖票案例为例进行演示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重入锁的使用</span><br><span class="line">public class Ticket implements Runnable&#123;</span><br><span class="line">    int ticket&#x3D;100;</span><br><span class="line">    &#x2F;&#x2F;创建重入锁对象</span><br><span class="line">    Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;    </span><br><span class="line">        while(true) &#123;    </span><br><span class="line">            &#x2F;&#x2F;上锁        </span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;                    </span><br><span class="line">                if(ticket&gt;0)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;卖出了一张票，还剩&quot;+(--ticket)+&quot;张。&quot;);</span><br><span class="line">                else break;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F;解锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要注意一下上锁后记得解锁，有几个lock就要有对应的几个unlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class testTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket&#x3D;new Ticket();</span><br><span class="line">        &#x2F;&#x2F;1.创建线程池</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(4);</span><br><span class="line">        &#x2F;&#x2F;2.提交四次，让四个线程来运行</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++) &#123;</span><br><span class="line">            eService.submit(new Ticket());</span><br><span class="line">        &#125;</span><br><span class="line">        eService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果不再演示。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>ReentrantReadWriteLock：</p>
<ul>
<li>一种支持一写多读的同步锁，读写分离，可以分别分配读锁和写锁。</li>
<li>支持多次分配读锁，使多个读操作可以并发执行。</li>
</ul>
<p>互斥规则：</p>
<ul>
<li>写—-写：互斥，一个线程在写的同时其他线程会被阻塞。</li>
<li>读—-写：互斥，读的时候不能写，写的时候不能读。</li>
<li>读—-读：不互斥、不阻塞。</li>
<li>在读操作远远高于写操作的环境中，可在保证线程安全的情况下，提高运行效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示读写锁的使用</span><br><span class="line">public class ReadWriteLock &#123;</span><br><span class="line">        &#x2F;&#x2F;创建读写锁对象</span><br><span class="line">        ReentrantReadWriteLock rrlLock&#x3D;new ReentrantReadWriteLock();</span><br><span class="line">        ReadLock readLock&#x3D;rrlLock.readLock();&#x2F;&#x2F;获得读锁</span><br><span class="line">        WriteLock writeLock&#x3D;rrlLock.writeLock();&#x2F;&#x2F;获得写锁</span><br><span class="line">        private int value&#x3D;999;</span><br><span class="line">        &#x2F;&#x2F;读方法</span><br><span class="line">        public int getValue() &#123;</span><br><span class="line">            readLock.lock();&#x2F;&#x2F;开启读锁</span><br><span class="line">            try &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return this.value;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                readLock.unlock();&#x2F;&#x2F;释放读锁</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;写方法</span><br><span class="line">        public void setValue(int value) &#123;</span><br><span class="line">            writeLock.lock();&#x2F;&#x2F;开启写锁</span><br><span class="line">            try &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                this.value&#x3D;value;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                writeLock.unlock();&#x2F;&#x2F;释放写锁</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testReadWriteLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(20);</span><br><span class="line">        ReadWriteLock rwlLock&#x3D;new ReadWriteLock();</span><br><span class="line">        Runnable read&#x3D;new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(rwlLock.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write&#x3D;new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                rwlLock.setValue(666);</span><br><span class="line">                System.out.println(&quot;改写为666&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;写2次</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++) &#123;</span><br><span class="line">            eService.submit(write);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读18次</span><br><span class="line">        for(int i&#x3D;0;i&lt;18;i++) &#123;</span><br><span class="line">            eService.submit(read);</span><br><span class="line">        &#125;    </span><br><span class="line">        eService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用sleep可以观察到，只有在读写交替和两个写操作的时候程序是互斥执行，而在读操作时线程之间是并发执行。</p>
<hr>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>下图中蓝色的表示线程安全的集合，绿色表示现代开发中已经很少使用的线程安全的集合。</p>
<ul>
<li><p>Collection体系集合</p>
</li>
<li><p>Map安全集合体系</p>
</li>
</ul>
<p><strong>在多线程中使用线程不安全的集合会出现异常</strong>。在JDK1.5之前，可以使用Collections中的工具类方法。</p>
<p>Collections工具类中提供了多个可以获得线程安全集合的方法：</p>
<ul>
<li><code>public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></li>
<li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li><code>public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
<li><code>public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></li>
<li><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt;)</code></li>
</ul>
<p>以上为JDK1.2提供，接口单一、维护性高，但性能没有提升，均以synchronized实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.使用ArrayList (不经过2步骤则报异常)</span><br><span class="line">        ArrayList&lt;String&gt; arrayList&#x3D;new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2 使用Collections中的线程安全方法转成线程安全的集合</span><br><span class="line">        List&lt;String&gt; synList&#x3D;Collections.synchronizedList(arrayList);</span><br><span class="line">        &#x2F;&#x2F;3 使用并发包里提供的集合</span><br><span class="line">        &#x2F;&#x2F;OnWriteArrayList&lt;String&gt; arrayList2&#x3D;new OnWriteArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;20;i++) &#123;</span><br><span class="line">            int temp&#x3D;i;</span><br><span class="line">            new Thread(new Runnable() &#123;            </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;10;j++) &#123;</span><br><span class="line">                        synList.add(Thread.currentThread().getName()+&quot;:&quot;+temp);</span><br><span class="line">                        System.out.println(synList.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把ArrayList转成线程安全的集合后程序正常运行，结果不再演示。</p>
<h3 id="OnWriteArrayList集合"><a href="#OnWriteArrayList集合" class="headerlink" title="OnWriteArrayList集合"></a>OnWriteArrayList集合</h3><ul>
<li>线程安全的ArrayList，加强版的读写分离。</li>
<li>写有锁，读无锁，读写之间不堵塞，优于读写锁。</li>
<li>写入时，先一个容器副本、再添加新元素，最后替换引用。所以说它是用空间换安全的一种方式。</li>
<li>使用ArrayList无异。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 演示OnWriteArrayList的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建集合</span><br><span class="line">        OnWriteArrayList&lt;String&gt; list&#x3D;new OnWriteArrayList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F;2.使用多线程操作</span><br><span class="line">        ExecutorService eService&#x3D;Executors.newFixedThreadPool(5);</span><br><span class="line">        &#x2F;&#x2F;3.提交任务</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++) &#123;</span><br><span class="line">            eService.submit(new Runnable() &#123;            </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;10;j++) &#123;</span><br><span class="line">                        list.add(Thread.currentThread().getName()+&quot;...&quot;+new Random().nextInt(1000));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;4.关闭线程池</span><br><span class="line">        eService.shutdown();</span><br><span class="line">        &#x2F;&#x2F;等所有线程都执行完毕</span><br><span class="line">        while(!eService.isTerminated());</span><br><span class="line">        &#x2F;&#x2F;5.打印结果</span><br><span class="line">        System.out.println(&quot;元素个数：&quot;+list.size());</span><br><span class="line">        for (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，没有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">元素个数：50</span><br><span class="line">pool-1-thread-2...222</span><br><span class="line">pool-1-thread-2...688</span><br><span class="line">pool-1-thread-2...770</span><br><span class="line">    ......</span><br><span class="line">pool-1-thread-4...568</span><br><span class="line">pool-1-thread-4...537</span><br><span class="line">pool-1-thread-4...413</span><br></pre></td></tr></table></figure>

<h3 id="OnWriteArrayList源码分析"><a href="#OnWriteArrayList源码分析" class="headerlink" title="OnWriteArrayList源码分析"></a>OnWriteArrayList源码分析</h3><ul>
<li><p><code>final transient ReentrantLock lock = new ReentrantLock();</code></p>
<p>此集合所使用的的锁lock是重入锁ReentrantLock。</p>
</li>
<li><p><code>private transient volatile Object[] array;</code></p>
<p>此集合实际存储的数组array。</p>
</li>
<li><p>在上节中调用的无参构造方法创建的是一个空的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OnWriteArrayList() &#123;</span><br><span class="line">    setArray(new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void setArray(Object[] a) &#123;</span><br><span class="line">    array &#x3D; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>add(E)</code>添加元素是先把原来的数组到一个长度减1的新数组里，然后对新数组进行操作，最后再把新数组赋给原数组。这个操作上了锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        Object[] newElements &#x3D; Arrays.Of(elements, len + 1);</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove(int)</code>删除元素同样是复制原数组到一个长度加1的新数组里，然后对新数组进行操作，最后再把新数组赋给原数组。这个操作也上了锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        E oldValue &#x3D; get(elements, index);</span><br><span class="line">        int numMoved &#x3D; len - index - 1;</span><br><span class="line">        if (numMoved &#x3D;&#x3D; 0)</span><br><span class="line">            setArray(Arrays.Of(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">            System.array(elements, 0, newElements, 0, index);</span><br><span class="line">            System.array(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关数组修改的操作都上了锁，也就说写操作是互斥访问的。</p>
<p>有关读操作的代码都是直接进行了访问，没有上锁，也就是说在写的同时可以读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="OnWriteArraySet集合"><a href="#OnWriteArraySet集合" class="headerlink" title="OnWriteArraySet集合"></a>OnWriteArraySet集合</h3><ul>
<li><p>线程安全的Set，底层使用OnWriteArrayList实现。</p>
</li>
<li><p>唯一不同在于，使用<code>addIfAbsent()</code>添加元素，会遍历数组，如果已有元素 (比较依据是equals)，则不添加 (扔掉副本)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示OnWriteArraySet的使用</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OnWriteArraySet&lt;String&gt; set&#x3D;new OnWriteArraySet&lt;String&gt;();</span><br><span class="line">        set.add(&quot;tang&quot;);</span><br><span class="line">        set.add(&quot;he&quot;);</span><br><span class="line">        set.add(&quot;yu&quot;);</span><br><span class="line">        set.add(&quot;wang&quot;);</span><br><span class="line">        set.add(&quot;tang&quot;);&#x2F;&#x2F;重复元素，添加失败</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个set集合是顺序输出的，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">[tang, he, yu, wang]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="OnWriteArraySet源码分析"><a href="#OnWriteArraySet源码分析" class="headerlink" title="OnWriteArraySet源码分析"></a>OnWriteArraySet源码分析</h3><ul>
<li><p><code>private final OnWriteArrayList&lt;E&gt; al</code></p>
<p>这个集合实际上使用的就是OnWriteArrayList集合。</p>
</li>
<li><p>它的无参构造方法new的就是OnWriteArrayList对象，所以它是有序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OnWriteArraySet() &#123;</span><br><span class="line">    al &#x3D; new OnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素的操作和OnWriteArrayList大同小异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean addIfAbsent(E e) &#123;</span><br><span class="line">    Object[] snapshot &#x3D; getArray();</span><br><span class="line">    return indexOf(e, snapshot, 0, snapshot.length) &gt;&#x3D; 0 ? false :</span><br><span class="line">    addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个三元表达式，意思是存在相同元素返回false，否则添加元素。</p>
<p>先进入indexOf方法查看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int indexOf(Object o, Object[] elements,</span><br><span class="line">                           int index, int fence) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; index; i &lt; fence; i++)</span><br><span class="line">            if (elements[i] &#x3D;&#x3D; null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; index; i &lt; fence; i++)</span><br><span class="line">            if (o.equals(elements[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是添加单个元素，index参数就是0，这个方法就是在遍历数组，如果数组中已经存在相同元素则返回数组下标，注意看它的比较依据是equals方法；如果不存在则返回-1。</p>
<p>在<code>addIfAbsent</code>所返回的三元表达式中，如果indexOf方法返回数组下标，则返回false，表示已经存在相同元素，添加失败；否则返回-1执行<code>addIfAbsent(e, snapshot)</code>，进入该方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] current &#x3D; getArray();</span><br><span class="line">        int len &#x3D; current.length;</span><br><span class="line">        if (snapshot !&#x3D; current) &#123;</span><br><span class="line">            &#x2F;&#x2F; Optimize for lost race to another addXXX operation</span><br><span class="line">            int common &#x3D; Math.min(snapshot.length, len);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; common; i++)</span><br><span class="line">                if (current[i] !&#x3D; snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    return false;</span><br><span class="line">            if (indexOf(e, current, common, len) &gt;&#x3D; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements &#x3D; Arrays.Of(current, len + 1);</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以忽略if语句，重点关注它的添加操作，发现它也将原数组到长度加一的新数组中，再对新数组进行操作，这个写操作上了锁。其他的写方法都调用了OnWriteArrayList的方法，同样是写操作上锁，读操作可以同时执行。</p>
</li>
</ul>
<h2 id="Queue接口-队列"><a href="#Queue接口-队列" class="headerlink" title="Queue接口 (队列)"></a>Queue接口 (队列)</h2><p>Collection的子接口，表示队列FIFO (First In First Out)，先进先出。</p>
<p>常用方法：</p>
<ul>
<li><p>抛出异常：</p>
<ul>
<li><p><code>boolean add(E e)</code></p>
<p>顺序添加一个元素 (到达上限后，再添加则会抛出异常)。</p>
</li>
<li><p><code>E remove()</code></p>
<p>获得第一个元素并移除 (如果队列没有元素时，则抛出异常)。</p>
</li>
<li><p><code>E element()</code></p>
<p>获得第一个元素但不移除 (如果队列没有元素时，则抛异常)。</p>
</li>
</ul>
</li>
<li><p>返回特殊值： (<strong>建议使用以下方法</strong>)</p>
<ul>
<li><p><code>boolean offer(E e)</code></p>
<p>顺序添加一个元素 (到达上限后，再添加则会返回false)。</p>
</li>
<li><p><code>E poll()</code></p>
<p>获得第一个元素并移除 (如果队列没有元素时，则返回null)。</p>
</li>
<li><p><code>E peek()</code></p>
<p>获得第一个元素但不移除 (如果队列没有元素时，则返回null)。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示Queue实现类的使用</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建队列</span><br><span class="line">        Queue&lt;String&gt; queue&#x3D;new LinkedList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F;入队</span><br><span class="line">        queue.offer(&quot;tang&quot;);</span><br><span class="line">        queue.offer(&quot;he&quot;);</span><br><span class="line">        queue.offer(&quot;yu&quot;);</span><br><span class="line">        queue.offer(&quot;wang&quot;);</span><br><span class="line">        queue.offer(&quot;fan&quot;);</span><br><span class="line">        System.out.println(&quot;队首元素：&quot;+queue.peek());</span><br><span class="line">        System.out.println(&quot;元素个数：&quot;+queue.size());</span><br><span class="line">        &#x2F;&#x2F;出队</span><br><span class="line">        int size&#x3D;queue.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;size;i++) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;出队完毕：&quot;+queue.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是因为LinkedList是线程不安全的集合，所以不能在多线程的环境中使用。该程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">队首元素：tang</span><br><span class="line">元素个数：5</span><br><span class="line">tang</span><br><span class="line">he</span><br><span class="line">yu</span><br><span class="line">wang</span><br><span class="line">fan</span><br><span class="line">出队完毕：0</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentLinkedQueue类"><a href="#ConcurrentLinkedQueue类" class="headerlink" title="ConcurrentLinkedQueue类"></a>ConcurrentLinkedQueue类</h3><ul>
<li><p>Queue接口的实现类。线程安全、可高效读写的队列，高并发下性能最好的队列。</p>
</li>
<li><p>无锁、CAS (Compare and Swap)比较交换算法，修改的方法包含三个核心参数 (V,E,N)。</p>
</li>
<li><p>V：要更新的变量；E：预期值；N：新值。</p>
</li>
<li><p>只有当V==E，V=N；否则表示V已被更新过，则取消当前操作。</p>
<p>也就是说假如当前值V是80，要将其改成100，先将V读取出来，读取的V就是预期值；如果预期值E和V相等，就把V的值更新成新值100；如果不等，说明中间有其他线程更新了V，就取消当前操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示线程安全的队列</span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建安全队列</span><br><span class="line">        ConcurrentLinkedQueue&lt;Integer&gt; queue&#x3D;new ConcurrentLinkedQueue&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;两个线程执行入队操作</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;5;i++) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;6;i&lt;&#x3D;10;i++) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;启动线程</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;10;i++) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是两个线程同时添加，所以结果不是顺序的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue接口-阻塞队列"><a href="#BlockingQueue接口-阻塞队列" class="headerlink" title="BlockingQueue接口 (阻塞队列)"></a>BlockingQueue接口 (阻塞队列)</h3><ul>
<li><p><strong>Queue的子接口</strong>，阻塞的队列，增加了两个线程状态为无限期等待的方法。</p>
</li>
<li><p>方法</p>
<ul>
<li><p><code>void put(E e)</code></p>
<p>将指定元素插入此队列中，如果没有可用空间，则等待。</p>
</li>
<li><p><code>E take()</code></p>
<p>获取并移除此队列头部元素，如果没有可用元素，则等待。</p>
</li>
</ul>
</li>
<li><p><strong>可用于解决生产者</strong>、<strong>消费者问题</strong>。</p>
</li>
</ul>
<h4 id="阻塞队列-实现类"><a href="#阻塞队列-实现类" class="headerlink" title="阻塞队列 (实现类)"></a>阻塞队列 (实现类)</h4><ul>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组结构实现，有界队列。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链表结构实现，有界队列。默认上限<code>Integer.MAX_VALUE</code>。</p>
</li>
</ul>
<p>通过一个小程序演示一下所谓的阻塞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个有界队列</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue&#x3D;new ArrayBlockingQueue&lt;Integer&gt;(3);</span><br><span class="line">        &#x2F;&#x2F;添加数据使用put</span><br><span class="line">        arrayBlockingQueue.put(1);</span><br><span class="line">        arrayBlockingQueue.put(2);</span><br><span class="line">        arrayBlockingQueue.put(3);</span><br><span class="line">        System.out.println(arrayBlockingQueue.size());</span><br><span class="line">        System.out.println(arrayBlockingQueue.toString());</span><br><span class="line">        arrayBlockingQueue.put(4);</span><br><span class="line">        System.out.println(&quot;我不会被执行。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序执行后可以通过控制台看见程序并没有结束，也没有打印最后一句话，说明当前线程 (主线程)被阻塞了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="重写生产者消费者问题"><a href="#重写生产者消费者问题" class="headerlink" title="重写生产者消费者问题"></a>重写生产者消费者问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建队列</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue&#x3D;new ArrayBlockingQueue&lt;Integer&gt;(6);</span><br><span class="line">        &#x2F;&#x2F;创建两个线程</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;30;i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(i);</span><br><span class="line">                        System.out.println(&quot;生产者生产了一个产品，产品ID：&quot;+i);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;        </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i&#x3D;1;i&lt;&#x3D;30;i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者消费了一个产品，产品ID：&quot;+i);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是插入队尾的方法是put，删除队首元素的方法是take。结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">生产者生产了一个产品，产品ID：1</span><br><span class="line">生产者生产了一个产品，产品ID：2</span><br><span class="line">生产者生产了一个产品，产品ID：3</span><br><span class="line">生产者生产了一个产品，产品ID：4</span><br><span class="line">生产者生产了一个产品，产品ID：5</span><br><span class="line">生产者生产了一个产品，产品ID：6</span><br><span class="line">消费者消费了一个产品，产品ID：1</span><br><span class="line">    ......</span><br><span class="line">消费者消费了一个产品，产品ID：25</span><br><span class="line">消费者消费了一个产品，产品ID：26</span><br><span class="line">消费者消费了一个产品，产品ID：27</span><br><span class="line">消费者消费了一个产品，产品ID：28</span><br><span class="line">消费者消费了一个产品，产品ID：29</span><br><span class="line">消费者消费了一个产品，产品ID：30</span><br></pre></td></tr></table></figure>

<h2 id="10-ConcurrentHashMap"><a href="#10-ConcurrentHashMap" class="headerlink" title="10. ConcurrentHashMap"></a>10. ConcurrentHashMap</h2><ul>
<li>初始容量默认为16段 (Segment)，使用分段锁设计。每一段都对应着一个哈希表。</li>
<li>不对整个Map加锁，而是为每个Segment加锁。对一个Segment的操作不影响其他Segment。</li>
<li>当多个对象存入同一个Segment时，才需要互斥。</li>
<li>最理想状态为16个对象分别存入16个Segment，并行数量16。</li>
<li>使用方式与HashMap无异。</li>
</ul>
<p>注：在JDK1.8之后，ConcurrentHashMap不再采用分段锁，而是采用无锁算法CAS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示线程安全的Map</span><br><span class="line">public class Demo8 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建集合</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; hashMap&#x3D;new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F;使用多线程添加数据</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;                </span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int k&#x3D;0;k&lt;10;k++) &#123;</span><br><span class="line">                        hashMap.put(Thread.currentThread().getName(), k);</span><br><span class="line">                        System.out.println(hashMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有问题，不再演示结果。</p>
<p>这篇博客真的好长，但想着分成几篇又不方便回顾。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaSE/" rel="tag"># JavaSE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020-10-%E5%BC%82%E5%B8%B8/" rel="prev" title="JavaSE-异常">
      <i class="fa fa-chevron-left"></i> JavaSE-异常
    </a></div>
      <div class="post-nav-item">
    <a href="/2021-01-JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" rel="next" title="JavaSE-集合框架">
      JavaSE-集合框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">什么是进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.4.</span> <span class="nav-text">线程的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">线程的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">线程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">继承Thread创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="nav-number">2.2.</span> <span class="nav-text">获取和修改线程名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">2.3.</span> <span class="nav-text">一个线程小案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">实现Runnable创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">2.5.</span> <span class="nav-text">Runnable小案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95"><span class="nav-number">2.6.</span> <span class="nav-text">Thread和Runnable的区别及正确写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81-%E6%BA%90%E7%A0%81%E8%A1%A5%E5%85%85"><span class="nav-number">3.</span> <span class="nav-text">线程基本状态 (源码补充)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">线程常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">5.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E6%AD%BB%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">经典问题 (死锁)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">5.4.</span> <span class="nav-text">线程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">5.5.</span> <span class="nav-text">经典问题 (生产者消费者)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">线程池概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">线程池原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.3.</span> <span class="nav-text">创建线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.4.</span> <span class="nav-text">Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%E7%BB%93%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8"><span class="nav-number">6.5.</span> <span class="nav-text">Callable结合线程池使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.6.</span> <span class="nav-text">Future接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">6.7.</span> <span class="nav-text">线程的同步与异步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">Lock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">7.1.</span> <span class="nav-text">重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">7.1.1.</span> <span class="nav-text">可重入锁解释及应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.1.2.</span> <span class="nav-text">重入锁的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">7.2.</span> <span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">8.</span> <span class="nav-text">线程安全的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OnWriteArrayList%E9%9B%86%E5%90%88"><span class="nav-number">8.1.</span> <span class="nav-text">OnWriteArrayList集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">8.2.</span> <span class="nav-text">OnWriteArrayList源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OnWriteArraySet%E9%9B%86%E5%90%88"><span class="nav-number">8.3.</span> <span class="nav-text">OnWriteArraySet集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OnWriteArraySet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">8.4.</span> <span class="nav-text">OnWriteArraySet源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue%E6%8E%A5%E5%8F%A3-%E9%98%9F%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text">Queue接口 (队列)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentLinkedQueue%E7%B1%BB"><span class="nav-number">9.1.</span> <span class="nav-text">ConcurrentLinkedQueue类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue%E6%8E%A5%E5%8F%A3-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">9.2.</span> <span class="nav-text">BlockingQueue接口 (阻塞队列)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">9.2.1.</span> <span class="nav-text">阻塞队列 (实现类)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">9.2.2.</span> <span class="nav-text">重写生产者消费者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-ConcurrentHashMap"><span class="nav-number">10.</span> <span class="nav-text">10. ConcurrentHashMap</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a href="/" class="site-author-image" rel="start" style="border:none">
    <img class="site-author-image" itemprop="image" alt="Mw"
      src="/images/Mw.png">
  </a>
  <p class="site-author-name" itemprop="name">Mw</p>
  <div class="site-description" itemprop="description">God is Developer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL213LWdo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mw-gh"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOm13LW1zQG91dGxvb2suY29t" title="E-Mail → mailto:mw-ms@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVubXc=" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Chenmw"><i class=" fa-fw"></i>知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vcC8xMDA1MDU2MDgyMjU0MTIyL2hvbWU/ZnJvbT1wYWdlXzEwMDUwNSZtb2Q9VEFCJmlzX2FsbD0xI3BsYWNl" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;p&#x2F;1005056082254122&#x2F;home?from&#x3D;page_100505&amp;mod&#x3D;TAB&amp;is_all&#x3D;1#place"><i class="fab fa-weibo fa-fw"></i>Weibo</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTMyOTc4NTI3MA==" title="网易云 → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;329785270"><i class=" fa-fw"></i>网易云</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">

&copy; 
<span itemprop="copyrightYear">2021</span>
<span class="with-love">
    <i class="fa fa-heart"></i>
</span>
<span class="author" itemprop="copyrightHolder">Mw</span>
</div>


<div class="wordcount">
    <span class="post-meta-item-icon">
    <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">347k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:16</span>
</div>
<div class="busuanzi-count">
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
    <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
    </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
    <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
    </span>
    </span>
</div>
<div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9tdXNlLnRoZW1lLW5leHQub3Jn">NexT.Muse</span> 强力驱动
</div>
        






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'KpFGcS5UDEldJtRGnAwWSgfA-9Nh9j0Va',
      appKey     : 'mQBf0bbk986bOA6XAFKPvgkU',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
